//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.1.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResetPasswordOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResetPasswordOutput>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonateUser(body: ImpersonateUserInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ImpersonateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processImpersonateUser(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonateTenant(body: ImpersonateTenantInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ImpersonateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processImpersonateTenant(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegatedImpersonate(body: DelegatedImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/DelegatedImpersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processDelegatedImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchToLinkedAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchToLinkedAccountOutput>;
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAuditLogListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAuditLogListDto>;
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueDto[]>;
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | undefined, entityTypeFullName: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | undefined, entityId: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | undefined, entityTypeFullName: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' cannot be null.");
        else if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityPropertyChangeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityPropertyChangeDto[]>;
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessAccountTeamsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param primaryFilter (optional) 
     * @param businessNameFilter (optional) 
     * @param employeeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, primaryFilter: number | undefined, businessNameFilter: string | undefined, employeeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetBusinessAccountTeamForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessAccountTeams/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (primaryFilter === null)
            throw new Error("The parameter 'primaryFilter' cannot be null.");
        else if (primaryFilter !== undefined)
            url_ += "PrimaryFilter=" + encodeURIComponent("" + primaryFilter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (employeeNameFilter === null)
            throw new Error("The parameter 'employeeNameFilter' cannot be null.");
        else if (employeeNameFilter !== undefined)
            url_ += "EmployeeNameFilter=" + encodeURIComponent("" + employeeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetBusinessAccountTeamForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetBusinessAccountTeamForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusinessAccountTeamForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBusinessAccountTeamForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessAccountTeamForView(id: number | undefined): Observable<GetBusinessAccountTeamForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessAccountTeams/GetBusinessAccountTeamForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessAccountTeamForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessAccountTeamForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessAccountTeamForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessAccountTeamForViewDto>;
        }));
    }

    protected processGetBusinessAccountTeamForView(response: HttpResponseBase): Observable<GetBusinessAccountTeamForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessAccountTeamForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessAccountTeamForEdit(id: number | undefined): Observable<GetBusinessAccountTeamForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessAccountTeams/GetBusinessAccountTeamForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessAccountTeamForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessAccountTeamForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessAccountTeamForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessAccountTeamForEditOutput>;
        }));
    }

    protected processGetBusinessAccountTeamForEdit(response: HttpResponseBase): Observable<GetBusinessAccountTeamForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessAccountTeamForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBusinessAccountTeamDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessAccountTeams/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessAccountTeams/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param primaryFilter (optional) 
     * @param businessNameFilter (optional) 
     * @param employeeNameFilter (optional) 
     * @return Success
     */
    getBusinessAccountTeamsToExcel(filter: string | undefined, primaryFilter: number | undefined, businessNameFilter: string | undefined, employeeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessAccountTeams/GetBusinessAccountTeamsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (primaryFilter === null)
            throw new Error("The parameter 'primaryFilter' cannot be null.");
        else if (primaryFilter !== undefined)
            url_ += "PrimaryFilter=" + encodeURIComponent("" + primaryFilter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (employeeNameFilter === null)
            throw new Error("The parameter 'employeeNameFilter' cannot be null.");
        else if (employeeNameFilter !== undefined)
            url_ += "EmployeeNameFilter=" + encodeURIComponent("" + employeeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessAccountTeamsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessAccountTeamsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetBusinessAccountTeamsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessAccountTeams/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllEmployeeForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessAccountTeams/GetAllEmployeeForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployeeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployeeForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto>;
        }));
    }

    protected processGetAllEmployeeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessContactMapsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param contactFullNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, businessNameFilter: string | undefined, contactFullNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetBusinessContactMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessContactMaps/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (contactFullNameFilter === null)
            throw new Error("The parameter 'contactFullNameFilter' cannot be null.");
        else if (contactFullNameFilter !== undefined)
            url_ += "ContactFullNameFilter=" + encodeURIComponent("" + contactFullNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetBusinessContactMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetBusinessContactMapForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusinessContactMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBusinessContactMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessContactMapForView(id: number | undefined): Observable<GetBusinessContactMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessContactMaps/GetBusinessContactMapForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessContactMapForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessContactMapForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessContactMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessContactMapForViewDto>;
        }));
    }

    protected processGetBusinessContactMapForView(response: HttpResponseBase): Observable<GetBusinessContactMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessContactMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessContactMapForEdit(id: number | undefined): Observable<GetBusinessContactMapForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessContactMaps/GetBusinessContactMapForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessContactMapForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessContactMapForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessContactMapForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessContactMapForEditOutput>;
        }));
    }

    protected processGetBusinessContactMapForEdit(response: HttpResponseBase): Observable<GetBusinessContactMapForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessContactMapForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBusinessContactMapDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessContactMaps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessContactMaps/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param contactFullNameFilter (optional) 
     * @return Success
     */
    getBusinessContactMapsToExcel(filter: string | undefined, businessNameFilter: string | undefined, contactFullNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessContactMaps/GetBusinessContactMapsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (contactFullNameFilter === null)
            throw new Error("The parameter 'contactFullNameFilter' cannot be null.");
        else if (contactFullNameFilter !== undefined)
            url_ += "ContactFullNameFilter=" + encodeURIComponent("" + contactFullNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessContactMapsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessContactMapsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetBusinessContactMapsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessContactMapBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessContactMaps/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessContactMapBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessContactMapBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessContactMapBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessContactMapBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllContactForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessContactMapContactLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessContactMaps/GetAllContactForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContactForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContactForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessContactMapContactLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessContactMapContactLookupTableDto>;
        }));
    }

    protected processGetAllContactForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessContactMapContactLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessContactMapContactLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param tradeNameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param customIdFilter (optional) 
     * @param yearOfEstablishmentFilter (optional) 
     * @param locationTitleFilter (optional) 
     * @param fullAddressFilter (optional) 
     * @param address1Filter (optional) 
     * @param address2Filter (optional) 
     * @param cityFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param phoneFilter (optional) 
     * @param faxFilter (optional) 
     * @param emailFilter (optional) 
     * @param websiteFilter (optional) 
     * @param einTaxIdFilter (optional) 
     * @param industryFilter (optional) 
     * @param internalRemarksFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param facebookFilter (optional) 
     * @param linkedInFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param cityNameFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, tradeNameFilter: string | undefined, descriptionFilter: string | undefined, customIdFilter: string | undefined, yearOfEstablishmentFilter: string | undefined, locationTitleFilter: string | undefined, fullAddressFilter: string | undefined, address1Filter: string | undefined, address2Filter: string | undefined, cityFilter: string | undefined, zipCodeFilter: string | undefined, maxLatitudeFilter: number | undefined, minLatitudeFilter: number | undefined, maxLongitudeFilter: number | undefined, minLongitudeFilter: number | undefined, phoneFilter: string | undefined, faxFilter: string | undefined, emailFilter: string | undefined, websiteFilter: string | undefined, einTaxIdFilter: string | undefined, industryFilter: string | undefined, internalRemarksFilter: string | undefined, verifiedFilter: number | undefined, facebookFilter: string | undefined, linkedInFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, cityNameFilter: string | undefined, mediaLibraryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetBusinessForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Businesses/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (tradeNameFilter === null)
            throw new Error("The parameter 'tradeNameFilter' cannot be null.");
        else if (tradeNameFilter !== undefined)
            url_ += "TradeNameFilter=" + encodeURIComponent("" + tradeNameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (customIdFilter === null)
            throw new Error("The parameter 'customIdFilter' cannot be null.");
        else if (customIdFilter !== undefined)
            url_ += "CustomIdFilter=" + encodeURIComponent("" + customIdFilter) + "&";
        if (yearOfEstablishmentFilter === null)
            throw new Error("The parameter 'yearOfEstablishmentFilter' cannot be null.");
        else if (yearOfEstablishmentFilter !== undefined)
            url_ += "YearOfEstablishmentFilter=" + encodeURIComponent("" + yearOfEstablishmentFilter) + "&";
        if (locationTitleFilter === null)
            throw new Error("The parameter 'locationTitleFilter' cannot be null.");
        else if (locationTitleFilter !== undefined)
            url_ += "LocationTitleFilter=" + encodeURIComponent("" + locationTitleFilter) + "&";
        if (fullAddressFilter === null)
            throw new Error("The parameter 'fullAddressFilter' cannot be null.");
        else if (fullAddressFilter !== undefined)
            url_ += "FullAddressFilter=" + encodeURIComponent("" + fullAddressFilter) + "&";
        if (address1Filter === null)
            throw new Error("The parameter 'address1Filter' cannot be null.");
        else if (address1Filter !== undefined)
            url_ += "Address1Filter=" + encodeURIComponent("" + address1Filter) + "&";
        if (address2Filter === null)
            throw new Error("The parameter 'address2Filter' cannot be null.");
        else if (address2Filter !== undefined)
            url_ += "Address2Filter=" + encodeURIComponent("" + address2Filter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (maxLatitudeFilter === null)
            throw new Error("The parameter 'maxLatitudeFilter' cannot be null.");
        else if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&";
        if (minLatitudeFilter === null)
            throw new Error("The parameter 'minLatitudeFilter' cannot be null.");
        else if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&";
        if (maxLongitudeFilter === null)
            throw new Error("The parameter 'maxLongitudeFilter' cannot be null.");
        else if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&";
        if (minLongitudeFilter === null)
            throw new Error("The parameter 'minLongitudeFilter' cannot be null.");
        else if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&";
        if (phoneFilter === null)
            throw new Error("The parameter 'phoneFilter' cannot be null.");
        else if (phoneFilter !== undefined)
            url_ += "PhoneFilter=" + encodeURIComponent("" + phoneFilter) + "&";
        if (faxFilter === null)
            throw new Error("The parameter 'faxFilter' cannot be null.");
        else if (faxFilter !== undefined)
            url_ += "FaxFilter=" + encodeURIComponent("" + faxFilter) + "&";
        if (emailFilter === null)
            throw new Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&";
        if (websiteFilter === null)
            throw new Error("The parameter 'websiteFilter' cannot be null.");
        else if (websiteFilter !== undefined)
            url_ += "WebsiteFilter=" + encodeURIComponent("" + websiteFilter) + "&";
        if (einTaxIdFilter === null)
            throw new Error("The parameter 'einTaxIdFilter' cannot be null.");
        else if (einTaxIdFilter !== undefined)
            url_ += "EinTaxIdFilter=" + encodeURIComponent("" + einTaxIdFilter) + "&";
        if (industryFilter === null)
            throw new Error("The parameter 'industryFilter' cannot be null.");
        else if (industryFilter !== undefined)
            url_ += "IndustryFilter=" + encodeURIComponent("" + industryFilter) + "&";
        if (internalRemarksFilter === null)
            throw new Error("The parameter 'internalRemarksFilter' cannot be null.");
        else if (internalRemarksFilter !== undefined)
            url_ += "InternalRemarksFilter=" + encodeURIComponent("" + internalRemarksFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&";
        if (linkedInFilter === null)
            throw new Error("The parameter 'linkedInFilter' cannot be null.");
        else if (linkedInFilter !== undefined)
            url_ += "LinkedInFilter=" + encodeURIComponent("" + linkedInFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (cityNameFilter === null)
            throw new Error("The parameter 'cityNameFilter' cannot be null.");
        else if (cityNameFilter !== undefined)
            url_ += "CityNameFilter=" + encodeURIComponent("" + cityNameFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetBusinessForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetBusinessForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusinessForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBusinessForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessForView(id: number | undefined): Observable<GetBusinessForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Businesses/GetBusinessForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessForViewDto>;
        }));
    }

    protected processGetBusinessForView(response: HttpResponseBase): Observable<GetBusinessForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessForEdit(id: number | undefined): Observable<GetBusinessForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Businesses/GetBusinessForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessForEditOutput>;
        }));
    }

    protected processGetBusinessForEdit(response: HttpResponseBase): Observable<GetBusinessForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBusinessDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Businesses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Businesses/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param tradeNameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param customIdFilter (optional) 
     * @param yearOfEstablishmentFilter (optional) 
     * @param locationTitleFilter (optional) 
     * @param fullAddressFilter (optional) 
     * @param address1Filter (optional) 
     * @param address2Filter (optional) 
     * @param cityFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param phoneFilter (optional) 
     * @param faxFilter (optional) 
     * @param emailFilter (optional) 
     * @param websiteFilter (optional) 
     * @param einTaxIdFilter (optional) 
     * @param industryFilter (optional) 
     * @param internalRemarksFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param facebookFilter (optional) 
     * @param linkedInFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param cityNameFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @return Success
     */
    getBusinessesToExcel(filter: string | undefined, nameFilter: string | undefined, tradeNameFilter: string | undefined, descriptionFilter: string | undefined, customIdFilter: string | undefined, yearOfEstablishmentFilter: string | undefined, locationTitleFilter: string | undefined, fullAddressFilter: string | undefined, address1Filter: string | undefined, address2Filter: string | undefined, cityFilter: string | undefined, zipCodeFilter: string | undefined, maxLatitudeFilter: number | undefined, minLatitudeFilter: number | undefined, maxLongitudeFilter: number | undefined, minLongitudeFilter: number | undefined, phoneFilter: string | undefined, faxFilter: string | undefined, emailFilter: string | undefined, websiteFilter: string | undefined, einTaxIdFilter: string | undefined, industryFilter: string | undefined, internalRemarksFilter: string | undefined, verifiedFilter: number | undefined, facebookFilter: string | undefined, linkedInFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, cityNameFilter: string | undefined, mediaLibraryNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Businesses/GetBusinessesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (tradeNameFilter === null)
            throw new Error("The parameter 'tradeNameFilter' cannot be null.");
        else if (tradeNameFilter !== undefined)
            url_ += "TradeNameFilter=" + encodeURIComponent("" + tradeNameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (customIdFilter === null)
            throw new Error("The parameter 'customIdFilter' cannot be null.");
        else if (customIdFilter !== undefined)
            url_ += "CustomIdFilter=" + encodeURIComponent("" + customIdFilter) + "&";
        if (yearOfEstablishmentFilter === null)
            throw new Error("The parameter 'yearOfEstablishmentFilter' cannot be null.");
        else if (yearOfEstablishmentFilter !== undefined)
            url_ += "YearOfEstablishmentFilter=" + encodeURIComponent("" + yearOfEstablishmentFilter) + "&";
        if (locationTitleFilter === null)
            throw new Error("The parameter 'locationTitleFilter' cannot be null.");
        else if (locationTitleFilter !== undefined)
            url_ += "LocationTitleFilter=" + encodeURIComponent("" + locationTitleFilter) + "&";
        if (fullAddressFilter === null)
            throw new Error("The parameter 'fullAddressFilter' cannot be null.");
        else if (fullAddressFilter !== undefined)
            url_ += "FullAddressFilter=" + encodeURIComponent("" + fullAddressFilter) + "&";
        if (address1Filter === null)
            throw new Error("The parameter 'address1Filter' cannot be null.");
        else if (address1Filter !== undefined)
            url_ += "Address1Filter=" + encodeURIComponent("" + address1Filter) + "&";
        if (address2Filter === null)
            throw new Error("The parameter 'address2Filter' cannot be null.");
        else if (address2Filter !== undefined)
            url_ += "Address2Filter=" + encodeURIComponent("" + address2Filter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (maxLatitudeFilter === null)
            throw new Error("The parameter 'maxLatitudeFilter' cannot be null.");
        else if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&";
        if (minLatitudeFilter === null)
            throw new Error("The parameter 'minLatitudeFilter' cannot be null.");
        else if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&";
        if (maxLongitudeFilter === null)
            throw new Error("The parameter 'maxLongitudeFilter' cannot be null.");
        else if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&";
        if (minLongitudeFilter === null)
            throw new Error("The parameter 'minLongitudeFilter' cannot be null.");
        else if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&";
        if (phoneFilter === null)
            throw new Error("The parameter 'phoneFilter' cannot be null.");
        else if (phoneFilter !== undefined)
            url_ += "PhoneFilter=" + encodeURIComponent("" + phoneFilter) + "&";
        if (faxFilter === null)
            throw new Error("The parameter 'faxFilter' cannot be null.");
        else if (faxFilter !== undefined)
            url_ += "FaxFilter=" + encodeURIComponent("" + faxFilter) + "&";
        if (emailFilter === null)
            throw new Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&";
        if (websiteFilter === null)
            throw new Error("The parameter 'websiteFilter' cannot be null.");
        else if (websiteFilter !== undefined)
            url_ += "WebsiteFilter=" + encodeURIComponent("" + websiteFilter) + "&";
        if (einTaxIdFilter === null)
            throw new Error("The parameter 'einTaxIdFilter' cannot be null.");
        else if (einTaxIdFilter !== undefined)
            url_ += "EinTaxIdFilter=" + encodeURIComponent("" + einTaxIdFilter) + "&";
        if (industryFilter === null)
            throw new Error("The parameter 'industryFilter' cannot be null.");
        else if (industryFilter !== undefined)
            url_ += "IndustryFilter=" + encodeURIComponent("" + industryFilter) + "&";
        if (internalRemarksFilter === null)
            throw new Error("The parameter 'internalRemarksFilter' cannot be null.");
        else if (internalRemarksFilter !== undefined)
            url_ += "InternalRemarksFilter=" + encodeURIComponent("" + internalRemarksFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&";
        if (linkedInFilter === null)
            throw new Error("The parameter 'linkedInFilter' cannot be null.");
        else if (linkedInFilter !== undefined)
            url_ += "LinkedInFilter=" + encodeURIComponent("" + linkedInFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (cityNameFilter === null)
            throw new Error("The parameter 'cityNameFilter' cannot be null.");
        else if (cityNameFilter !== undefined)
            url_ += "CityNameFilter=" + encodeURIComponent("" + cityNameFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetBusinessesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountryForTableDropdown(): Observable<BusinessCountryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Businesses/GetAllCountryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessCountryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessCountryLookupTableDto[]>;
        }));
    }

    protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<BusinessCountryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BusinessCountryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllStateForTableDropdown(): Observable<BusinessStateLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Businesses/GetAllStateForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStateForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStateForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessStateLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessStateLookupTableDto[]>;
        }));
    }

    protected processGetAllStateForTableDropdown(response: HttpResponseBase): Observable<BusinessStateLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BusinessStateLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCityForTableDropdown(): Observable<BusinessCityLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Businesses/GetAllCityForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCityForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCityForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BusinessCityLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BusinessCityLookupTableDto[]>;
        }));
    }

    protected processGetAllCityForTableDropdown(response: HttpResponseBase): Observable<BusinessCityLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BusinessCityLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMediaLibraryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessMediaLibraryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Businesses/GetAllMediaLibraryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMediaLibraryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMediaLibraryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessMediaLibraryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessMediaLibraryLookupTableDto>;
        }));
    }

    protected processGetAllMediaLibraryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessMediaLibraryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessMediaLibraryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessJobMapsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, businessNameFilter: string | undefined, jobTitleFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetBusinessJobMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessJobMaps/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (jobTitleFilter === null)
            throw new Error("The parameter 'jobTitleFilter' cannot be null.");
        else if (jobTitleFilter !== undefined)
            url_ += "JobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetBusinessJobMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetBusinessJobMapForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusinessJobMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBusinessJobMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessJobMapForView(id: number | undefined): Observable<GetBusinessJobMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessJobMaps/GetBusinessJobMapForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessJobMapForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessJobMapForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessJobMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessJobMapForViewDto>;
        }));
    }

    protected processGetBusinessJobMapForView(response: HttpResponseBase): Observable<GetBusinessJobMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessJobMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessJobMapForEdit(id: number | undefined): Observable<GetBusinessJobMapForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessJobMaps/GetBusinessJobMapForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessJobMapForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessJobMapForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessJobMapForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessJobMapForEditOutput>;
        }));
    }

    protected processGetBusinessJobMapForEdit(response: HttpResponseBase): Observable<GetBusinessJobMapForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessJobMapForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBusinessJobMapDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessJobMaps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessJobMaps/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @return Success
     */
    getBusinessJobMapsToExcel(filter: string | undefined, businessNameFilter: string | undefined, jobTitleFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessJobMaps/GetBusinessJobMapsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (jobTitleFilter === null)
            throw new Error("The parameter 'jobTitleFilter' cannot be null.");
        else if (jobTitleFilter !== undefined)
            url_ += "JobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessJobMapsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessJobMapsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetBusinessJobMapsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessJobMapBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessJobMaps/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessJobMapBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessJobMapBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessJobMapBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessJobMapBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllJobForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessJobMapJobLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessJobMaps/GetAllJobForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessJobMapJobLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessJobMapJobLookupTableDto>;
        }));
    }

    protected processGetAllJobForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessJobMapJobLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessJobMapJobLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessNotesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param notesFilter (optional) 
     * @param businessNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, notesFilter: string | undefined, businessNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetBusinessNoteForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessNotes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (notesFilter === null)
            throw new Error("The parameter 'notesFilter' cannot be null.");
        else if (notesFilter !== undefined)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetBusinessNoteForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetBusinessNoteForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusinessNoteForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBusinessNoteForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessNoteForView(id: number | undefined): Observable<GetBusinessNoteForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessNotes/GetBusinessNoteForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessNoteForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessNoteForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessNoteForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessNoteForViewDto>;
        }));
    }

    protected processGetBusinessNoteForView(response: HttpResponseBase): Observable<GetBusinessNoteForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessNoteForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessNoteForEdit(id: number | undefined): Observable<GetBusinessNoteForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessNotes/GetBusinessNoteForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessNoteForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessNoteForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessNoteForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessNoteForEditOutput>;
        }));
    }

    protected processGetBusinessNoteForEdit(response: HttpResponseBase): Observable<GetBusinessNoteForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessNoteForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBusinessNoteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessNotes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessNotes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param notesFilter (optional) 
     * @param businessNameFilter (optional) 
     * @return Success
     */
    getBusinessNotesToExcel(filter: string | undefined, notesFilter: string | undefined, businessNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessNotes/GetBusinessNotesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (notesFilter === null)
            throw new Error("The parameter 'notesFilter' cannot be null.");
        else if (notesFilter !== undefined)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessNotesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessNotesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetBusinessNotesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessNoteBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessNotes/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessNoteBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessNoteBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessNoteBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessNoteBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessProductMapsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param productNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, businessNameFilter: string | undefined, productNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetBusinessProductMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProductMaps/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetBusinessProductMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetBusinessProductMapForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusinessProductMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBusinessProductMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessProductMapForView(id: number | undefined): Observable<GetBusinessProductMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProductMaps/GetBusinessProductMapForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessProductMapForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessProductMapForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessProductMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessProductMapForViewDto>;
        }));
    }

    protected processGetBusinessProductMapForView(response: HttpResponseBase): Observable<GetBusinessProductMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessProductMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessProductMapForEdit(id: number | undefined): Observable<GetBusinessProductMapForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProductMaps/GetBusinessProductMapForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessProductMapForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessProductMapForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessProductMapForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessProductMapForEditOutput>;
        }));
    }

    protected processGetBusinessProductMapForEdit(response: HttpResponseBase): Observable<GetBusinessProductMapForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessProductMapForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBusinessProductMapDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProductMaps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProductMaps/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param productNameFilter (optional) 
     * @return Success
     */
    getBusinessProductMapsToExcel(filter: string | undefined, businessNameFilter: string | undefined, productNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProductMaps/GetBusinessProductMapsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessProductMapsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessProductMapsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetBusinessProductMapsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessProductMapBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProductMaps/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessProductMapBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessProductMapBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessProductMapBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessProductMapBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessProductMapProductLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessProductMaps/GetAllProductForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessProductMapProductLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessProductMapProductLookupTableDto>;
        }));
    }

    protected processGetAllProductForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessProductMapProductLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessProductMapProductLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessStoreMapsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, businessNameFilter: string | undefined, storeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetBusinessStoreMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessStoreMaps/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetBusinessStoreMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetBusinessStoreMapForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusinessStoreMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBusinessStoreMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessStoreMapForView(id: number | undefined): Observable<GetBusinessStoreMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessStoreMaps/GetBusinessStoreMapForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessStoreMapForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessStoreMapForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessStoreMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessStoreMapForViewDto>;
        }));
    }

    protected processGetBusinessStoreMapForView(response: HttpResponseBase): Observable<GetBusinessStoreMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessStoreMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessStoreMapForEdit(id: number | undefined): Observable<GetBusinessStoreMapForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessStoreMaps/GetBusinessStoreMapForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessStoreMapForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessStoreMapForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessStoreMapForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessStoreMapForEditOutput>;
        }));
    }

    protected processGetBusinessStoreMapForEdit(response: HttpResponseBase): Observable<GetBusinessStoreMapForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessStoreMapForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBusinessStoreMapDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessStoreMaps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessStoreMaps/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param storeNameFilter (optional) 
     * @return Success
     */
    getBusinessStoreMapsToExcel(filter: string | undefined, businessNameFilter: string | undefined, storeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessStoreMaps/GetBusinessStoreMapsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessStoreMapsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessStoreMapsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetBusinessStoreMapsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessStoreMapBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessStoreMaps/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessStoreMapBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessStoreMapBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessStoreMapBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessStoreMapBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessStoreMapStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessStoreMaps/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessStoreMapStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessStoreMapStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessStoreMapStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessStoreMapStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param businessNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, businessNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetBusinessTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTags/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetBusinessTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetBusinessTagForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusinessTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBusinessTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessTagForView(id: number | undefined): Observable<GetBusinessTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTags/GetBusinessTagForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessTagForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessTagForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessTagForViewDto>;
        }));
    }

    protected processGetBusinessTagForView(response: HttpResponseBase): Observable<GetBusinessTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessTagForEdit(id: number | undefined): Observable<GetBusinessTagForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTags/GetBusinessTagForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessTagForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessTagForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessTagForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessTagForEditOutput>;
        }));
    }

    protected processGetBusinessTagForEdit(response: HttpResponseBase): Observable<GetBusinessTagForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessTagForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBusinessTagDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTags/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTags/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param businessNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @return Success
     */
    getBusinessTagsToExcel(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, businessNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTags/GetBusinessTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessTagsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetBusinessTagsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessTagBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTags/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessTagBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessTagBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessTagBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessTagBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTags/GetAllMasterTagCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessTagMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTags/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessTagMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessTagMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessTagMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessTagMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessTaskMapsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param taskEventNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, businessNameFilter: string | undefined, taskEventNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetBusinessTaskMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTaskMaps/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (taskEventNameFilter === null)
            throw new Error("The parameter 'taskEventNameFilter' cannot be null.");
        else if (taskEventNameFilter !== undefined)
            url_ += "TaskEventNameFilter=" + encodeURIComponent("" + taskEventNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetBusinessTaskMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetBusinessTaskMapForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusinessTaskMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBusinessTaskMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessTaskMapForView(id: number | undefined): Observable<GetBusinessTaskMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTaskMaps/GetBusinessTaskMapForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessTaskMapForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessTaskMapForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessTaskMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessTaskMapForViewDto>;
        }));
    }

    protected processGetBusinessTaskMapForView(response: HttpResponseBase): Observable<GetBusinessTaskMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessTaskMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessTaskMapForEdit(id: number | undefined): Observable<GetBusinessTaskMapForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTaskMaps/GetBusinessTaskMapForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessTaskMapForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessTaskMapForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessTaskMapForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessTaskMapForEditOutput>;
        }));
    }

    protected processGetBusinessTaskMapForEdit(response: HttpResponseBase): Observable<GetBusinessTaskMapForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessTaskMapForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBusinessTaskMapDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTaskMaps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTaskMaps/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param taskEventNameFilter (optional) 
     * @return Success
     */
    getBusinessTaskMapsToExcel(filter: string | undefined, businessNameFilter: string | undefined, taskEventNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTaskMaps/GetBusinessTaskMapsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (taskEventNameFilter === null)
            throw new Error("The parameter 'taskEventNameFilter' cannot be null.");
        else if (taskEventNameFilter !== undefined)
            url_ += "TaskEventNameFilter=" + encodeURIComponent("" + taskEventNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessTaskMapsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessTaskMapsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetBusinessTaskMapsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessTaskMapBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTaskMaps/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessTaskMapBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessTaskMapBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessTaskMapBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessTaskMapBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaskEventForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessTaskMaps/GetAllTaskEventForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaskEventForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaskEventForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto>;
        }));
    }

    protected processGetAllTaskEventForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BusinessUsersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, businessNameFilter: string | undefined, userNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetBusinessUserForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUsers/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetBusinessUserForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetBusinessUserForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusinessUserForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBusinessUserForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessUserForView(id: number | undefined): Observable<GetBusinessUserForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUsers/GetBusinessUserForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessUserForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessUserForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessUserForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessUserForViewDto>;
        }));
    }

    protected processGetBusinessUserForView(response: HttpResponseBase): Observable<GetBusinessUserForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessUserForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusinessUserForEdit(id: number | undefined): Observable<GetBusinessUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUsers/GetBusinessUserForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessUserForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetBusinessUserForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetBusinessUserForEditOutput>;
        }));
    }

    protected processGetBusinessUserForEdit(response: HttpResponseBase): Observable<GetBusinessUserForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBusinessUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditBusinessUserDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUsers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUsers/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param businessNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @return Success
     */
    getBusinessUsersToExcel(filter: string | undefined, businessNameFilter: string | undefined, userNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUsers/GetBusinessUsersToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessUsersToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetBusinessUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessUserBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUsers/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessUserBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessUserBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessUserBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessUserBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfBusinessUserUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BusinessUsers/GetAllUserForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfBusinessUserUserLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfBusinessUserUserLookupTableDto>;
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBusinessUserUserLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBusinessUserUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfCacheDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfCacheDto>;
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfCacheDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserChatFriendsWithSettingsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserChatFriendsWithSettingsOutput>;
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserChatFriendsWithSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | undefined, userId: number | undefined, minMessageId: number | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (minMessageId === null)
            throw new Error("The parameter 'minMessageId' cannot be null.");
        else if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfChatMessageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfChatMessageDto>;
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CitiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param countyNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, countyNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetCityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Cities/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (countyNameFilter === null)
            throw new Error("The parameter 'countyNameFilter' cannot be null.");
        else if (countyNameFilter !== undefined)
            url_ += "CountyNameFilter=" + encodeURIComponent("" + countyNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetCityForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetCityForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCityForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCityForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCityForView(id: number | undefined): Observable<GetCityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Cities/GetCityForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCityForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCityForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCityForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCityForViewDto>;
        }));
    }

    protected processGetCityForView(response: HttpResponseBase): Observable<GetCityForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCityForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCityForEdit(id: number | undefined): Observable<GetCityForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Cities/GetCityForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCityForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCityForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCityForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCityForEditOutput>;
        }));
    }

    protected processGetCityForEdit(response: HttpResponseBase): Observable<GetCityForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCityForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditCityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cities/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cities/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param countyNameFilter (optional) 
     * @return Success
     */
    getCitiesToExcel(filter: string | undefined, nameFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, countyNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Cities/GetCitiesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (countyNameFilter === null)
            throw new Error("The parameter 'countyNameFilter' cannot be null.");
        else if (countyNameFilter !== undefined)
            url_ += "CountyNameFilter=" + encodeURIComponent("" + countyNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCitiesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCitiesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetCitiesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountryForTableDropdown(): Observable<CityCountryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Cities/GetAllCountryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityCountryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityCountryLookupTableDto[]>;
        }));
    }

    protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<CityCountryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityCountryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllStateForTableDropdown(): Observable<CityStateLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Cities/GetAllStateForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStateForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStateForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityStateLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityStateLookupTableDto[]>;
        }));
    }

    protected processGetAllStateForTableDropdown(response: HttpResponseBase): Observable<CityStateLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityStateLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountyForTableDropdown(): Observable<CityCountyLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Cities/GetAllCountyForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountyForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountyForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityCountyLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityCountyLookupTableDto[]>;
        }));
    }

    protected processGetAllCountyForTableDropdown(response: HttpResponseBase): Observable<CityCountyLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityCountyLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>;
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDefaultEditionNameOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDefaultEditionNameOutput>;
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ConnectChannelsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetConnectChannelForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ConnectChannels/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetConnectChannelForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetConnectChannelForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetConnectChannelForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetConnectChannelForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getConnectChannelForView(id: number | undefined): Observable<GetConnectChannelForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ConnectChannels/GetConnectChannelForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConnectChannelForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConnectChannelForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetConnectChannelForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetConnectChannelForViewDto>;
        }));
    }

    protected processGetConnectChannelForView(response: HttpResponseBase): Observable<GetConnectChannelForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetConnectChannelForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getConnectChannelForEdit(id: number | undefined): Observable<GetConnectChannelForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ConnectChannels/GetConnectChannelForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConnectChannelForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConnectChannelForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetConnectChannelForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetConnectChannelForEditOutput>;
        }));
    }

    protected processGetConnectChannelForEdit(response: HttpResponseBase): Observable<GetConnectChannelForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetConnectChannelForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditConnectChannelDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ConnectChannels/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ConnectChannels/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @return Success
     */
    getConnectChannelsToExcel(filter: string | undefined, nameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ConnectChannels/GetConnectChannelsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConnectChannelsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConnectChannelsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetConnectChannelsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContactsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param fullNameFilter (optional) 
     * @param firstNameFilter (optional) 
     * @param lastNameFilter (optional) 
     * @param fullAddressFilter (optional) 
     * @param addressFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param cityFilter (optional) 
     * @param maxDateOfBirthFilter (optional) 
     * @param minDateOfBirthFilter (optional) 
     * @param countryCodeFilter (optional) 
     * @param personalEmailFilter (optional) 
     * @param businessEmailFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param companyNameFilter (optional) 
     * @param profileFilter (optional) 
     * @param aiDataTagFilter (optional) 
     * @param facebookFilter (optional) 
     * @param linkedInFilter (optional) 
     * @param referredFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxScoreFilter (optional) 
     * @param minScoreFilter (optional) 
     * @param userNameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param membershipTypeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, fullNameFilter: string | undefined, firstNameFilter: string | undefined, lastNameFilter: string | undefined, fullAddressFilter: string | undefined, addressFilter: string | undefined, zipCodeFilter: string | undefined, cityFilter: string | undefined, maxDateOfBirthFilter: DateTime | undefined, minDateOfBirthFilter: DateTime | undefined, countryCodeFilter: string | undefined, personalEmailFilter: string | undefined, businessEmailFilter: string | undefined, jobTitleFilter: string | undefined, companyNameFilter: string | undefined, profileFilter: string | undefined, aiDataTagFilter: string | undefined, facebookFilter: string | undefined, linkedInFilter: string | undefined, referredFilter: number | undefined, verifiedFilter: number | undefined, maxScoreFilter: number | undefined, minScoreFilter: number | undefined, userNameFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, membershipTypeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetContactForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (fullNameFilter === null)
            throw new Error("The parameter 'fullNameFilter' cannot be null.");
        else if (fullNameFilter !== undefined)
            url_ += "FullNameFilter=" + encodeURIComponent("" + fullNameFilter) + "&";
        if (firstNameFilter === null)
            throw new Error("The parameter 'firstNameFilter' cannot be null.");
        else if (firstNameFilter !== undefined)
            url_ += "FirstNameFilter=" + encodeURIComponent("" + firstNameFilter) + "&";
        if (lastNameFilter === null)
            throw new Error("The parameter 'lastNameFilter' cannot be null.");
        else if (lastNameFilter !== undefined)
            url_ += "LastNameFilter=" + encodeURIComponent("" + lastNameFilter) + "&";
        if (fullAddressFilter === null)
            throw new Error("The parameter 'fullAddressFilter' cannot be null.");
        else if (fullAddressFilter !== undefined)
            url_ += "FullAddressFilter=" + encodeURIComponent("" + fullAddressFilter) + "&";
        if (addressFilter === null)
            throw new Error("The parameter 'addressFilter' cannot be null.");
        else if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (maxDateOfBirthFilter === null)
            throw new Error("The parameter 'maxDateOfBirthFilter' cannot be null.");
        else if (maxDateOfBirthFilter !== undefined)
            url_ += "MaxDateOfBirthFilter=" + encodeURIComponent(maxDateOfBirthFilter ? "" + maxDateOfBirthFilter.toString() : "") + "&";
        if (minDateOfBirthFilter === null)
            throw new Error("The parameter 'minDateOfBirthFilter' cannot be null.");
        else if (minDateOfBirthFilter !== undefined)
            url_ += "MinDateOfBirthFilter=" + encodeURIComponent(minDateOfBirthFilter ? "" + minDateOfBirthFilter.toString() : "") + "&";
        if (countryCodeFilter === null)
            throw new Error("The parameter 'countryCodeFilter' cannot be null.");
        else if (countryCodeFilter !== undefined)
            url_ += "CountryCodeFilter=" + encodeURIComponent("" + countryCodeFilter) + "&";
        if (personalEmailFilter === null)
            throw new Error("The parameter 'personalEmailFilter' cannot be null.");
        else if (personalEmailFilter !== undefined)
            url_ += "PersonalEmailFilter=" + encodeURIComponent("" + personalEmailFilter) + "&";
        if (businessEmailFilter === null)
            throw new Error("The parameter 'businessEmailFilter' cannot be null.");
        else if (businessEmailFilter !== undefined)
            url_ += "BusinessEmailFilter=" + encodeURIComponent("" + businessEmailFilter) + "&";
        if (jobTitleFilter === null)
            throw new Error("The parameter 'jobTitleFilter' cannot be null.");
        else if (jobTitleFilter !== undefined)
            url_ += "JobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&";
        if (companyNameFilter === null)
            throw new Error("The parameter 'companyNameFilter' cannot be null.");
        else if (companyNameFilter !== undefined)
            url_ += "CompanyNameFilter=" + encodeURIComponent("" + companyNameFilter) + "&";
        if (profileFilter === null)
            throw new Error("The parameter 'profileFilter' cannot be null.");
        else if (profileFilter !== undefined)
            url_ += "ProfileFilter=" + encodeURIComponent("" + profileFilter) + "&";
        if (aiDataTagFilter === null)
            throw new Error("The parameter 'aiDataTagFilter' cannot be null.");
        else if (aiDataTagFilter !== undefined)
            url_ += "AiDataTagFilter=" + encodeURIComponent("" + aiDataTagFilter) + "&";
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&";
        if (linkedInFilter === null)
            throw new Error("The parameter 'linkedInFilter' cannot be null.");
        else if (linkedInFilter !== undefined)
            url_ += "LinkedInFilter=" + encodeURIComponent("" + linkedInFilter) + "&";
        if (referredFilter === null)
            throw new Error("The parameter 'referredFilter' cannot be null.");
        else if (referredFilter !== undefined)
            url_ += "ReferredFilter=" + encodeURIComponent("" + referredFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxScoreFilter === null)
            throw new Error("The parameter 'maxScoreFilter' cannot be null.");
        else if (maxScoreFilter !== undefined)
            url_ += "MaxScoreFilter=" + encodeURIComponent("" + maxScoreFilter) + "&";
        if (minScoreFilter === null)
            throw new Error("The parameter 'minScoreFilter' cannot be null.");
        else if (minScoreFilter !== undefined)
            url_ += "MinScoreFilter=" + encodeURIComponent("" + minScoreFilter) + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (membershipTypeNameFilter === null)
            throw new Error("The parameter 'membershipTypeNameFilter' cannot be null.");
        else if (membershipTypeNameFilter !== undefined)
            url_ += "MembershipTypeNameFilter=" + encodeURIComponent("" + membershipTypeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetContactForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetContactForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetContactForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetContactForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContactForView(id: number | undefined): Observable<GetContactForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetContactForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContactForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContactForViewDto>;
        }));
    }

    protected processGetContactForView(response: HttpResponseBase): Observable<GetContactForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetContactForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContactForEdit(id: number | undefined): Observable<GetContactForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetContactForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContactForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContactForEditOutput>;
        }));
    }

    protected processGetContactForEdit(response: HttpResponseBase): Observable<GetContactForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetContactForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditContactDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param fullNameFilter (optional) 
     * @param firstNameFilter (optional) 
     * @param lastNameFilter (optional) 
     * @param fullAddressFilter (optional) 
     * @param addressFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param cityFilter (optional) 
     * @param maxDateOfBirthFilter (optional) 
     * @param minDateOfBirthFilter (optional) 
     * @param countryCodeFilter (optional) 
     * @param personalEmailFilter (optional) 
     * @param businessEmailFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param companyNameFilter (optional) 
     * @param profileFilter (optional) 
     * @param aiDataTagFilter (optional) 
     * @param facebookFilter (optional) 
     * @param linkedInFilter (optional) 
     * @param referredFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxScoreFilter (optional) 
     * @param minScoreFilter (optional) 
     * @param userNameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param membershipTypeNameFilter (optional) 
     * @return Success
     */
    getContactsToExcel(filter: string | undefined, fullNameFilter: string | undefined, firstNameFilter: string | undefined, lastNameFilter: string | undefined, fullAddressFilter: string | undefined, addressFilter: string | undefined, zipCodeFilter: string | undefined, cityFilter: string | undefined, maxDateOfBirthFilter: DateTime | undefined, minDateOfBirthFilter: DateTime | undefined, countryCodeFilter: string | undefined, personalEmailFilter: string | undefined, businessEmailFilter: string | undefined, jobTitleFilter: string | undefined, companyNameFilter: string | undefined, profileFilter: string | undefined, aiDataTagFilter: string | undefined, facebookFilter: string | undefined, linkedInFilter: string | undefined, referredFilter: number | undefined, verifiedFilter: number | undefined, maxScoreFilter: number | undefined, minScoreFilter: number | undefined, userNameFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, membershipTypeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetContactsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (fullNameFilter === null)
            throw new Error("The parameter 'fullNameFilter' cannot be null.");
        else if (fullNameFilter !== undefined)
            url_ += "FullNameFilter=" + encodeURIComponent("" + fullNameFilter) + "&";
        if (firstNameFilter === null)
            throw new Error("The parameter 'firstNameFilter' cannot be null.");
        else if (firstNameFilter !== undefined)
            url_ += "FirstNameFilter=" + encodeURIComponent("" + firstNameFilter) + "&";
        if (lastNameFilter === null)
            throw new Error("The parameter 'lastNameFilter' cannot be null.");
        else if (lastNameFilter !== undefined)
            url_ += "LastNameFilter=" + encodeURIComponent("" + lastNameFilter) + "&";
        if (fullAddressFilter === null)
            throw new Error("The parameter 'fullAddressFilter' cannot be null.");
        else if (fullAddressFilter !== undefined)
            url_ += "FullAddressFilter=" + encodeURIComponent("" + fullAddressFilter) + "&";
        if (addressFilter === null)
            throw new Error("The parameter 'addressFilter' cannot be null.");
        else if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (maxDateOfBirthFilter === null)
            throw new Error("The parameter 'maxDateOfBirthFilter' cannot be null.");
        else if (maxDateOfBirthFilter !== undefined)
            url_ += "MaxDateOfBirthFilter=" + encodeURIComponent(maxDateOfBirthFilter ? "" + maxDateOfBirthFilter.toString() : "") + "&";
        if (minDateOfBirthFilter === null)
            throw new Error("The parameter 'minDateOfBirthFilter' cannot be null.");
        else if (minDateOfBirthFilter !== undefined)
            url_ += "MinDateOfBirthFilter=" + encodeURIComponent(minDateOfBirthFilter ? "" + minDateOfBirthFilter.toString() : "") + "&";
        if (countryCodeFilter === null)
            throw new Error("The parameter 'countryCodeFilter' cannot be null.");
        else if (countryCodeFilter !== undefined)
            url_ += "CountryCodeFilter=" + encodeURIComponent("" + countryCodeFilter) + "&";
        if (personalEmailFilter === null)
            throw new Error("The parameter 'personalEmailFilter' cannot be null.");
        else if (personalEmailFilter !== undefined)
            url_ += "PersonalEmailFilter=" + encodeURIComponent("" + personalEmailFilter) + "&";
        if (businessEmailFilter === null)
            throw new Error("The parameter 'businessEmailFilter' cannot be null.");
        else if (businessEmailFilter !== undefined)
            url_ += "BusinessEmailFilter=" + encodeURIComponent("" + businessEmailFilter) + "&";
        if (jobTitleFilter === null)
            throw new Error("The parameter 'jobTitleFilter' cannot be null.");
        else if (jobTitleFilter !== undefined)
            url_ += "JobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&";
        if (companyNameFilter === null)
            throw new Error("The parameter 'companyNameFilter' cannot be null.");
        else if (companyNameFilter !== undefined)
            url_ += "CompanyNameFilter=" + encodeURIComponent("" + companyNameFilter) + "&";
        if (profileFilter === null)
            throw new Error("The parameter 'profileFilter' cannot be null.");
        else if (profileFilter !== undefined)
            url_ += "ProfileFilter=" + encodeURIComponent("" + profileFilter) + "&";
        if (aiDataTagFilter === null)
            throw new Error("The parameter 'aiDataTagFilter' cannot be null.");
        else if (aiDataTagFilter !== undefined)
            url_ += "AiDataTagFilter=" + encodeURIComponent("" + aiDataTagFilter) + "&";
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&";
        if (linkedInFilter === null)
            throw new Error("The parameter 'linkedInFilter' cannot be null.");
        else if (linkedInFilter !== undefined)
            url_ += "LinkedInFilter=" + encodeURIComponent("" + linkedInFilter) + "&";
        if (referredFilter === null)
            throw new Error("The parameter 'referredFilter' cannot be null.");
        else if (referredFilter !== undefined)
            url_ += "ReferredFilter=" + encodeURIComponent("" + referredFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxScoreFilter === null)
            throw new Error("The parameter 'maxScoreFilter' cannot be null.");
        else if (maxScoreFilter !== undefined)
            url_ += "MaxScoreFilter=" + encodeURIComponent("" + maxScoreFilter) + "&";
        if (minScoreFilter === null)
            throw new Error("The parameter 'minScoreFilter' cannot be null.");
        else if (minScoreFilter !== undefined)
            url_ += "MinScoreFilter=" + encodeURIComponent("" + minScoreFilter) + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (membershipTypeNameFilter === null)
            throw new Error("The parameter 'membershipTypeNameFilter' cannot be null.");
        else if (membershipTypeNameFilter !== undefined)
            url_ += "MembershipTypeNameFilter=" + encodeURIComponent("" + membershipTypeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetContactsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfContactUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAllUserForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfContactUserLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfContactUserLookupTableDto>;
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfContactUserLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountryForTableDropdown(): Observable<ContactCountryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAllCountryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactCountryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactCountryLookupTableDto[]>;
        }));
    }

    protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<ContactCountryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactCountryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllStateForTableDropdown(): Observable<ContactStateLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAllStateForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStateForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStateForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactStateLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactStateLookupTableDto[]>;
        }));
    }

    protected processGetAllStateForTableDropdown(response: HttpResponseBase): Observable<ContactStateLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactStateLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllMembershipTypeForTableDropdown(): Observable<ContactMembershipTypeLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAllMembershipTypeForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMembershipTypeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMembershipTypeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactMembershipTypeLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactMembershipTypeLookupTableDto[]>;
        }));
    }

    protected processGetAllMembershipTypeForTableDropdown(response: HttpResponseBase): Observable<ContactMembershipTypeLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactMembershipTypeLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContactTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param contactFullNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, contactFullNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetContactTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactTags/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (contactFullNameFilter === null)
            throw new Error("The parameter 'contactFullNameFilter' cannot be null.");
        else if (contactFullNameFilter !== undefined)
            url_ += "ContactFullNameFilter=" + encodeURIComponent("" + contactFullNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetContactTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetContactTagForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetContactTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetContactTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContactTagForView(id: number | undefined): Observable<GetContactTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactTags/GetContactTagForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactTagForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactTagForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContactTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContactTagForViewDto>;
        }));
    }

    protected processGetContactTagForView(response: HttpResponseBase): Observable<GetContactTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetContactTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContactTagForEdit(id: number | undefined): Observable<GetContactTagForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ContactTags/GetContactTagForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactTagForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactTagForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContactTagForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContactTagForEditOutput>;
        }));
    }

    protected processGetContactTagForEdit(response: HttpResponseBase): Observable<GetContactTagForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetContactTagForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditContactTagDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContactTags/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContactTags/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param contactFullNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @return Success
     */
    getContactTagsToExcel(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, contactFullNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactTags/GetContactTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (contactFullNameFilter === null)
            throw new Error("The parameter 'contactFullNameFilter' cannot be null.");
        else if (contactFullNameFilter !== undefined)
            url_ += "ContactFullNameFilter=" + encodeURIComponent("" + contactFullNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactTagsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetContactTagsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllContactForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfContactTagContactLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactTags/GetAllContactForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContactForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContactForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfContactTagContactLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfContactTagContactLookupTableDto>;
        }));
    }

    protected processGetAllContactForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfContactTagContactLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactTagContactLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfContactTagMasterTagCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactTags/GetAllMasterTagCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfContactTagMasterTagCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfContactTagMasterTagCategoryLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfContactTagMasterTagCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactTagMasterTagCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfContactTagMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ContactTags/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfContactTagMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfContactTagMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfContactTagMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactTagMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ContractTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetContractTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractTypes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetContractTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetContractTypeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetContractTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetContractTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContractTypeForView(id: number | undefined): Observable<GetContractTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractTypes/GetContractTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractTypeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContractTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContractTypeForViewDto>;
        }));
    }

    protected processGetContractTypeForView(response: HttpResponseBase): Observable<GetContractTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetContractTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContractTypeForEdit(id: number | undefined): Observable<GetContractTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ContractTypes/GetContractTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractTypeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetContractTypeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetContractTypeForEditOutput>;
        }));
    }

    protected processGetContractTypeForEdit(response: HttpResponseBase): Observable<GetContractTypeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetContractTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditContractTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContractTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContractTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @return Success
     */
    getContractTypesToExcel(filter: string | undefined, nameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ContractTypes/GetContractTypesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractTypesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetContractTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CountiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetCountyForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Counties/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetCountyForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetCountyForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCountyForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCountyForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCountyForView(id: number | undefined): Observable<GetCountyForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Counties/GetCountyForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountyForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountyForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountyForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountyForViewDto>;
        }));
    }

    protected processGetCountyForView(response: HttpResponseBase): Observable<GetCountyForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCountyForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCountyForEdit(id: number | undefined): Observable<GetCountyForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Counties/GetCountyForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountyForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountyForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountyForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountyForEditOutput>;
        }));
    }

    protected processGetCountyForEdit(response: HttpResponseBase): Observable<GetCountyForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCountyForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditCountyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Counties/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Counties/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @return Success
     */
    getCountiesToExcel(filter: string | undefined, nameFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Counties/GetCountiesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountiesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountiesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetCountiesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountryForTableDropdown(): Observable<CountyCountryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Counties/GetAllCountryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountyCountryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountyCountryLookupTableDto[]>;
        }));
    }

    protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<CountyCountryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountyCountryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllStateForTableDropdown(): Observable<CountyStateLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Counties/GetAllStateForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStateForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStateForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountyStateLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountyStateLookupTableDto[]>;
        }));
    }

    protected processGetAllStateForTableDropdown(response: HttpResponseBase): Observable<CountyStateLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountyStateLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CountriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param tickerFilter (optional) 
     * @param flagIconFilter (optional) 
     * @param phoneCodeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, tickerFilter: string | undefined, flagIconFilter: string | undefined, phoneCodeFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetCountryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Countries/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (tickerFilter === null)
            throw new Error("The parameter 'tickerFilter' cannot be null.");
        else if (tickerFilter !== undefined)
            url_ += "TickerFilter=" + encodeURIComponent("" + tickerFilter) + "&";
        if (flagIconFilter === null)
            throw new Error("The parameter 'flagIconFilter' cannot be null.");
        else if (flagIconFilter !== undefined)
            url_ += "FlagIconFilter=" + encodeURIComponent("" + flagIconFilter) + "&";
        if (phoneCodeFilter === null)
            throw new Error("The parameter 'phoneCodeFilter' cannot be null.");
        else if (phoneCodeFilter !== undefined)
            url_ += "PhoneCodeFilter=" + encodeURIComponent("" + phoneCodeFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetCountryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetCountryForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCountryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCountryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCountryForView(id: number | undefined): Observable<GetCountryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Countries/GetCountryForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountryForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountryForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountryForViewDto>;
        }));
    }

    protected processGetCountryForView(response: HttpResponseBase): Observable<GetCountryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCountryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCountryForEdit(id: number | undefined): Observable<GetCountryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Countries/GetCountryForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountryForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountryForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountryForEditOutput>;
        }));
    }

    protected processGetCountryForEdit(response: HttpResponseBase): Observable<GetCountryForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCountryForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditCountryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Countries/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Countries/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param tickerFilter (optional) 
     * @param flagIconFilter (optional) 
     * @param phoneCodeFilter (optional) 
     * @return Success
     */
    getCountriesToExcel(filter: string | undefined, nameFilter: string | undefined, tickerFilter: string | undefined, flagIconFilter: string | undefined, phoneCodeFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Countries/GetCountriesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (tickerFilter === null)
            throw new Error("The parameter 'tickerFilter' cannot be null.");
        else if (tickerFilter !== undefined)
            url_ += "TickerFilter=" + encodeURIComponent("" + tickerFilter) + "&";
        if (flagIconFilter === null)
            throw new Error("The parameter 'flagIconFilter' cannot be null.");
        else if (flagIconFilter !== undefined)
            url_ += "FlagIconFilter=" + encodeURIComponent("" + flagIconFilter) + "&";
        if (phoneCodeFilter === null)
            throw new Error("The parameter 'phoneCodeFilter' cannot be null.");
        else if (phoneCodeFilter !== undefined)
            url_ += "PhoneCodeFilter=" + encodeURIComponent("" + phoneCodeFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountriesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountriesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetCountriesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CurrenciesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param tickerFilter (optional) 
     * @param iconFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, tickerFilter: string | undefined, iconFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetCurrencyForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (tickerFilter === null)
            throw new Error("The parameter 'tickerFilter' cannot be null.");
        else if (tickerFilter !== undefined)
            url_ += "TickerFilter=" + encodeURIComponent("" + tickerFilter) + "&";
        if (iconFilter === null)
            throw new Error("The parameter 'iconFilter' cannot be null.");
        else if (iconFilter !== undefined)
            url_ += "IconFilter=" + encodeURIComponent("" + iconFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetCurrencyForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetCurrencyForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCurrencyForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCurrencyForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCurrencyForView(id: number | undefined): Observable<GetCurrencyForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/GetCurrencyForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencyForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrencyForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrencyForViewDto>;
        }));
    }

    protected processGetCurrencyForView(response: HttpResponseBase): Observable<GetCurrencyForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrencyForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCurrencyForEdit(id: number | undefined): Observable<GetCurrencyForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/GetCurrencyForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencyForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrencyForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrencyForEditOutput>;
        }));
    }

    protected processGetCurrencyForEdit(response: HttpResponseBase): Observable<GetCurrencyForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrencyForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditCurrencyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param tickerFilter (optional) 
     * @param iconFilter (optional) 
     * @return Success
     */
    getCurrenciesToExcel(filter: string | undefined, nameFilter: string | undefined, tickerFilter: string | undefined, iconFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/GetCurrenciesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (tickerFilter === null)
            throw new Error("The parameter 'tickerFilter' cannot be null.");
        else if (tickerFilter !== undefined)
            url_ += "TickerFilter=" + encodeURIComponent("" + tickerFilter) + "&";
        if (iconFilter === null)
            throw new Error("The parameter 'iconFilter' cannot be null.");
        else if (iconFilter !== undefined)
            url_ += "IconFilter=" + encodeURIComponent("" + iconFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrenciesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrenciesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetCurrenciesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DashboardCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getUserDashboard(dashboardName: string | undefined, application: string | undefined): Observable<Dashboard> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetUserDashboard?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Dashboard>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Dashboard>;
        }));
    }

    protected processGetUserDashboard(response: HttpResponseBase): Observable<Dashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePage(body: SavePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/SavePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renamePage(body: RenamePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/RenamePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenamePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenamePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRenamePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewPage(body: AddNewPageInput | undefined): Observable<AddNewPageOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddNewPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddNewPageOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddNewPageOutput>;
        }));
    }

    protected processAddNewPage(response: HttpResponseBase): Observable<AddNewPageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddNewPageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    deletePage(id: string | undefined, dashboardName: string | undefined, application: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/DeletePage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addWidget(body: AddWidgetInput | undefined): Observable<Widget> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddWidget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWidget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Widget>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Widget>;
        }));
    }

    protected processAddWidget(response: HttpResponseBase): Observable<Widget> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Widget.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getDashboardDefinition(dashboardName: string | undefined, application: string | undefined): Observable<DashboardOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetDashboardDefinition?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardOutput>;
        }));
    }

    protected processGetDashboardDefinition(response: HttpResponseBase): Observable<DashboardOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getAllWidgetDefinitions(dashboardName: string | undefined, application: string | undefined): Observable<WidgetOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetAllWidgetDefinitions?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWidgetDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWidgetDefinitions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetOutput[]>;
        }));
    }

    protected processGetAllWidgetDefinitions(response: HttpResponseBase): Observable<WidgetOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @param pageId (optional) 
     * @return Success
     */
    getAllAvailableWidgetDefinitionsForPage(dashboardName: string | undefined, application: string | undefined, pageId: string | undefined): Observable<WidgetOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetAllAvailableWidgetDefinitionsForPage?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        if (pageId === null)
            throw new Error("The parameter 'pageId' cannot be null.");
        else if (pageId !== undefined)
            url_ += "PageId=" + encodeURIComponent("" + pageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAvailableWidgetDefinitionsForPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAvailableWidgetDefinitionsForPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetOutput[]>;
        }));
    }

    protected processGetAllAvailableWidgetDefinitionsForPage(response: HttpResponseBase): Observable<WidgetOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param application (optional) 
     * @param dashboardName (optional) 
     * @return Success
     */
    getSettingName(application: string | undefined, dashboardName: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetSettingName?";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "application=" + encodeURIComponent("" + application) + "&";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "dashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSettingName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: DateTime | undefined): Observable<DateFieldOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateFieldOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateFieldOutput>;
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateFieldOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateFieldOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: DateTime | undefined): Observable<DateFieldOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateFieldOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateFieldOutput>;
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateFieldOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateFieldOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<DateRangeFieldOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateRangeFieldOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateRangeFieldOutput>;
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateRangeFieldOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateRangeFieldOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAndGetDateWithText(body: SendAndGetDateWithTextInput | undefined): Observable<DateWithTextFieldOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateWithText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateWithText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateWithText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateWithTextFieldOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateWithTextFieldOutput>;
        }));
    }

    protected processSendAndGetDateWithText(response: HttpResponseBase): Observable<DateWithTextFieldOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateWithTextFieldOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueOfString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueOfString[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(body: NameValueOfString[] | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueOfString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueOfString[]>;
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringOutput>;
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DocumentTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDocumentTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetDocumentTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetDocumentTypeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDocumentTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetDocumentTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentTypeForView(id: number | undefined): Observable<GetDocumentTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/GetDocumentTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDocumentTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDocumentTypeForViewDto>;
        }));
    }

    protected processGetDocumentTypeForView(response: HttpResponseBase): Observable<GetDocumentTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDocumentTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDocumentTypeForEdit(id: number | undefined): Observable<GetDocumentTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/GetDocumentTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDocumentTypeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDocumentTypeForEditOutput>;
        }));
    }

    protected processGetDocumentTypeForEdit(response: HttpResponseBase): Observable<GetDocumentTypeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDocumentTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDocumentTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @return Success
     */
    getDocumentTypesToExcel(filter: string | undefined, nameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentTypes/GetDocumentTypesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetDocumentTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DynamicEntityPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicEntityPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicEntityPropertyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityFullName (optional) 
     * @return Success
     */
    getAllPropertiesOfAnEntity(entityFullName: string | undefined): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAllPropertiesOfAnEntity?";
        if (entityFullName === null)
            throw new Error("The parameter 'entityFullName' cannot be null.");
        else if (entityFullName !== undefined)
            url_ += "EntityFullName=" + encodeURIComponent("" + entityFullName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPropertiesOfAnEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPropertiesOfAnEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
        }));
    }

    protected processGetAllPropertiesOfAnEntity(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicEntityPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicEntityPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllEntitiesHasDynamicProperty(): Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAllEntitiesHasDynamicProperty";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntitiesHasDynamicProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntitiesHasDynamicProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>;
        }));
    }

    protected processGetAllEntitiesHasDynamicProperty(response: HttpResponseBase): Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DynamicEntityPropertyDefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAllowedInputTypeNames(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyDefinition/GetAllAllowedInputTypeNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAllowedInputTypeNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAllowedInputTypeNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAllAllowedInputTypeNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllEntities(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyDefinition/GetAllEntities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAllEntities(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DynamicEntityPropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicEntityPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicEntityPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicEntityPropertyValueDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicEntityPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicEntityPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param propertyId (optional) 
     * @return Success
     */
    getAll(entityId: string | undefined, propertyId: number | undefined): Observable<ListResultDtoOfDynamicEntityPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/GetAll?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicEntityPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicEntityPropertyValueDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicEntityPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicEntityPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllDynamicEntityPropertyValues(entityFullName: string, entityId: string): Observable<GetAllDynamicEntityPropertyValuesOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/GetAllDynamicEntityPropertyValues?";
        if (entityFullName === undefined || entityFullName === null)
            throw new Error("The parameter 'entityFullName' must be defined and cannot be null.");
        else
            url_ += "EntityFullName=" + encodeURIComponent("" + entityFullName) + "&";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDynamicEntityPropertyValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDynamicEntityPropertyValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllDynamicEntityPropertyValuesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllDynamicEntityPropertyValuesOutput>;
        }));
    }

    protected processGetAllDynamicEntityPropertyValues(response: HttpResponseBase): Observable<GetAllDynamicEntityPropertyValuesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDynamicEntityPropertyValuesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdateAllValues(body: InsertOrUpdateAllValuesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/InsertOrUpdateAllValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertOrUpdateAllValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertOrUpdateAllValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInsertOrUpdateAllValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cleanValues(body: CleanValuesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/CleanValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCleanValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DynamicPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPropertyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfDynamicPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicPropertyDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    findAllowedInputType(name: string | undefined): Observable<IInputType> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/FindAllowedInputType?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindAllowedInputType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindAllowedInputType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IInputType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IInputType>;
        }));
    }

    protected processFindAllowedInputType(response: HttpResponseBase): Observable<IInputType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IInputType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DynamicPropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPropertyValueDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllValuesOfDynamicProperty(id: number | undefined): Observable<ListResultDtoOfDynamicPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/GetAllValuesOfDynamicProperty?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllValuesOfDynamicProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllValuesOfDynamicProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicPropertyValueDto>;
        }));
    }

    protected processGetAllValuesOfDynamicProperty(response: HttpResponseBase): Observable<ListResultDtoOfDynamicPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfEditionListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfEditionListDto>;
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfEditionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionEditOutput>;
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEdition(body: CreateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEdition(body: UpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | undefined, addAllItem: boolean | undefined, onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId === null)
            throw new Error("The parameter 'selectedEditionId' cannot be null.");
        else if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&";
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscribableEditionComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscribableEditionComboboxItemDto[]>;
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmailTemplatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subjectFilter (optional) 
     * @param contentFilter (optional) 
     * @param publishedFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, subjectFilter: string | undefined, contentFilter: string | undefined, publishedFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetEmailTemplateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EmailTemplates/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (subjectFilter === null)
            throw new Error("The parameter 'subjectFilter' cannot be null.");
        else if (subjectFilter !== undefined)
            url_ += "SubjectFilter=" + encodeURIComponent("" + subjectFilter) + "&";
        if (contentFilter === null)
            throw new Error("The parameter 'contentFilter' cannot be null.");
        else if (contentFilter !== undefined)
            url_ += "ContentFilter=" + encodeURIComponent("" + contentFilter) + "&";
        if (publishedFilter === null)
            throw new Error("The parameter 'publishedFilter' cannot be null.");
        else if (publishedFilter !== undefined)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetEmailTemplateForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetEmailTemplateForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEmailTemplateForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetEmailTemplateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmailTemplateForView(id: number | undefined): Observable<GetEmailTemplateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EmailTemplates/GetEmailTemplateForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTemplateForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTemplateForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmailTemplateForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmailTemplateForViewDto>;
        }));
    }

    protected processGetEmailTemplateForView(response: HttpResponseBase): Observable<GetEmailTemplateForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmailTemplateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmailTemplateForEdit(id: number | undefined): Observable<GetEmailTemplateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/EmailTemplates/GetEmailTemplateForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTemplateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTemplateForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmailTemplateForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmailTemplateForEditOutput>;
        }));
    }

    protected processGetEmailTemplateForEdit(response: HttpResponseBase): Observable<GetEmailTemplateForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmailTemplateForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditEmailTemplateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EmailTemplates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EmailTemplates/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param subjectFilter (optional) 
     * @param contentFilter (optional) 
     * @param publishedFilter (optional) 
     * @return Success
     */
    getEmailTemplatesToExcel(filter: string | undefined, subjectFilter: string | undefined, contentFilter: string | undefined, publishedFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/EmailTemplates/GetEmailTemplatesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (subjectFilter === null)
            throw new Error("The parameter 'subjectFilter' cannot be null.");
        else if (subjectFilter !== undefined)
            url_ += "SubjectFilter=" + encodeURIComponent("" + subjectFilter) + "&";
        if (contentFilter === null)
            throw new Error("The parameter 'contentFilter' cannot be null.");
        else if (contentFilter !== undefined)
            url_ += "ContentFilter=" + encodeURIComponent("" + contentFilter) + "&";
        if (publishedFilter === null)
            throw new Error("The parameter 'publishedFilter' cannot be null.");
        else if (publishedFilter !== undefined)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTemplatesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTemplatesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEmailTemplatesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmployeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param firstNameFilter (optional) 
     * @param lastNameFilter (optional) 
     * @param fullAddressFilter (optional) 
     * @param addressFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param cityFilter (optional) 
     * @param maxDateOfBirthFilter (optional) 
     * @param minDateOfBirthFilter (optional) 
     * @param mobileFilter (optional) 
     * @param officePhoneFilter (optional) 
     * @param personalEmailFilter (optional) 
     * @param businessEmailFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param companyNameFilter (optional) 
     * @param profileFilter (optional) 
     * @param maxHireDateFilter (optional) 
     * @param minHireDateFilter (optional) 
     * @param facebookFilter (optional) 
     * @param linkedInFilter (optional) 
     * @param faxFilter (optional) 
     * @param profilePictureIdFilter (optional) 
     * @param currentEmployeeFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param contactFullNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, firstNameFilter: string | undefined, lastNameFilter: string | undefined, fullAddressFilter: string | undefined, addressFilter: string | undefined, zipCodeFilter: string | undefined, cityFilter: string | undefined, maxDateOfBirthFilter: DateTime | undefined, minDateOfBirthFilter: DateTime | undefined, mobileFilter: string | undefined, officePhoneFilter: string | undefined, personalEmailFilter: string | undefined, businessEmailFilter: string | undefined, jobTitleFilter: string | undefined, companyNameFilter: string | undefined, profileFilter: string | undefined, maxHireDateFilter: DateTime | undefined, minHireDateFilter: DateTime | undefined, facebookFilter: string | undefined, linkedInFilter: string | undefined, faxFilter: string | undefined, profilePictureIdFilter: string | undefined, currentEmployeeFilter: number | undefined, stateNameFilter: string | undefined, countryNameFilter: string | undefined, contactFullNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetEmployeeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (firstNameFilter === null)
            throw new Error("The parameter 'firstNameFilter' cannot be null.");
        else if (firstNameFilter !== undefined)
            url_ += "FirstNameFilter=" + encodeURIComponent("" + firstNameFilter) + "&";
        if (lastNameFilter === null)
            throw new Error("The parameter 'lastNameFilter' cannot be null.");
        else if (lastNameFilter !== undefined)
            url_ += "LastNameFilter=" + encodeURIComponent("" + lastNameFilter) + "&";
        if (fullAddressFilter === null)
            throw new Error("The parameter 'fullAddressFilter' cannot be null.");
        else if (fullAddressFilter !== undefined)
            url_ += "FullAddressFilter=" + encodeURIComponent("" + fullAddressFilter) + "&";
        if (addressFilter === null)
            throw new Error("The parameter 'addressFilter' cannot be null.");
        else if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (maxDateOfBirthFilter === null)
            throw new Error("The parameter 'maxDateOfBirthFilter' cannot be null.");
        else if (maxDateOfBirthFilter !== undefined)
            url_ += "MaxDateOfBirthFilter=" + encodeURIComponent(maxDateOfBirthFilter ? "" + maxDateOfBirthFilter.toString() : "") + "&";
        if (minDateOfBirthFilter === null)
            throw new Error("The parameter 'minDateOfBirthFilter' cannot be null.");
        else if (minDateOfBirthFilter !== undefined)
            url_ += "MinDateOfBirthFilter=" + encodeURIComponent(minDateOfBirthFilter ? "" + minDateOfBirthFilter.toString() : "") + "&";
        if (mobileFilter === null)
            throw new Error("The parameter 'mobileFilter' cannot be null.");
        else if (mobileFilter !== undefined)
            url_ += "MobileFilter=" + encodeURIComponent("" + mobileFilter) + "&";
        if (officePhoneFilter === null)
            throw new Error("The parameter 'officePhoneFilter' cannot be null.");
        else if (officePhoneFilter !== undefined)
            url_ += "OfficePhoneFilter=" + encodeURIComponent("" + officePhoneFilter) + "&";
        if (personalEmailFilter === null)
            throw new Error("The parameter 'personalEmailFilter' cannot be null.");
        else if (personalEmailFilter !== undefined)
            url_ += "PersonalEmailFilter=" + encodeURIComponent("" + personalEmailFilter) + "&";
        if (businessEmailFilter === null)
            throw new Error("The parameter 'businessEmailFilter' cannot be null.");
        else if (businessEmailFilter !== undefined)
            url_ += "BusinessEmailFilter=" + encodeURIComponent("" + businessEmailFilter) + "&";
        if (jobTitleFilter === null)
            throw new Error("The parameter 'jobTitleFilter' cannot be null.");
        else if (jobTitleFilter !== undefined)
            url_ += "JobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&";
        if (companyNameFilter === null)
            throw new Error("The parameter 'companyNameFilter' cannot be null.");
        else if (companyNameFilter !== undefined)
            url_ += "CompanyNameFilter=" + encodeURIComponent("" + companyNameFilter) + "&";
        if (profileFilter === null)
            throw new Error("The parameter 'profileFilter' cannot be null.");
        else if (profileFilter !== undefined)
            url_ += "ProfileFilter=" + encodeURIComponent("" + profileFilter) + "&";
        if (maxHireDateFilter === null)
            throw new Error("The parameter 'maxHireDateFilter' cannot be null.");
        else if (maxHireDateFilter !== undefined)
            url_ += "MaxHireDateFilter=" + encodeURIComponent(maxHireDateFilter ? "" + maxHireDateFilter.toString() : "") + "&";
        if (minHireDateFilter === null)
            throw new Error("The parameter 'minHireDateFilter' cannot be null.");
        else if (minHireDateFilter !== undefined)
            url_ += "MinHireDateFilter=" + encodeURIComponent(minHireDateFilter ? "" + minHireDateFilter.toString() : "") + "&";
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&";
        if (linkedInFilter === null)
            throw new Error("The parameter 'linkedInFilter' cannot be null.");
        else if (linkedInFilter !== undefined)
            url_ += "LinkedInFilter=" + encodeURIComponent("" + linkedInFilter) + "&";
        if (faxFilter === null)
            throw new Error("The parameter 'faxFilter' cannot be null.");
        else if (faxFilter !== undefined)
            url_ += "FaxFilter=" + encodeURIComponent("" + faxFilter) + "&";
        if (profilePictureIdFilter === null)
            throw new Error("The parameter 'profilePictureIdFilter' cannot be null.");
        else if (profilePictureIdFilter !== undefined)
            url_ += "ProfilePictureIdFilter=" + encodeURIComponent("" + profilePictureIdFilter) + "&";
        if (currentEmployeeFilter === null)
            throw new Error("The parameter 'currentEmployeeFilter' cannot be null.");
        else if (currentEmployeeFilter !== undefined)
            url_ += "CurrentEmployeeFilter=" + encodeURIComponent("" + currentEmployeeFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (contactFullNameFilter === null)
            throw new Error("The parameter 'contactFullNameFilter' cannot be null.");
        else if (contactFullNameFilter !== undefined)
            url_ += "ContactFullNameFilter=" + encodeURIComponent("" + contactFullNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetEmployeeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetEmployeeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEmployeeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetEmployeeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmployeeForView(id: number | undefined): Observable<GetEmployeeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetEmployeeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmployeeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmployeeForViewDto>;
        }));
    }

    protected processGetEmployeeForView(response: HttpResponseBase): Observable<GetEmployeeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmployeeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmployeeForEdit(id: number | undefined): Observable<GetEmployeeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetEmployeeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmployeeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmployeeForEditOutput>;
        }));
    }

    protected processGetEmployeeForEdit(response: HttpResponseBase): Observable<GetEmployeeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmployeeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditEmployeeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employees/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employees/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param firstNameFilter (optional) 
     * @param lastNameFilter (optional) 
     * @param fullAddressFilter (optional) 
     * @param addressFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param cityFilter (optional) 
     * @param maxDateOfBirthFilter (optional) 
     * @param minDateOfBirthFilter (optional) 
     * @param mobileFilter (optional) 
     * @param officePhoneFilter (optional) 
     * @param personalEmailFilter (optional) 
     * @param businessEmailFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param companyNameFilter (optional) 
     * @param profileFilter (optional) 
     * @param maxHireDateFilter (optional) 
     * @param minHireDateFilter (optional) 
     * @param facebookFilter (optional) 
     * @param linkedInFilter (optional) 
     * @param faxFilter (optional) 
     * @param profilePictureIdFilter (optional) 
     * @param currentEmployeeFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param contactFullNameFilter (optional) 
     * @return Success
     */
    getEmployeesToExcel(filter: string | undefined, nameFilter: string | undefined, firstNameFilter: string | undefined, lastNameFilter: string | undefined, fullAddressFilter: string | undefined, addressFilter: string | undefined, zipCodeFilter: string | undefined, cityFilter: string | undefined, maxDateOfBirthFilter: DateTime | undefined, minDateOfBirthFilter: DateTime | undefined, mobileFilter: string | undefined, officePhoneFilter: string | undefined, personalEmailFilter: string | undefined, businessEmailFilter: string | undefined, jobTitleFilter: string | undefined, companyNameFilter: string | undefined, profileFilter: string | undefined, maxHireDateFilter: DateTime | undefined, minHireDateFilter: DateTime | undefined, facebookFilter: string | undefined, linkedInFilter: string | undefined, faxFilter: string | undefined, profilePictureIdFilter: string | undefined, currentEmployeeFilter: number | undefined, stateNameFilter: string | undefined, countryNameFilter: string | undefined, contactFullNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetEmployeesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (firstNameFilter === null)
            throw new Error("The parameter 'firstNameFilter' cannot be null.");
        else if (firstNameFilter !== undefined)
            url_ += "FirstNameFilter=" + encodeURIComponent("" + firstNameFilter) + "&";
        if (lastNameFilter === null)
            throw new Error("The parameter 'lastNameFilter' cannot be null.");
        else if (lastNameFilter !== undefined)
            url_ += "LastNameFilter=" + encodeURIComponent("" + lastNameFilter) + "&";
        if (fullAddressFilter === null)
            throw new Error("The parameter 'fullAddressFilter' cannot be null.");
        else if (fullAddressFilter !== undefined)
            url_ += "FullAddressFilter=" + encodeURIComponent("" + fullAddressFilter) + "&";
        if (addressFilter === null)
            throw new Error("The parameter 'addressFilter' cannot be null.");
        else if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (maxDateOfBirthFilter === null)
            throw new Error("The parameter 'maxDateOfBirthFilter' cannot be null.");
        else if (maxDateOfBirthFilter !== undefined)
            url_ += "MaxDateOfBirthFilter=" + encodeURIComponent(maxDateOfBirthFilter ? "" + maxDateOfBirthFilter.toString() : "") + "&";
        if (minDateOfBirthFilter === null)
            throw new Error("The parameter 'minDateOfBirthFilter' cannot be null.");
        else if (minDateOfBirthFilter !== undefined)
            url_ += "MinDateOfBirthFilter=" + encodeURIComponent(minDateOfBirthFilter ? "" + minDateOfBirthFilter.toString() : "") + "&";
        if (mobileFilter === null)
            throw new Error("The parameter 'mobileFilter' cannot be null.");
        else if (mobileFilter !== undefined)
            url_ += "MobileFilter=" + encodeURIComponent("" + mobileFilter) + "&";
        if (officePhoneFilter === null)
            throw new Error("The parameter 'officePhoneFilter' cannot be null.");
        else if (officePhoneFilter !== undefined)
            url_ += "OfficePhoneFilter=" + encodeURIComponent("" + officePhoneFilter) + "&";
        if (personalEmailFilter === null)
            throw new Error("The parameter 'personalEmailFilter' cannot be null.");
        else if (personalEmailFilter !== undefined)
            url_ += "PersonalEmailFilter=" + encodeURIComponent("" + personalEmailFilter) + "&";
        if (businessEmailFilter === null)
            throw new Error("The parameter 'businessEmailFilter' cannot be null.");
        else if (businessEmailFilter !== undefined)
            url_ += "BusinessEmailFilter=" + encodeURIComponent("" + businessEmailFilter) + "&";
        if (jobTitleFilter === null)
            throw new Error("The parameter 'jobTitleFilter' cannot be null.");
        else if (jobTitleFilter !== undefined)
            url_ += "JobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&";
        if (companyNameFilter === null)
            throw new Error("The parameter 'companyNameFilter' cannot be null.");
        else if (companyNameFilter !== undefined)
            url_ += "CompanyNameFilter=" + encodeURIComponent("" + companyNameFilter) + "&";
        if (profileFilter === null)
            throw new Error("The parameter 'profileFilter' cannot be null.");
        else if (profileFilter !== undefined)
            url_ += "ProfileFilter=" + encodeURIComponent("" + profileFilter) + "&";
        if (maxHireDateFilter === null)
            throw new Error("The parameter 'maxHireDateFilter' cannot be null.");
        else if (maxHireDateFilter !== undefined)
            url_ += "MaxHireDateFilter=" + encodeURIComponent(maxHireDateFilter ? "" + maxHireDateFilter.toString() : "") + "&";
        if (minHireDateFilter === null)
            throw new Error("The parameter 'minHireDateFilter' cannot be null.");
        else if (minHireDateFilter !== undefined)
            url_ += "MinHireDateFilter=" + encodeURIComponent(minHireDateFilter ? "" + minHireDateFilter.toString() : "") + "&";
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&";
        if (linkedInFilter === null)
            throw new Error("The parameter 'linkedInFilter' cannot be null.");
        else if (linkedInFilter !== undefined)
            url_ += "LinkedInFilter=" + encodeURIComponent("" + linkedInFilter) + "&";
        if (faxFilter === null)
            throw new Error("The parameter 'faxFilter' cannot be null.");
        else if (faxFilter !== undefined)
            url_ += "FaxFilter=" + encodeURIComponent("" + faxFilter) + "&";
        if (profilePictureIdFilter === null)
            throw new Error("The parameter 'profilePictureIdFilter' cannot be null.");
        else if (profilePictureIdFilter !== undefined)
            url_ += "ProfilePictureIdFilter=" + encodeURIComponent("" + profilePictureIdFilter) + "&";
        if (currentEmployeeFilter === null)
            throw new Error("The parameter 'currentEmployeeFilter' cannot be null.");
        else if (currentEmployeeFilter !== undefined)
            url_ += "CurrentEmployeeFilter=" + encodeURIComponent("" + currentEmployeeFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (contactFullNameFilter === null)
            throw new Error("The parameter 'contactFullNameFilter' cannot be null.");
        else if (contactFullNameFilter !== undefined)
            url_ += "ContactFullNameFilter=" + encodeURIComponent("" + contactFullNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEmployeesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStateForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfEmployeeStateLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetAllStateForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStateForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStateForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEmployeeStateLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEmployeeStateLookupTableDto>;
        }));
    }

    protected processGetAllStateForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEmployeeStateLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEmployeeStateLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCountryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfEmployeeCountryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetAllCountryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEmployeeCountryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEmployeeCountryLookupTableDto>;
        }));
    }

    protected processGetAllCountryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEmployeeCountryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEmployeeCountryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllContactForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfEmployeeContactLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetAllContactForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContactForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContactForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEmployeeContactLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEmployeeContactLookupTableDto>;
        }));
    }

    protected processGetAllContactForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEmployeeContactLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEmployeeContactLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmployeeTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param employeeNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, employeeNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetEmployeeTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeTags/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (employeeNameFilter === null)
            throw new Error("The parameter 'employeeNameFilter' cannot be null.");
        else if (employeeNameFilter !== undefined)
            url_ += "EmployeeNameFilter=" + encodeURIComponent("" + employeeNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetEmployeeTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetEmployeeTagForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEmployeeTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetEmployeeTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmployeeTagForView(id: number | undefined): Observable<GetEmployeeTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeTags/GetEmployeeTagForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTagForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTagForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmployeeTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmployeeTagForViewDto>;
        }));
    }

    protected processGetEmployeeTagForView(response: HttpResponseBase): Observable<GetEmployeeTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmployeeTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmployeeTagForEdit(id: number | undefined): Observable<GetEmployeeTagForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeTags/GetEmployeeTagForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTagForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTagForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEmployeeTagForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEmployeeTagForEditOutput>;
        }));
    }

    protected processGetEmployeeTagForEdit(response: HttpResponseBase): Observable<GetEmployeeTagForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEmployeeTagForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditEmployeeTagDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeTags/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeTags/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param employeeNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @return Success
     */
    getEmployeeTagsToExcel(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, employeeNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeTags/GetEmployeeTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (employeeNameFilter === null)
            throw new Error("The parameter 'employeeNameFilter' cannot be null.");
        else if (employeeNameFilter !== undefined)
            url_ += "EmployeeNameFilter=" + encodeURIComponent("" + employeeNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTagsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEmployeeTagsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllEmployeeForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfEmployeeTagEmployeeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeTags/GetAllEmployeeForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployeeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployeeForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEmployeeTagEmployeeLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEmployeeTagEmployeeLookupTableDto>;
        }));
    }

    protected processGetAllEmployeeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEmployeeTagEmployeeLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEmployeeTagEmployeeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeTags/GetAllMasterTagCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfEmployeeTagMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeTags/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEmployeeTagMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEmployeeTagMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEmployeeTagMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEmployeeTagMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    removeFriend(userId: number | undefined, tenantId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/RemoveFriend?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFriend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFriend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveFriend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getTopStatsData(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<TopStatsData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetTopStatsData?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStatsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStatsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TopStatsData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TopStatsData>;
        }));
    }

    protected processGetTopStatsData(response: HttpResponseBase): Observable<TopStatsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TopStatsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRecentTenantsData(): Observable<GetRecentTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetRecentTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentTenantsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRecentTenantsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRecentTenantsOutput>;
        }));
    }

    protected processGetRecentTenantsData(response: HttpResponseBase): Observable<GetRecentTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRecentTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getSubscriptionExpiringTenantsData(): Observable<GetExpiringTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetSubscriptionExpiringTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionExpiringTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionExpiringTenantsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetExpiringTenantsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetExpiringTenantsOutput>;
        }));
    }

    protected processGetSubscriptionExpiringTenantsData(response: HttpResponseBase): Observable<GetExpiringTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExpiringTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIncomeStatisticsDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIncomeStatisticsDataOutput>;
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncomeStatisticsDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionTenantStatisticsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionTenantStatisticsOutput>;
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionTenantStatisticsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginSettingsDto>;
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HubsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxEstimatedPopulationFilter (optional) 
     * @param minEstimatedPopulationFilter (optional) 
     * @param hasParentHubFilter (optional) 
     * @param maxParentHubIdFilter (optional) 
     * @param minParentHubIdFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param liveFilter (optional) 
     * @param urlFilter (optional) 
     * @param officeFullAddressFilter (optional) 
     * @param partnerOrOwnedFilter (optional) 
     * @param phoneFilter (optional) 
     * @param yearlyRevenueFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param cityNameFilter (optional) 
     * @param countyNameFilter (optional) 
     * @param hubTypeNameFilter (optional) 
     * @param currencyNameFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, maxEstimatedPopulationFilter: number | undefined, minEstimatedPopulationFilter: number | undefined, hasParentHubFilter: number | undefined, maxParentHubIdFilter: number | undefined, minParentHubIdFilter: number | undefined, maxLatitudeFilter: number | undefined, minLatitudeFilter: number | undefined, maxLongitudeFilter: number | undefined, minLongitudeFilter: number | undefined, liveFilter: number | undefined, urlFilter: string | undefined, officeFullAddressFilter: string | undefined, partnerOrOwnedFilter: number | undefined, phoneFilter: string | undefined, yearlyRevenueFilter: string | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, cityNameFilter: string | undefined, countyNameFilter: string | undefined, hubTypeNameFilter: string | undefined, currencyNameFilter: string | undefined, mediaLibraryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetHubForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (maxEstimatedPopulationFilter === null)
            throw new Error("The parameter 'maxEstimatedPopulationFilter' cannot be null.");
        else if (maxEstimatedPopulationFilter !== undefined)
            url_ += "MaxEstimatedPopulationFilter=" + encodeURIComponent("" + maxEstimatedPopulationFilter) + "&";
        if (minEstimatedPopulationFilter === null)
            throw new Error("The parameter 'minEstimatedPopulationFilter' cannot be null.");
        else if (minEstimatedPopulationFilter !== undefined)
            url_ += "MinEstimatedPopulationFilter=" + encodeURIComponent("" + minEstimatedPopulationFilter) + "&";
        if (hasParentHubFilter === null)
            throw new Error("The parameter 'hasParentHubFilter' cannot be null.");
        else if (hasParentHubFilter !== undefined)
            url_ += "HasParentHubFilter=" + encodeURIComponent("" + hasParentHubFilter) + "&";
        if (maxParentHubIdFilter === null)
            throw new Error("The parameter 'maxParentHubIdFilter' cannot be null.");
        else if (maxParentHubIdFilter !== undefined)
            url_ += "MaxParentHubIdFilter=" + encodeURIComponent("" + maxParentHubIdFilter) + "&";
        if (minParentHubIdFilter === null)
            throw new Error("The parameter 'minParentHubIdFilter' cannot be null.");
        else if (minParentHubIdFilter !== undefined)
            url_ += "MinParentHubIdFilter=" + encodeURIComponent("" + minParentHubIdFilter) + "&";
        if (maxLatitudeFilter === null)
            throw new Error("The parameter 'maxLatitudeFilter' cannot be null.");
        else if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&";
        if (minLatitudeFilter === null)
            throw new Error("The parameter 'minLatitudeFilter' cannot be null.");
        else if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&";
        if (maxLongitudeFilter === null)
            throw new Error("The parameter 'maxLongitudeFilter' cannot be null.");
        else if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&";
        if (minLongitudeFilter === null)
            throw new Error("The parameter 'minLongitudeFilter' cannot be null.");
        else if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&";
        if (liveFilter === null)
            throw new Error("The parameter 'liveFilter' cannot be null.");
        else if (liveFilter !== undefined)
            url_ += "LiveFilter=" + encodeURIComponent("" + liveFilter) + "&";
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&";
        if (officeFullAddressFilter === null)
            throw new Error("The parameter 'officeFullAddressFilter' cannot be null.");
        else if (officeFullAddressFilter !== undefined)
            url_ += "OfficeFullAddressFilter=" + encodeURIComponent("" + officeFullAddressFilter) + "&";
        if (partnerOrOwnedFilter === null)
            throw new Error("The parameter 'partnerOrOwnedFilter' cannot be null.");
        else if (partnerOrOwnedFilter !== undefined)
            url_ += "PartnerOrOwnedFilter=" + encodeURIComponent("" + partnerOrOwnedFilter) + "&";
        if (phoneFilter === null)
            throw new Error("The parameter 'phoneFilter' cannot be null.");
        else if (phoneFilter !== undefined)
            url_ += "PhoneFilter=" + encodeURIComponent("" + phoneFilter) + "&";
        if (yearlyRevenueFilter === null)
            throw new Error("The parameter 'yearlyRevenueFilter' cannot be null.");
        else if (yearlyRevenueFilter !== undefined)
            url_ += "YearlyRevenueFilter=" + encodeURIComponent("" + yearlyRevenueFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (cityNameFilter === null)
            throw new Error("The parameter 'cityNameFilter' cannot be null.");
        else if (cityNameFilter !== undefined)
            url_ += "CityNameFilter=" + encodeURIComponent("" + cityNameFilter) + "&";
        if (countyNameFilter === null)
            throw new Error("The parameter 'countyNameFilter' cannot be null.");
        else if (countyNameFilter !== undefined)
            url_ += "CountyNameFilter=" + encodeURIComponent("" + countyNameFilter) + "&";
        if (hubTypeNameFilter === null)
            throw new Error("The parameter 'hubTypeNameFilter' cannot be null.");
        else if (hubTypeNameFilter !== undefined)
            url_ += "HubTypeNameFilter=" + encodeURIComponent("" + hubTypeNameFilter) + "&";
        if (currencyNameFilter === null)
            throw new Error("The parameter 'currencyNameFilter' cannot be null.");
        else if (currencyNameFilter !== undefined)
            url_ += "CurrencyNameFilter=" + encodeURIComponent("" + currencyNameFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetHubForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetHubForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetHubForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetHubForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHubForView(id: number | undefined): Observable<GetHubForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetHubForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHubForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHubForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetHubForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetHubForViewDto>;
        }));
    }

    protected processGetHubForView(response: HttpResponseBase): Observable<GetHubForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetHubForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHubForEdit(id: number | undefined): Observable<GetHubForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetHubForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHubForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHubForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetHubForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetHubForEditOutput>;
        }));
    }

    protected processGetHubForEdit(response: HttpResponseBase): Observable<GetHubForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetHubForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditHubDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxEstimatedPopulationFilter (optional) 
     * @param minEstimatedPopulationFilter (optional) 
     * @param hasParentHubFilter (optional) 
     * @param maxParentHubIdFilter (optional) 
     * @param minParentHubIdFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param liveFilter (optional) 
     * @param urlFilter (optional) 
     * @param officeFullAddressFilter (optional) 
     * @param partnerOrOwnedFilter (optional) 
     * @param phoneFilter (optional) 
     * @param yearlyRevenueFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param cityNameFilter (optional) 
     * @param countyNameFilter (optional) 
     * @param hubTypeNameFilter (optional) 
     * @param currencyNameFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @return Success
     */
    getHubsToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, maxEstimatedPopulationFilter: number | undefined, minEstimatedPopulationFilter: number | undefined, hasParentHubFilter: number | undefined, maxParentHubIdFilter: number | undefined, minParentHubIdFilter: number | undefined, maxLatitudeFilter: number | undefined, minLatitudeFilter: number | undefined, maxLongitudeFilter: number | undefined, minLongitudeFilter: number | undefined, liveFilter: number | undefined, urlFilter: string | undefined, officeFullAddressFilter: string | undefined, partnerOrOwnedFilter: number | undefined, phoneFilter: string | undefined, yearlyRevenueFilter: string | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, cityNameFilter: string | undefined, countyNameFilter: string | undefined, hubTypeNameFilter: string | undefined, currencyNameFilter: string | undefined, mediaLibraryNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetHubsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (maxEstimatedPopulationFilter === null)
            throw new Error("The parameter 'maxEstimatedPopulationFilter' cannot be null.");
        else if (maxEstimatedPopulationFilter !== undefined)
            url_ += "MaxEstimatedPopulationFilter=" + encodeURIComponent("" + maxEstimatedPopulationFilter) + "&";
        if (minEstimatedPopulationFilter === null)
            throw new Error("The parameter 'minEstimatedPopulationFilter' cannot be null.");
        else if (minEstimatedPopulationFilter !== undefined)
            url_ += "MinEstimatedPopulationFilter=" + encodeURIComponent("" + minEstimatedPopulationFilter) + "&";
        if (hasParentHubFilter === null)
            throw new Error("The parameter 'hasParentHubFilter' cannot be null.");
        else if (hasParentHubFilter !== undefined)
            url_ += "HasParentHubFilter=" + encodeURIComponent("" + hasParentHubFilter) + "&";
        if (maxParentHubIdFilter === null)
            throw new Error("The parameter 'maxParentHubIdFilter' cannot be null.");
        else if (maxParentHubIdFilter !== undefined)
            url_ += "MaxParentHubIdFilter=" + encodeURIComponent("" + maxParentHubIdFilter) + "&";
        if (minParentHubIdFilter === null)
            throw new Error("The parameter 'minParentHubIdFilter' cannot be null.");
        else if (minParentHubIdFilter !== undefined)
            url_ += "MinParentHubIdFilter=" + encodeURIComponent("" + minParentHubIdFilter) + "&";
        if (maxLatitudeFilter === null)
            throw new Error("The parameter 'maxLatitudeFilter' cannot be null.");
        else if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&";
        if (minLatitudeFilter === null)
            throw new Error("The parameter 'minLatitudeFilter' cannot be null.");
        else if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&";
        if (maxLongitudeFilter === null)
            throw new Error("The parameter 'maxLongitudeFilter' cannot be null.");
        else if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&";
        if (minLongitudeFilter === null)
            throw new Error("The parameter 'minLongitudeFilter' cannot be null.");
        else if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&";
        if (liveFilter === null)
            throw new Error("The parameter 'liveFilter' cannot be null.");
        else if (liveFilter !== undefined)
            url_ += "LiveFilter=" + encodeURIComponent("" + liveFilter) + "&";
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&";
        if (officeFullAddressFilter === null)
            throw new Error("The parameter 'officeFullAddressFilter' cannot be null.");
        else if (officeFullAddressFilter !== undefined)
            url_ += "OfficeFullAddressFilter=" + encodeURIComponent("" + officeFullAddressFilter) + "&";
        if (partnerOrOwnedFilter === null)
            throw new Error("The parameter 'partnerOrOwnedFilter' cannot be null.");
        else if (partnerOrOwnedFilter !== undefined)
            url_ += "PartnerOrOwnedFilter=" + encodeURIComponent("" + partnerOrOwnedFilter) + "&";
        if (phoneFilter === null)
            throw new Error("The parameter 'phoneFilter' cannot be null.");
        else if (phoneFilter !== undefined)
            url_ += "PhoneFilter=" + encodeURIComponent("" + phoneFilter) + "&";
        if (yearlyRevenueFilter === null)
            throw new Error("The parameter 'yearlyRevenueFilter' cannot be null.");
        else if (yearlyRevenueFilter !== undefined)
            url_ += "YearlyRevenueFilter=" + encodeURIComponent("" + yearlyRevenueFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (cityNameFilter === null)
            throw new Error("The parameter 'cityNameFilter' cannot be null.");
        else if (cityNameFilter !== undefined)
            url_ += "CityNameFilter=" + encodeURIComponent("" + cityNameFilter) + "&";
        if (countyNameFilter === null)
            throw new Error("The parameter 'countyNameFilter' cannot be null.");
        else if (countyNameFilter !== undefined)
            url_ += "CountyNameFilter=" + encodeURIComponent("" + countyNameFilter) + "&";
        if (hubTypeNameFilter === null)
            throw new Error("The parameter 'hubTypeNameFilter' cannot be null.");
        else if (hubTypeNameFilter !== undefined)
            url_ += "HubTypeNameFilter=" + encodeURIComponent("" + hubTypeNameFilter) + "&";
        if (currencyNameFilter === null)
            throw new Error("The parameter 'currencyNameFilter' cannot be null.");
        else if (currencyNameFilter !== undefined)
            url_ += "CurrencyNameFilter=" + encodeURIComponent("" + currencyNameFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHubsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHubsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetHubsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountryForTableDropdown(): Observable<HubCountryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetAllCountryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HubCountryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HubCountryLookupTableDto[]>;
        }));
    }

    protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<HubCountryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HubCountryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllStateForTableDropdown(): Observable<HubStateLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetAllStateForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStateForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStateForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HubStateLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HubStateLookupTableDto[]>;
        }));
    }

    protected processGetAllStateForTableDropdown(response: HttpResponseBase): Observable<HubStateLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HubStateLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCityForTableDropdown(): Observable<HubCityLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetAllCityForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCityForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCityForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HubCityLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HubCityLookupTableDto[]>;
        }));
    }

    protected processGetAllCityForTableDropdown(response: HttpResponseBase): Observable<HubCityLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HubCityLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountyForTableDropdown(): Observable<HubCountyLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetAllCountyForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountyForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountyForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HubCountyLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HubCountyLookupTableDto[]>;
        }));
    }

    protected processGetAllCountyForTableDropdown(response: HttpResponseBase): Observable<HubCountyLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HubCountyLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllHubTypeForTableDropdown(): Observable<HubHubTypeLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetAllHubTypeForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHubTypeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHubTypeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HubHubTypeLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HubHubTypeLookupTableDto[]>;
        }));
    }

    protected processGetAllHubTypeForTableDropdown(response: HttpResponseBase): Observable<HubHubTypeLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HubHubTypeLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCurrencyForTableDropdown(): Observable<HubCurrencyLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetAllCurrencyForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencyForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HubCurrencyLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HubCurrencyLookupTableDto[]>;
        }));
    }

    protected processGetAllCurrencyForTableDropdown(response: HttpResponseBase): Observable<HubCurrencyLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HubCurrencyLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMediaLibraryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfHubMediaLibraryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Hubs/GetAllMediaLibraryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMediaLibraryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMediaLibraryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfHubMediaLibraryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfHubMediaLibraryLookupTableDto>;
        }));
    }

    protected processGetAllMediaLibraryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfHubMediaLibraryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfHubMediaLibraryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HubTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetHubTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/HubTypes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetHubTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetHubTypeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetHubTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetHubTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHubTypeForView(id: number | undefined): Observable<GetHubTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/HubTypes/GetHubTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHubTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHubTypeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetHubTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetHubTypeForViewDto>;
        }));
    }

    protected processGetHubTypeForView(response: HttpResponseBase): Observable<GetHubTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetHubTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHubTypeForEdit(id: number | undefined): Observable<GetHubTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/HubTypes/GetHubTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHubTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHubTypeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetHubTypeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetHubTypeForEditOutput>;
        }));
    }

    protected processGetHubTypeForEdit(response: HttpResponseBase): Observable<GetHubTypeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetHubTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditHubTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HubTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HubTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @return Success
     */
    getHubTypesToExcel(filter: string | undefined, nameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/HubTypes/GetHubTypesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHubTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHubTypesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetHubTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setup(body: InstallDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingsJsonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingsJsonDto>;
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingsJsonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckDatabaseOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckDatabaseOutput>;
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckDatabaseOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoice(body: CreateInvoiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param fullTimeJobOrGigWorkProjectFilter (optional) 
     * @param remoteWorkOrOnSiteWorkFilter (optional) 
     * @param salaryBasedOrFixedPriceFilter (optional) 
     * @param salaryOrStaffingRateFilter (optional) 
     * @param referralPointsFilter (optional) 
     * @param templateFilter (optional) 
     * @param maxNumberOfJobsFilter (optional) 
     * @param minNumberOfJobsFilter (optional) 
     * @param minimumExperienceFilter (optional) 
     * @param maximumExperienceFilter (optional) 
     * @param jobDescriptionFilter (optional) 
     * @param jobLocationFullAddressFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxHireByDateFilter (optional) 
     * @param minHireByDateFilter (optional) 
     * @param maxPublishDateFilter (optional) 
     * @param minPublishDateFilter (optional) 
     * @param maxExpirationDateFilter (optional) 
     * @param minExpirationDateFilter (optional) 
     * @param internalJobDescriptionFilter (optional) 
     * @param cityLocationFilter (optional) 
     * @param publishedFilter (optional) 
     * @param urlFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param productCategoryNameFilter (optional) 
     * @param currencyNameFilter (optional) 
     * @param businessNameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param cityNameFilter (optional) 
     * @param jobStatusTypeNameFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, titleFilter: string | undefined, fullTimeJobOrGigWorkProjectFilter: number | undefined, remoteWorkOrOnSiteWorkFilter: number | undefined, salaryBasedOrFixedPriceFilter: number | undefined, salaryOrStaffingRateFilter: string | undefined, referralPointsFilter: string | undefined, templateFilter: number | undefined, maxNumberOfJobsFilter: number | undefined, minNumberOfJobsFilter: number | undefined, minimumExperienceFilter: string | undefined, maximumExperienceFilter: string | undefined, jobDescriptionFilter: string | undefined, jobLocationFullAddressFilter: string | undefined, zipCodeFilter: string | undefined, maxLatitudeFilter: number | undefined, minLatitudeFilter: number | undefined, maxLongitudeFilter: number | undefined, minLongitudeFilter: number | undefined, maxStartDateFilter: DateTime | undefined, minStartDateFilter: DateTime | undefined, maxHireByDateFilter: DateTime | undefined, minHireByDateFilter: DateTime | undefined, maxPublishDateFilter: DateTime | undefined, minPublishDateFilter: DateTime | undefined, maxExpirationDateFilter: DateTime | undefined, minExpirationDateFilter: DateTime | undefined, internalJobDescriptionFilter: string | undefined, cityLocationFilter: string | undefined, publishedFilter: number | undefined, urlFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, productCategoryNameFilter: string | undefined, currencyNameFilter: string | undefined, businessNameFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, cityNameFilter: string | undefined, jobStatusTypeNameFilter: string | undefined, storeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetJobForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (titleFilter === null)
            throw new Error("The parameter 'titleFilter' cannot be null.");
        else if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&";
        if (fullTimeJobOrGigWorkProjectFilter === null)
            throw new Error("The parameter 'fullTimeJobOrGigWorkProjectFilter' cannot be null.");
        else if (fullTimeJobOrGigWorkProjectFilter !== undefined)
            url_ += "FullTimeJobOrGigWorkProjectFilter=" + encodeURIComponent("" + fullTimeJobOrGigWorkProjectFilter) + "&";
        if (remoteWorkOrOnSiteWorkFilter === null)
            throw new Error("The parameter 'remoteWorkOrOnSiteWorkFilter' cannot be null.");
        else if (remoteWorkOrOnSiteWorkFilter !== undefined)
            url_ += "RemoteWorkOrOnSiteWorkFilter=" + encodeURIComponent("" + remoteWorkOrOnSiteWorkFilter) + "&";
        if (salaryBasedOrFixedPriceFilter === null)
            throw new Error("The parameter 'salaryBasedOrFixedPriceFilter' cannot be null.");
        else if (salaryBasedOrFixedPriceFilter !== undefined)
            url_ += "SalaryBasedOrFixedPriceFilter=" + encodeURIComponent("" + salaryBasedOrFixedPriceFilter) + "&";
        if (salaryOrStaffingRateFilter === null)
            throw new Error("The parameter 'salaryOrStaffingRateFilter' cannot be null.");
        else if (salaryOrStaffingRateFilter !== undefined)
            url_ += "SalaryOrStaffingRateFilter=" + encodeURIComponent("" + salaryOrStaffingRateFilter) + "&";
        if (referralPointsFilter === null)
            throw new Error("The parameter 'referralPointsFilter' cannot be null.");
        else if (referralPointsFilter !== undefined)
            url_ += "ReferralPointsFilter=" + encodeURIComponent("" + referralPointsFilter) + "&";
        if (templateFilter === null)
            throw new Error("The parameter 'templateFilter' cannot be null.");
        else if (templateFilter !== undefined)
            url_ += "TemplateFilter=" + encodeURIComponent("" + templateFilter) + "&";
        if (maxNumberOfJobsFilter === null)
            throw new Error("The parameter 'maxNumberOfJobsFilter' cannot be null.");
        else if (maxNumberOfJobsFilter !== undefined)
            url_ += "MaxNumberOfJobsFilter=" + encodeURIComponent("" + maxNumberOfJobsFilter) + "&";
        if (minNumberOfJobsFilter === null)
            throw new Error("The parameter 'minNumberOfJobsFilter' cannot be null.");
        else if (minNumberOfJobsFilter !== undefined)
            url_ += "MinNumberOfJobsFilter=" + encodeURIComponent("" + minNumberOfJobsFilter) + "&";
        if (minimumExperienceFilter === null)
            throw new Error("The parameter 'minimumExperienceFilter' cannot be null.");
        else if (minimumExperienceFilter !== undefined)
            url_ += "MinimumExperienceFilter=" + encodeURIComponent("" + minimumExperienceFilter) + "&";
        if (maximumExperienceFilter === null)
            throw new Error("The parameter 'maximumExperienceFilter' cannot be null.");
        else if (maximumExperienceFilter !== undefined)
            url_ += "MaximumExperienceFilter=" + encodeURIComponent("" + maximumExperienceFilter) + "&";
        if (jobDescriptionFilter === null)
            throw new Error("The parameter 'jobDescriptionFilter' cannot be null.");
        else if (jobDescriptionFilter !== undefined)
            url_ += "JobDescriptionFilter=" + encodeURIComponent("" + jobDescriptionFilter) + "&";
        if (jobLocationFullAddressFilter === null)
            throw new Error("The parameter 'jobLocationFullAddressFilter' cannot be null.");
        else if (jobLocationFullAddressFilter !== undefined)
            url_ += "JobLocationFullAddressFilter=" + encodeURIComponent("" + jobLocationFullAddressFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (maxLatitudeFilter === null)
            throw new Error("The parameter 'maxLatitudeFilter' cannot be null.");
        else if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&";
        if (minLatitudeFilter === null)
            throw new Error("The parameter 'minLatitudeFilter' cannot be null.");
        else if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&";
        if (maxLongitudeFilter === null)
            throw new Error("The parameter 'maxLongitudeFilter' cannot be null.");
        else if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&";
        if (minLongitudeFilter === null)
            throw new Error("The parameter 'minLongitudeFilter' cannot be null.");
        else if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&";
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toString() : "") + "&";
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toString() : "") + "&";
        if (maxHireByDateFilter === null)
            throw new Error("The parameter 'maxHireByDateFilter' cannot be null.");
        else if (maxHireByDateFilter !== undefined)
            url_ += "MaxHireByDateFilter=" + encodeURIComponent(maxHireByDateFilter ? "" + maxHireByDateFilter.toString() : "") + "&";
        if (minHireByDateFilter === null)
            throw new Error("The parameter 'minHireByDateFilter' cannot be null.");
        else if (minHireByDateFilter !== undefined)
            url_ += "MinHireByDateFilter=" + encodeURIComponent(minHireByDateFilter ? "" + minHireByDateFilter.toString() : "") + "&";
        if (maxPublishDateFilter === null)
            throw new Error("The parameter 'maxPublishDateFilter' cannot be null.");
        else if (maxPublishDateFilter !== undefined)
            url_ += "MaxPublishDateFilter=" + encodeURIComponent(maxPublishDateFilter ? "" + maxPublishDateFilter.toString() : "") + "&";
        if (minPublishDateFilter === null)
            throw new Error("The parameter 'minPublishDateFilter' cannot be null.");
        else if (minPublishDateFilter !== undefined)
            url_ += "MinPublishDateFilter=" + encodeURIComponent(minPublishDateFilter ? "" + minPublishDateFilter.toString() : "") + "&";
        if (maxExpirationDateFilter === null)
            throw new Error("The parameter 'maxExpirationDateFilter' cannot be null.");
        else if (maxExpirationDateFilter !== undefined)
            url_ += "MaxExpirationDateFilter=" + encodeURIComponent(maxExpirationDateFilter ? "" + maxExpirationDateFilter.toString() : "") + "&";
        if (minExpirationDateFilter === null)
            throw new Error("The parameter 'minExpirationDateFilter' cannot be null.");
        else if (minExpirationDateFilter !== undefined)
            url_ += "MinExpirationDateFilter=" + encodeURIComponent(minExpirationDateFilter ? "" + minExpirationDateFilter.toString() : "") + "&";
        if (internalJobDescriptionFilter === null)
            throw new Error("The parameter 'internalJobDescriptionFilter' cannot be null.");
        else if (internalJobDescriptionFilter !== undefined)
            url_ += "InternalJobDescriptionFilter=" + encodeURIComponent("" + internalJobDescriptionFilter) + "&";
        if (cityLocationFilter === null)
            throw new Error("The parameter 'cityLocationFilter' cannot be null.");
        else if (cityLocationFilter !== undefined)
            url_ += "CityLocationFilter=" + encodeURIComponent("" + cityLocationFilter) + "&";
        if (publishedFilter === null)
            throw new Error("The parameter 'publishedFilter' cannot be null.");
        else if (publishedFilter !== undefined)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (productCategoryNameFilter === null)
            throw new Error("The parameter 'productCategoryNameFilter' cannot be null.");
        else if (productCategoryNameFilter !== undefined)
            url_ += "ProductCategoryNameFilter=" + encodeURIComponent("" + productCategoryNameFilter) + "&";
        if (currencyNameFilter === null)
            throw new Error("The parameter 'currencyNameFilter' cannot be null.");
        else if (currencyNameFilter !== undefined)
            url_ += "CurrencyNameFilter=" + encodeURIComponent("" + currencyNameFilter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (cityNameFilter === null)
            throw new Error("The parameter 'cityNameFilter' cannot be null.");
        else if (cityNameFilter !== undefined)
            url_ += "CityNameFilter=" + encodeURIComponent("" + cityNameFilter) + "&";
        if (jobStatusTypeNameFilter === null)
            throw new Error("The parameter 'jobStatusTypeNameFilter' cannot be null.");
        else if (jobStatusTypeNameFilter !== undefined)
            url_ += "JobStatusTypeNameFilter=" + encodeURIComponent("" + jobStatusTypeNameFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetJobForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetJobForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetJobForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetJobForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getJobForView(id: number | undefined): Observable<GetJobForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetJobForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJobForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJobForViewDto>;
        }));
    }

    protected processGetJobForView(response: HttpResponseBase): Observable<GetJobForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJobForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getJobForEdit(id: number | undefined): Observable<GetJobForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetJobForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJobForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJobForEditOutput>;
        }));
    }

    protected processGetJobForEdit(response: HttpResponseBase): Observable<GetJobForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJobForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditJobDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param fullTimeJobOrGigWorkProjectFilter (optional) 
     * @param remoteWorkOrOnSiteWorkFilter (optional) 
     * @param salaryBasedOrFixedPriceFilter (optional) 
     * @param salaryOrStaffingRateFilter (optional) 
     * @param referralPointsFilter (optional) 
     * @param templateFilter (optional) 
     * @param maxNumberOfJobsFilter (optional) 
     * @param minNumberOfJobsFilter (optional) 
     * @param minimumExperienceFilter (optional) 
     * @param maximumExperienceFilter (optional) 
     * @param jobDescriptionFilter (optional) 
     * @param jobLocationFullAddressFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxHireByDateFilter (optional) 
     * @param minHireByDateFilter (optional) 
     * @param maxPublishDateFilter (optional) 
     * @param minPublishDateFilter (optional) 
     * @param maxExpirationDateFilter (optional) 
     * @param minExpirationDateFilter (optional) 
     * @param internalJobDescriptionFilter (optional) 
     * @param cityLocationFilter (optional) 
     * @param publishedFilter (optional) 
     * @param urlFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param productCategoryNameFilter (optional) 
     * @param currencyNameFilter (optional) 
     * @param businessNameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param cityNameFilter (optional) 
     * @param jobStatusTypeNameFilter (optional) 
     * @param storeNameFilter (optional) 
     * @return Success
     */
    getJobsToExcel(filter: string | undefined, titleFilter: string | undefined, fullTimeJobOrGigWorkProjectFilter: number | undefined, remoteWorkOrOnSiteWorkFilter: number | undefined, salaryBasedOrFixedPriceFilter: number | undefined, salaryOrStaffingRateFilter: string | undefined, referralPointsFilter: string | undefined, templateFilter: number | undefined, maxNumberOfJobsFilter: number | undefined, minNumberOfJobsFilter: number | undefined, minimumExperienceFilter: string | undefined, maximumExperienceFilter: string | undefined, jobDescriptionFilter: string | undefined, jobLocationFullAddressFilter: string | undefined, zipCodeFilter: string | undefined, maxLatitudeFilter: number | undefined, minLatitudeFilter: number | undefined, maxLongitudeFilter: number | undefined, minLongitudeFilter: number | undefined, maxStartDateFilter: DateTime | undefined, minStartDateFilter: DateTime | undefined, maxHireByDateFilter: DateTime | undefined, minHireByDateFilter: DateTime | undefined, maxPublishDateFilter: DateTime | undefined, minPublishDateFilter: DateTime | undefined, maxExpirationDateFilter: DateTime | undefined, minExpirationDateFilter: DateTime | undefined, internalJobDescriptionFilter: string | undefined, cityLocationFilter: string | undefined, publishedFilter: number | undefined, urlFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, productCategoryNameFilter: string | undefined, currencyNameFilter: string | undefined, businessNameFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, cityNameFilter: string | undefined, jobStatusTypeNameFilter: string | undefined, storeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetJobsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (titleFilter === null)
            throw new Error("The parameter 'titleFilter' cannot be null.");
        else if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&";
        if (fullTimeJobOrGigWorkProjectFilter === null)
            throw new Error("The parameter 'fullTimeJobOrGigWorkProjectFilter' cannot be null.");
        else if (fullTimeJobOrGigWorkProjectFilter !== undefined)
            url_ += "FullTimeJobOrGigWorkProjectFilter=" + encodeURIComponent("" + fullTimeJobOrGigWorkProjectFilter) + "&";
        if (remoteWorkOrOnSiteWorkFilter === null)
            throw new Error("The parameter 'remoteWorkOrOnSiteWorkFilter' cannot be null.");
        else if (remoteWorkOrOnSiteWorkFilter !== undefined)
            url_ += "RemoteWorkOrOnSiteWorkFilter=" + encodeURIComponent("" + remoteWorkOrOnSiteWorkFilter) + "&";
        if (salaryBasedOrFixedPriceFilter === null)
            throw new Error("The parameter 'salaryBasedOrFixedPriceFilter' cannot be null.");
        else if (salaryBasedOrFixedPriceFilter !== undefined)
            url_ += "SalaryBasedOrFixedPriceFilter=" + encodeURIComponent("" + salaryBasedOrFixedPriceFilter) + "&";
        if (salaryOrStaffingRateFilter === null)
            throw new Error("The parameter 'salaryOrStaffingRateFilter' cannot be null.");
        else if (salaryOrStaffingRateFilter !== undefined)
            url_ += "SalaryOrStaffingRateFilter=" + encodeURIComponent("" + salaryOrStaffingRateFilter) + "&";
        if (referralPointsFilter === null)
            throw new Error("The parameter 'referralPointsFilter' cannot be null.");
        else if (referralPointsFilter !== undefined)
            url_ += "ReferralPointsFilter=" + encodeURIComponent("" + referralPointsFilter) + "&";
        if (templateFilter === null)
            throw new Error("The parameter 'templateFilter' cannot be null.");
        else if (templateFilter !== undefined)
            url_ += "TemplateFilter=" + encodeURIComponent("" + templateFilter) + "&";
        if (maxNumberOfJobsFilter === null)
            throw new Error("The parameter 'maxNumberOfJobsFilter' cannot be null.");
        else if (maxNumberOfJobsFilter !== undefined)
            url_ += "MaxNumberOfJobsFilter=" + encodeURIComponent("" + maxNumberOfJobsFilter) + "&";
        if (minNumberOfJobsFilter === null)
            throw new Error("The parameter 'minNumberOfJobsFilter' cannot be null.");
        else if (minNumberOfJobsFilter !== undefined)
            url_ += "MinNumberOfJobsFilter=" + encodeURIComponent("" + minNumberOfJobsFilter) + "&";
        if (minimumExperienceFilter === null)
            throw new Error("The parameter 'minimumExperienceFilter' cannot be null.");
        else if (minimumExperienceFilter !== undefined)
            url_ += "MinimumExperienceFilter=" + encodeURIComponent("" + minimumExperienceFilter) + "&";
        if (maximumExperienceFilter === null)
            throw new Error("The parameter 'maximumExperienceFilter' cannot be null.");
        else if (maximumExperienceFilter !== undefined)
            url_ += "MaximumExperienceFilter=" + encodeURIComponent("" + maximumExperienceFilter) + "&";
        if (jobDescriptionFilter === null)
            throw new Error("The parameter 'jobDescriptionFilter' cannot be null.");
        else if (jobDescriptionFilter !== undefined)
            url_ += "JobDescriptionFilter=" + encodeURIComponent("" + jobDescriptionFilter) + "&";
        if (jobLocationFullAddressFilter === null)
            throw new Error("The parameter 'jobLocationFullAddressFilter' cannot be null.");
        else if (jobLocationFullAddressFilter !== undefined)
            url_ += "JobLocationFullAddressFilter=" + encodeURIComponent("" + jobLocationFullAddressFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (maxLatitudeFilter === null)
            throw new Error("The parameter 'maxLatitudeFilter' cannot be null.");
        else if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&";
        if (minLatitudeFilter === null)
            throw new Error("The parameter 'minLatitudeFilter' cannot be null.");
        else if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&";
        if (maxLongitudeFilter === null)
            throw new Error("The parameter 'maxLongitudeFilter' cannot be null.");
        else if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&";
        if (minLongitudeFilter === null)
            throw new Error("The parameter 'minLongitudeFilter' cannot be null.");
        else if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&";
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toString() : "") + "&";
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toString() : "") + "&";
        if (maxHireByDateFilter === null)
            throw new Error("The parameter 'maxHireByDateFilter' cannot be null.");
        else if (maxHireByDateFilter !== undefined)
            url_ += "MaxHireByDateFilter=" + encodeURIComponent(maxHireByDateFilter ? "" + maxHireByDateFilter.toString() : "") + "&";
        if (minHireByDateFilter === null)
            throw new Error("The parameter 'minHireByDateFilter' cannot be null.");
        else if (minHireByDateFilter !== undefined)
            url_ += "MinHireByDateFilter=" + encodeURIComponent(minHireByDateFilter ? "" + minHireByDateFilter.toString() : "") + "&";
        if (maxPublishDateFilter === null)
            throw new Error("The parameter 'maxPublishDateFilter' cannot be null.");
        else if (maxPublishDateFilter !== undefined)
            url_ += "MaxPublishDateFilter=" + encodeURIComponent(maxPublishDateFilter ? "" + maxPublishDateFilter.toString() : "") + "&";
        if (minPublishDateFilter === null)
            throw new Error("The parameter 'minPublishDateFilter' cannot be null.");
        else if (minPublishDateFilter !== undefined)
            url_ += "MinPublishDateFilter=" + encodeURIComponent(minPublishDateFilter ? "" + minPublishDateFilter.toString() : "") + "&";
        if (maxExpirationDateFilter === null)
            throw new Error("The parameter 'maxExpirationDateFilter' cannot be null.");
        else if (maxExpirationDateFilter !== undefined)
            url_ += "MaxExpirationDateFilter=" + encodeURIComponent(maxExpirationDateFilter ? "" + maxExpirationDateFilter.toString() : "") + "&";
        if (minExpirationDateFilter === null)
            throw new Error("The parameter 'minExpirationDateFilter' cannot be null.");
        else if (minExpirationDateFilter !== undefined)
            url_ += "MinExpirationDateFilter=" + encodeURIComponent(minExpirationDateFilter ? "" + minExpirationDateFilter.toString() : "") + "&";
        if (internalJobDescriptionFilter === null)
            throw new Error("The parameter 'internalJobDescriptionFilter' cannot be null.");
        else if (internalJobDescriptionFilter !== undefined)
            url_ += "InternalJobDescriptionFilter=" + encodeURIComponent("" + internalJobDescriptionFilter) + "&";
        if (cityLocationFilter === null)
            throw new Error("The parameter 'cityLocationFilter' cannot be null.");
        else if (cityLocationFilter !== undefined)
            url_ += "CityLocationFilter=" + encodeURIComponent("" + cityLocationFilter) + "&";
        if (publishedFilter === null)
            throw new Error("The parameter 'publishedFilter' cannot be null.");
        else if (publishedFilter !== undefined)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (productCategoryNameFilter === null)
            throw new Error("The parameter 'productCategoryNameFilter' cannot be null.");
        else if (productCategoryNameFilter !== undefined)
            url_ += "ProductCategoryNameFilter=" + encodeURIComponent("" + productCategoryNameFilter) + "&";
        if (currencyNameFilter === null)
            throw new Error("The parameter 'currencyNameFilter' cannot be null.");
        else if (currencyNameFilter !== undefined)
            url_ += "CurrencyNameFilter=" + encodeURIComponent("" + currencyNameFilter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (cityNameFilter === null)
            throw new Error("The parameter 'cityNameFilter' cannot be null.");
        else if (cityNameFilter !== undefined)
            url_ += "CityNameFilter=" + encodeURIComponent("" + cityNameFilter) + "&";
        if (jobStatusTypeNameFilter === null)
            throw new Error("The parameter 'jobStatusTypeNameFilter' cannot be null.");
        else if (jobStatusTypeNameFilter !== undefined)
            url_ += "JobStatusTypeNameFilter=" + encodeURIComponent("" + jobStatusTypeNameFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetJobsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobMasterTagCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAllMasterTagCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobMasterTagCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobMasterTagCategoryLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobMasterTagCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobMasterTagCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobProductCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAllProductCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobProductCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobProductCategoryLookupTableDto>;
        }));
    }

    protected processGetAllProductCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobProductCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobProductCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCurrencyForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobCurrencyLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAllCurrencyForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencyForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobCurrencyLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobCurrencyLookupTableDto>;
        }));
    }

    protected processGetAllCurrencyForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobCurrencyLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobCurrencyLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCountryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobCountryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAllCountryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobCountryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobCountryLookupTableDto>;
        }));
    }

    protected processGetAllCountryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobCountryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobCountryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStateForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobStateLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAllStateForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStateForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStateForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobStateLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobStateLookupTableDto>;
        }));
    }

    protected processGetAllStateForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobStateLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobStateLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCityForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobCityLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAllCityForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCityForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCityForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobCityLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobCityLookupTableDto>;
        }));
    }

    protected processGetAllCityForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobCityLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobCityLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllJobStatusTypeForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobJobStatusTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAllJobStatusTypeForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobStatusTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobStatusTypeForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobJobStatusTypeLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobJobStatusTypeLookupTableDto>;
        }));
    }

    protected processGetAllJobStatusTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobJobStatusTypeLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobJobStatusTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Jobs/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobStatusTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetJobStatusTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/JobStatusTypes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetJobStatusTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetJobStatusTypeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetJobStatusTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetJobStatusTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getJobStatusTypeForView(id: number | undefined): Observable<GetJobStatusTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/JobStatusTypes/GetJobStatusTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobStatusTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobStatusTypeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJobStatusTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJobStatusTypeForViewDto>;
        }));
    }

    protected processGetJobStatusTypeForView(response: HttpResponseBase): Observable<GetJobStatusTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJobStatusTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getJobStatusTypeForEdit(id: number | undefined): Observable<GetJobStatusTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/JobStatusTypes/GetJobStatusTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobStatusTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobStatusTypeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJobStatusTypeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJobStatusTypeForEditOutput>;
        }));
    }

    protected processGetJobStatusTypeForEdit(response: HttpResponseBase): Observable<GetJobStatusTypeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJobStatusTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditJobStatusTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobStatusTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobStatusTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @return Success
     */
    getJobStatusTypesToExcel(filter: string | undefined, nameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/JobStatusTypes/GetJobStatusTypesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobStatusTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobStatusTypesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetJobStatusTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, jobTitleFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetJobTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTags/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (jobTitleFilter === null)
            throw new Error("The parameter 'jobTitleFilter' cannot be null.");
        else if (jobTitleFilter !== undefined)
            url_ += "JobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetJobTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetJobTagForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetJobTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetJobTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getJobTagForView(id: number | undefined): Observable<GetJobTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTags/GetJobTagForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobTagForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobTagForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJobTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJobTagForViewDto>;
        }));
    }

    protected processGetJobTagForView(response: HttpResponseBase): Observable<GetJobTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJobTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getJobTagForEdit(id: number | undefined): Observable<GetJobTagForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/JobTags/GetJobTagForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobTagForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobTagForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJobTagForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJobTagForEditOutput>;
        }));
    }

    protected processGetJobTagForEdit(response: HttpResponseBase): Observable<GetJobTagForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJobTagForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditJobTagDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobTags/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobTags/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @return Success
     */
    getJobTagsToExcel(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, jobTitleFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTags/GetJobTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (jobTitleFilter === null)
            throw new Error("The parameter 'jobTitleFilter' cannot be null.");
        else if (jobTitleFilter !== undefined)
            url_ += "JobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobTagsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetJobTagsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllJobForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobTagJobLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTags/GetAllJobForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobTagJobLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobTagJobLookupTableDto>;
        }));
    }

    protected processGetAllJobForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobTagJobLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobTagJobLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobTagMasterTagCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTags/GetAllMasterTagCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobTagMasterTagCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobTagMasterTagCategoryLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobTagMasterTagCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobTagMasterTagCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfJobTagMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTags/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfJobTagMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfJobTagMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfJobTagMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfJobTagMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguagesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguagesOutput>;
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguageForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguageForEditOutput>;
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined, sourceName: string, baseLanguageName: string | undefined, targetLanguageName: string, targetValueFilter: string | undefined, filterText: string | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&";
        if (baseLanguageName === null)
            throw new Error("The parameter 'baseLanguageName' cannot be null.");
        else if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&";
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&";
        if (targetValueFilter === null)
            throw new Error("The parameter 'targetValueFilter' cannot be null.");
        else if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLanguageTextListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLanguageTextListDto>;
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MarketplaceCommissionTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param maxPercentageFilter (optional) 
     * @param minPercentageFilter (optional) 
     * @param maxFixedAmountFilter (optional) 
     * @param minFixedAmountFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, maxPercentageFilter: number | undefined, minPercentageFilter: number | undefined, maxFixedAmountFilter: number | undefined, minFixedAmountFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMarketplaceCommissionTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MarketplaceCommissionTypes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (maxPercentageFilter === null)
            throw new Error("The parameter 'maxPercentageFilter' cannot be null.");
        else if (maxPercentageFilter !== undefined)
            url_ += "MaxPercentageFilter=" + encodeURIComponent("" + maxPercentageFilter) + "&";
        if (minPercentageFilter === null)
            throw new Error("The parameter 'minPercentageFilter' cannot be null.");
        else if (minPercentageFilter !== undefined)
            url_ += "MinPercentageFilter=" + encodeURIComponent("" + minPercentageFilter) + "&";
        if (maxFixedAmountFilter === null)
            throw new Error("The parameter 'maxFixedAmountFilter' cannot be null.");
        else if (maxFixedAmountFilter !== undefined)
            url_ += "MaxFixedAmountFilter=" + encodeURIComponent("" + maxFixedAmountFilter) + "&";
        if (minFixedAmountFilter === null)
            throw new Error("The parameter 'minFixedAmountFilter' cannot be null.");
        else if (minFixedAmountFilter !== undefined)
            url_ += "MinFixedAmountFilter=" + encodeURIComponent("" + minFixedAmountFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMarketplaceCommissionTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMarketplaceCommissionTypeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMarketplaceCommissionTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMarketplaceCommissionTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMarketplaceCommissionTypeForView(id: number | undefined): Observable<GetMarketplaceCommissionTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MarketplaceCommissionTypes/GetMarketplaceCommissionTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMarketplaceCommissionTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMarketplaceCommissionTypeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMarketplaceCommissionTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMarketplaceCommissionTypeForViewDto>;
        }));
    }

    protected processGetMarketplaceCommissionTypeForView(response: HttpResponseBase): Observable<GetMarketplaceCommissionTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMarketplaceCommissionTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMarketplaceCommissionTypeForEdit(id: number | undefined): Observable<GetMarketplaceCommissionTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MarketplaceCommissionTypes/GetMarketplaceCommissionTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMarketplaceCommissionTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMarketplaceCommissionTypeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMarketplaceCommissionTypeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMarketplaceCommissionTypeForEditOutput>;
        }));
    }

    protected processGetMarketplaceCommissionTypeForEdit(response: HttpResponseBase): Observable<GetMarketplaceCommissionTypeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMarketplaceCommissionTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMarketplaceCommissionTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MarketplaceCommissionTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MarketplaceCommissionTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param maxPercentageFilter (optional) 
     * @param minPercentageFilter (optional) 
     * @param maxFixedAmountFilter (optional) 
     * @param minFixedAmountFilter (optional) 
     * @return Success
     */
    getMarketplaceCommissionTypesToExcel(filter: string | undefined, nameFilter: string | undefined, maxPercentageFilter: number | undefined, minPercentageFilter: number | undefined, maxFixedAmountFilter: number | undefined, minFixedAmountFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MarketplaceCommissionTypes/GetMarketplaceCommissionTypesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (maxPercentageFilter === null)
            throw new Error("The parameter 'maxPercentageFilter' cannot be null.");
        else if (maxPercentageFilter !== undefined)
            url_ += "MaxPercentageFilter=" + encodeURIComponent("" + maxPercentageFilter) + "&";
        if (minPercentageFilter === null)
            throw new Error("The parameter 'minPercentageFilter' cannot be null.");
        else if (minPercentageFilter !== undefined)
            url_ += "MinPercentageFilter=" + encodeURIComponent("" + minPercentageFilter) + "&";
        if (maxFixedAmountFilter === null)
            throw new Error("The parameter 'maxFixedAmountFilter' cannot be null.");
        else if (maxFixedAmountFilter !== undefined)
            url_ += "MaxFixedAmountFilter=" + encodeURIComponent("" + maxFixedAmountFilter) + "&";
        if (minFixedAmountFilter === null)
            throw new Error("The parameter 'minFixedAmountFilter' cannot be null.");
        else if (minFixedAmountFilter !== undefined)
            url_ += "MinFixedAmountFilter=" + encodeURIComponent("" + minFixedAmountFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMarketplaceCommissionTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMarketplaceCommissionTypesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetMarketplaceCommissionTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MasterTagCategoriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, mediaLibraryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMasterTagCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterTagCategories/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMasterTagCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMasterTagCategoryForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMasterTagCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMasterTagCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMasterTagCategoryForView(id: number | undefined): Observable<GetMasterTagCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterTagCategories/GetMasterTagCategoryForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMasterTagCategoryForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMasterTagCategoryForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMasterTagCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMasterTagCategoryForViewDto>;
        }));
    }

    protected processGetMasterTagCategoryForView(response: HttpResponseBase): Observable<GetMasterTagCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMasterTagCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMasterTagCategoryForEdit(id: number | undefined): Observable<GetMasterTagCategoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MasterTagCategories/GetMasterTagCategoryForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMasterTagCategoryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMasterTagCategoryForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMasterTagCategoryForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMasterTagCategoryForEditOutput>;
        }));
    }

    protected processGetMasterTagCategoryForEdit(response: HttpResponseBase): Observable<GetMasterTagCategoryForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMasterTagCategoryForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMasterTagCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MasterTagCategories/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MasterTagCategories/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @return Success
     */
    getMasterTagCategoriesToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, mediaLibraryNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterTagCategories/GetMasterTagCategoriesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMasterTagCategoriesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMasterTagCategoriesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetMasterTagCategoriesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMediaLibraryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterTagCategories/GetAllMediaLibraryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMediaLibraryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMediaLibraryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto>;
        }));
    }

    protected processGetAllMediaLibraryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MasterTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param synonymsFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, synonymsFilter: string | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, masterTagCategoryNameFilter: string | undefined, mediaLibraryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMasterTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterTags/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (synonymsFilter === null)
            throw new Error("The parameter 'synonymsFilter' cannot be null.");
        else if (synonymsFilter !== undefined)
            url_ += "SynonymsFilter=" + encodeURIComponent("" + synonymsFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMasterTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMasterTagForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMasterTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMasterTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMasterTagForView(id: number | undefined): Observable<GetMasterTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterTags/GetMasterTagForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMasterTagForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMasterTagForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMasterTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMasterTagForViewDto>;
        }));
    }

    protected processGetMasterTagForView(response: HttpResponseBase): Observable<GetMasterTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMasterTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMasterTagForEdit(id: number | undefined): Observable<GetMasterTagForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MasterTags/GetMasterTagForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMasterTagForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMasterTagForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMasterTagForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMasterTagForEditOutput>;
        }));
    }

    protected processGetMasterTagForEdit(response: HttpResponseBase): Observable<GetMasterTagForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMasterTagForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMasterTagDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MasterTags/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MasterTags/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param synonymsFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @return Success
     */
    getMasterTagsToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, synonymsFilter: string | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, masterTagCategoryNameFilter: string | undefined, mediaLibraryNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterTags/GetMasterTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (synonymsFilter === null)
            throw new Error("The parameter 'synonymsFilter' cannot be null.");
        else if (synonymsFilter !== undefined)
            url_ += "SynonymsFilter=" + encodeURIComponent("" + synonymsFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMasterTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMasterTagsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetMasterTagsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllMasterTagCategoryForTableDropdown(): Observable<MasterTagMasterTagCategoryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/MasterTags/GetAllMasterTagCategoryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MasterTagMasterTagCategoryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MasterTagMasterTagCategoryLookupTableDto[]>;
        }));
    }

    protected processGetAllMasterTagCategoryForTableDropdown(response: HttpResponseBase): Observable<MasterTagMasterTagCategoryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MasterTagMasterTagCategoryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMediaLibraryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMasterTagMediaLibraryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MasterTags/GetAllMediaLibraryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMediaLibraryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMediaLibraryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMasterTagMediaLibraryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMasterTagMediaLibraryLookupTableDto>;
        }));
    }

    protected processGetAllMediaLibraryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMasterTagMediaLibraryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMasterTagMediaLibraryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MeasurementUnitsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMeasurementUnitForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MeasurementUnits/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMeasurementUnitForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMeasurementUnitForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMeasurementUnitForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMeasurementUnitForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMeasurementUnitForView(id: number | undefined): Observable<GetMeasurementUnitForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MeasurementUnits/GetMeasurementUnitForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeasurementUnitForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeasurementUnitForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMeasurementUnitForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMeasurementUnitForViewDto>;
        }));
    }

    protected processGetMeasurementUnitForView(response: HttpResponseBase): Observable<GetMeasurementUnitForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMeasurementUnitForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMeasurementUnitForEdit(id: number | undefined): Observable<GetMeasurementUnitForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MeasurementUnits/GetMeasurementUnitForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeasurementUnitForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeasurementUnitForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMeasurementUnitForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMeasurementUnitForEditOutput>;
        }));
    }

    protected processGetMeasurementUnitForEdit(response: HttpResponseBase): Observable<GetMeasurementUnitForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMeasurementUnitForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMeasurementUnitDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MeasurementUnits/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MeasurementUnits/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @return Success
     */
    getMeasurementUnitsToExcel(filter: string | undefined, nameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MeasurementUnits/GetMeasurementUnitsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMeasurementUnitsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMeasurementUnitsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetMeasurementUnitsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MediaLibrariesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sizeFilter (optional) 
     * @param fileExtensionFilter (optional) 
     * @param dimensionFilter (optional) 
     * @param videoLinkFilter (optional) 
     * @param seoTagFilter (optional) 
     * @param altTagFilter (optional) 
     * @param virtualPathFilter (optional) 
     * @param binaryObjectIdFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, sizeFilter: string | undefined, fileExtensionFilter: string | undefined, dimensionFilter: string | undefined, videoLinkFilter: string | undefined, seoTagFilter: string | undefined, altTagFilter: string | undefined, virtualPathFilter: string | undefined, binaryObjectIdFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMediaLibraryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MediaLibraries/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sizeFilter === null)
            throw new Error("The parameter 'sizeFilter' cannot be null.");
        else if (sizeFilter !== undefined)
            url_ += "SizeFilter=" + encodeURIComponent("" + sizeFilter) + "&";
        if (fileExtensionFilter === null)
            throw new Error("The parameter 'fileExtensionFilter' cannot be null.");
        else if (fileExtensionFilter !== undefined)
            url_ += "FileExtensionFilter=" + encodeURIComponent("" + fileExtensionFilter) + "&";
        if (dimensionFilter === null)
            throw new Error("The parameter 'dimensionFilter' cannot be null.");
        else if (dimensionFilter !== undefined)
            url_ += "DimensionFilter=" + encodeURIComponent("" + dimensionFilter) + "&";
        if (videoLinkFilter === null)
            throw new Error("The parameter 'videoLinkFilter' cannot be null.");
        else if (videoLinkFilter !== undefined)
            url_ += "VideoLinkFilter=" + encodeURIComponent("" + videoLinkFilter) + "&";
        if (seoTagFilter === null)
            throw new Error("The parameter 'seoTagFilter' cannot be null.");
        else if (seoTagFilter !== undefined)
            url_ += "SeoTagFilter=" + encodeURIComponent("" + seoTagFilter) + "&";
        if (altTagFilter === null)
            throw new Error("The parameter 'altTagFilter' cannot be null.");
        else if (altTagFilter !== undefined)
            url_ += "AltTagFilter=" + encodeURIComponent("" + altTagFilter) + "&";
        if (virtualPathFilter === null)
            throw new Error("The parameter 'virtualPathFilter' cannot be null.");
        else if (virtualPathFilter !== undefined)
            url_ += "VirtualPathFilter=" + encodeURIComponent("" + virtualPathFilter) + "&";
        if (binaryObjectIdFilter === null)
            throw new Error("The parameter 'binaryObjectIdFilter' cannot be null.");
        else if (binaryObjectIdFilter !== undefined)
            url_ += "BinaryObjectIdFilter=" + encodeURIComponent("" + binaryObjectIdFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMediaLibraryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMediaLibraryForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMediaLibraryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMediaLibraryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMediaLibraryForView(id: number | undefined): Observable<GetMediaLibraryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MediaLibraries/GetMediaLibraryForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMediaLibraryForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMediaLibraryForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMediaLibraryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMediaLibraryForViewDto>;
        }));
    }

    protected processGetMediaLibraryForView(response: HttpResponseBase): Observable<GetMediaLibraryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMediaLibraryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMediaLibraryForEdit(id: number | undefined): Observable<GetMediaLibraryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MediaLibraries/GetMediaLibraryForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMediaLibraryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMediaLibraryForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMediaLibraryForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMediaLibraryForEditOutput>;
        }));
    }

    protected processGetMediaLibraryForEdit(response: HttpResponseBase): Observable<GetMediaLibraryForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMediaLibraryForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMediaLibraryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MediaLibraries/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MediaLibraries/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sizeFilter (optional) 
     * @param fileExtensionFilter (optional) 
     * @param dimensionFilter (optional) 
     * @param videoLinkFilter (optional) 
     * @param seoTagFilter (optional) 
     * @param altTagFilter (optional) 
     * @param virtualPathFilter (optional) 
     * @param binaryObjectIdFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @return Success
     */
    getMediaLibrariesToExcel(filter: string | undefined, nameFilter: string | undefined, sizeFilter: string | undefined, fileExtensionFilter: string | undefined, dimensionFilter: string | undefined, videoLinkFilter: string | undefined, seoTagFilter: string | undefined, altTagFilter: string | undefined, virtualPathFilter: string | undefined, binaryObjectIdFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MediaLibraries/GetMediaLibrariesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sizeFilter === null)
            throw new Error("The parameter 'sizeFilter' cannot be null.");
        else if (sizeFilter !== undefined)
            url_ += "SizeFilter=" + encodeURIComponent("" + sizeFilter) + "&";
        if (fileExtensionFilter === null)
            throw new Error("The parameter 'fileExtensionFilter' cannot be null.");
        else if (fileExtensionFilter !== undefined)
            url_ += "FileExtensionFilter=" + encodeURIComponent("" + fileExtensionFilter) + "&";
        if (dimensionFilter === null)
            throw new Error("The parameter 'dimensionFilter' cannot be null.");
        else if (dimensionFilter !== undefined)
            url_ += "DimensionFilter=" + encodeURIComponent("" + dimensionFilter) + "&";
        if (videoLinkFilter === null)
            throw new Error("The parameter 'videoLinkFilter' cannot be null.");
        else if (videoLinkFilter !== undefined)
            url_ += "VideoLinkFilter=" + encodeURIComponent("" + videoLinkFilter) + "&";
        if (seoTagFilter === null)
            throw new Error("The parameter 'seoTagFilter' cannot be null.");
        else if (seoTagFilter !== undefined)
            url_ += "SeoTagFilter=" + encodeURIComponent("" + seoTagFilter) + "&";
        if (altTagFilter === null)
            throw new Error("The parameter 'altTagFilter' cannot be null.");
        else if (altTagFilter !== undefined)
            url_ += "AltTagFilter=" + encodeURIComponent("" + altTagFilter) + "&";
        if (virtualPathFilter === null)
            throw new Error("The parameter 'virtualPathFilter' cannot be null.");
        else if (virtualPathFilter !== undefined)
            url_ += "VirtualPathFilter=" + encodeURIComponent("" + virtualPathFilter) + "&";
        if (binaryObjectIdFilter === null)
            throw new Error("The parameter 'binaryObjectIdFilter' cannot be null.");
        else if (binaryObjectIdFilter !== undefined)
            url_ += "BinaryObjectIdFilter=" + encodeURIComponent("" + binaryObjectIdFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMediaLibrariesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMediaLibrariesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetMediaLibrariesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MediaLibraries/GetAllMasterTagCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMediaLibraryMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MediaLibraries/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMediaLibraryMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMediaLibraryMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMediaLibraryMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMediaLibraryMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MembershipTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMembershipTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MembershipTypes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMembershipTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMembershipTypeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMembershipTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMembershipTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMembershipTypeForView(id: number | undefined): Observable<GetMembershipTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MembershipTypes/GetMembershipTypeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMembershipTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMembershipTypeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMembershipTypeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMembershipTypeForViewDto>;
        }));
    }

    protected processGetMembershipTypeForView(response: HttpResponseBase): Observable<GetMembershipTypeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMembershipTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMembershipTypeForEdit(id: number | undefined): Observable<GetMembershipTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MembershipTypes/GetMembershipTypeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMembershipTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMembershipTypeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMembershipTypeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMembershipTypeForEditOutput>;
        }));
    }

    protected processGetMembershipTypeForEdit(response: HttpResponseBase): Observable<GetMembershipTypeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMembershipTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMembershipTypeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MembershipTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MembershipTypes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @return Success
     */
    getMembershipTypesToExcel(filter: string | undefined, nameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MembershipTypes/GetMembershipTypesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMembershipTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMembershipTypesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetMembershipTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | undefined, startDate: DateTime | undefined, endDate: DateTime | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationsOutput>;
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    shouldUserUpdateApp(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Notification/ShouldUserUpdateApp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShouldUserUpdateApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShouldUserUpdateApp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processShouldUserUpdateApp(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    setAllAvailableVersionNotificationAsRead(): Observable<SetNotificationAsReadOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllAvailableVersionNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllAvailableVersionNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllAvailableVersionNotificationAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SetNotificationAsReadOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SetNotificationAsReadOutput>;
        }));
    }

    protected processSetAllAvailableVersionNotificationAsRead(response: HttpResponseBase): Observable<SetNotificationAsReadOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetNotificationAsReadOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<SetNotificationAsReadOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SetNotificationAsReadOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SetNotificationAsReadOutput>;
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<SetNotificationAsReadOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetNotificationAsReadOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationSettingsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationSettingsOutput>;
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | undefined, startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteAllUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMassNotificationUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetAllUserForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMassNotificationUserLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMassNotificationUserLookupTableDto>;
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMassNotificationUserLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMassNotificationUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllOrganizationUnitForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetAllOrganizationUnitForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizationUnitForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizationUnitForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto>;
        }));
    }

    protected processGetAllOrganizationUnitForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMassNotification(body: CreateMassNotificationInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/CreateMassNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMassNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMassNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateMassNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    createNewVersionReleasedNotification(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/CreateNewVersionReleasedNotification";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNewVersionReleasedNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNewVersionReleasedNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateNewVersionReleasedNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllNotifiers(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetAllNotifiers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotifiers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotifiers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAllNotifiers(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getNotificationsPublishedByUser(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetPublishedNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationsPublishedByUser?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationsPublishedByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationsPublishedByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPublishedNotificationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPublishedNotificationsOutput>;
        }));
    }

    protected processGetNotificationsPublishedByUser(response: HttpResponseBase): Observable<GetPublishedNotificationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPublishedNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfOrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfOrganizationUnitDto>;
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfOrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrganizationUnitUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrganizationUnitUserListDto>;
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrganizationUnitRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrganizationUnitRoleListDto>;
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentInfoDto>;
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: CreatePaymentDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelPayment(body: CancelPaymentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSubscriptionPaymentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSubscriptionPaymentListDto>;
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled === null)
            throw new Error("The parameter 'recurringPaymentsEnabled' cannot be null.");
        else if (recurringPaymentsEnabled !== undefined)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentGatewayModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentGatewayModel[]>;
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    switchBetweenFreeEditions(upgradeEditionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/SwitchBetweenFreeEditions?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchBetweenFreeEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchBetweenFreeEditions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSwitchBetweenFreeEditions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    upgradeSubscriptionCostsLessThenMinAmount(editionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSubscriptionCostsLessThenMinAmount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpgradeSubscriptionCostsLessThenMinAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    hasAnyPayment(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Payment/HasAnyPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHasAnyPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasAnyPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processHasAnyPayment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalOrderId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | undefined, paypalOrderId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        if (paypalOrderId === null)
            throw new Error("The parameter 'paypalOrderId' cannot be null.");
        else if (paypalOrderId !== undefined)
            url_ += "paypalOrderId=" + encodeURIComponent("" + paypalOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayPalConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayPalConfigurationDto>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayPalConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfFlatPermissionWithLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfFlatPermissionWithLevelDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductCategoriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param hasParentCategoryFilter (optional) 
     * @param maxParentCategoryIdFilter (optional) 
     * @param minParentCategoryIdFilter (optional) 
     * @param urlFilter (optional) 
     * @param metaTitleFilter (optional) 
     * @param metaKeywordsFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param productOrServiceFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, hasParentCategoryFilter: number | undefined, maxParentCategoryIdFilter: number | undefined, minParentCategoryIdFilter: number | undefined, urlFilter: string | undefined, metaTitleFilter: string | undefined, metaKeywordsFilter: string | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, productOrServiceFilter: number | undefined, mediaLibraryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetProductCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (hasParentCategoryFilter === null)
            throw new Error("The parameter 'hasParentCategoryFilter' cannot be null.");
        else if (hasParentCategoryFilter !== undefined)
            url_ += "HasParentCategoryFilter=" + encodeURIComponent("" + hasParentCategoryFilter) + "&";
        if (maxParentCategoryIdFilter === null)
            throw new Error("The parameter 'maxParentCategoryIdFilter' cannot be null.");
        else if (maxParentCategoryIdFilter !== undefined)
            url_ += "MaxParentCategoryIdFilter=" + encodeURIComponent("" + maxParentCategoryIdFilter) + "&";
        if (minParentCategoryIdFilter === null)
            throw new Error("The parameter 'minParentCategoryIdFilter' cannot be null.");
        else if (minParentCategoryIdFilter !== undefined)
            url_ += "MinParentCategoryIdFilter=" + encodeURIComponent("" + minParentCategoryIdFilter) + "&";
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&";
        if (metaTitleFilter === null)
            throw new Error("The parameter 'metaTitleFilter' cannot be null.");
        else if (metaTitleFilter !== undefined)
            url_ += "MetaTitleFilter=" + encodeURIComponent("" + metaTitleFilter) + "&";
        if (metaKeywordsFilter === null)
            throw new Error("The parameter 'metaKeywordsFilter' cannot be null.");
        else if (metaKeywordsFilter !== undefined)
            url_ += "MetaKeywordsFilter=" + encodeURIComponent("" + metaKeywordsFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (productOrServiceFilter === null)
            throw new Error("The parameter 'productOrServiceFilter' cannot be null.");
        else if (productOrServiceFilter !== undefined)
            url_ += "ProductOrServiceFilter=" + encodeURIComponent("" + productOrServiceFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetProductCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetProductCategoryForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetProductCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProductCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductCategoryForView(id: number | undefined): Observable<GetProductCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/GetProductCategoryForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoryForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoryForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductCategoryForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductCategoryForViewDto>;
        }));
    }

    protected processGetProductCategoryForView(response: HttpResponseBase): Observable<GetProductCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductCategoryForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductCategoryForEdit(id: number | undefined): Observable<GetProductCategoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/GetProductCategoryForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoryForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductCategoryForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductCategoryForEditOutput>;
        }));
    }

    protected processGetProductCategoryForEdit(response: HttpResponseBase): Observable<GetProductCategoryForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductCategoryForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProductCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param hasParentCategoryFilter (optional) 
     * @param maxParentCategoryIdFilter (optional) 
     * @param minParentCategoryIdFilter (optional) 
     * @param urlFilter (optional) 
     * @param metaTitleFilter (optional) 
     * @param metaKeywordsFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param productOrServiceFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @return Success
     */
    getProductCategoriesToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, hasParentCategoryFilter: number | undefined, maxParentCategoryIdFilter: number | undefined, minParentCategoryIdFilter: number | undefined, urlFilter: string | undefined, metaTitleFilter: string | undefined, metaKeywordsFilter: string | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, productOrServiceFilter: number | undefined, mediaLibraryNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/GetProductCategoriesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (hasParentCategoryFilter === null)
            throw new Error("The parameter 'hasParentCategoryFilter' cannot be null.");
        else if (hasParentCategoryFilter !== undefined)
            url_ += "HasParentCategoryFilter=" + encodeURIComponent("" + hasParentCategoryFilter) + "&";
        if (maxParentCategoryIdFilter === null)
            throw new Error("The parameter 'maxParentCategoryIdFilter' cannot be null.");
        else if (maxParentCategoryIdFilter !== undefined)
            url_ += "MaxParentCategoryIdFilter=" + encodeURIComponent("" + maxParentCategoryIdFilter) + "&";
        if (minParentCategoryIdFilter === null)
            throw new Error("The parameter 'minParentCategoryIdFilter' cannot be null.");
        else if (minParentCategoryIdFilter !== undefined)
            url_ += "MinParentCategoryIdFilter=" + encodeURIComponent("" + minParentCategoryIdFilter) + "&";
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&";
        if (metaTitleFilter === null)
            throw new Error("The parameter 'metaTitleFilter' cannot be null.");
        else if (metaTitleFilter !== undefined)
            url_ += "MetaTitleFilter=" + encodeURIComponent("" + metaTitleFilter) + "&";
        if (metaKeywordsFilter === null)
            throw new Error("The parameter 'metaKeywordsFilter' cannot be null.");
        else if (metaKeywordsFilter !== undefined)
            url_ += "MetaKeywordsFilter=" + encodeURIComponent("" + metaKeywordsFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (productOrServiceFilter === null)
            throw new Error("The parameter 'productOrServiceFilter' cannot be null.");
        else if (productOrServiceFilter !== undefined)
            url_ += "ProductOrServiceFilter=" + encodeURIComponent("" + productOrServiceFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategoriesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategoriesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetProductCategoriesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMediaLibraryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductCategoryMediaLibraryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategories/GetAllMediaLibraryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMediaLibraryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMediaLibraryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProductCategoryMediaLibraryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProductCategoryMediaLibraryLookupTableDto>;
        }));
    }

    protected processGetAllMediaLibraryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductCategoryMediaLibraryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductCategoryMediaLibraryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param shortDescriptionFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param skuFilter (optional) 
     * @param urlFilter (optional) 
     * @param seoTitleFilter (optional) 
     * @param metaKeywordsFilter (optional) 
     * @param metaDescriptionFilter (optional) 
     * @param maxRegularPriceFilter (optional) 
     * @param minRegularPriceFilter (optional) 
     * @param maxSalePriceFilter (optional) 
     * @param minSalePriceFilter (optional) 
     * @param maxPriceDiscountPercentageFilter (optional) 
     * @param minPriceDiscountPercentageFilter (optional) 
     * @param callForPriceFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxMeasurementAmountFilter (optional) 
     * @param minMeasurementAmountFilter (optional) 
     * @param isTaxExemptFilter (optional) 
     * @param maxStockQuantityFilter (optional) 
     * @param minStockQuantityFilter (optional) 
     * @param isDisplayStockQuantityFilter (optional) 
     * @param isPublishedFilter (optional) 
     * @param isPackageProductFilter (optional) 
     * @param internalNotesFilter (optional) 
     * @param isTemplateFilter (optional) 
     * @param maxPriceDiscountAmountFilter (optional) 
     * @param minPriceDiscountAmountFilter (optional) 
     * @param isServiceFilter (optional) 
     * @param isWholeSaleProductFilter (optional) 
     * @param productManufacturerSkuFilter (optional) 
     * @param byOrderOnlyFilter (optional) 
     * @param maxScoreFilter (optional) 
     * @param minScoreFilter (optional) 
     * @param productCategoryNameFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @param measurementUnitNameFilter (optional) 
     * @param currencyNameFilter (optional) 
     * @param ratingLikeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, shortDescriptionFilter: string | undefined, descriptionFilter: string | undefined, skuFilter: string | undefined, urlFilter: string | undefined, seoTitleFilter: string | undefined, metaKeywordsFilter: string | undefined, metaDescriptionFilter: string | undefined, maxRegularPriceFilter: number | undefined, minRegularPriceFilter: number | undefined, maxSalePriceFilter: number | undefined, minSalePriceFilter: number | undefined, maxPriceDiscountPercentageFilter: number | undefined, minPriceDiscountPercentageFilter: number | undefined, callForPriceFilter: number | undefined, maxUnitPriceFilter: number | undefined, minUnitPriceFilter: number | undefined, maxMeasurementAmountFilter: number | undefined, minMeasurementAmountFilter: number | undefined, isTaxExemptFilter: number | undefined, maxStockQuantityFilter: number | undefined, minStockQuantityFilter: number | undefined, isDisplayStockQuantityFilter: number | undefined, isPublishedFilter: number | undefined, isPackageProductFilter: number | undefined, internalNotesFilter: string | undefined, isTemplateFilter: number | undefined, maxPriceDiscountAmountFilter: number | undefined, minPriceDiscountAmountFilter: number | undefined, isServiceFilter: number | undefined, isWholeSaleProductFilter: number | undefined, productManufacturerSkuFilter: string | undefined, byOrderOnlyFilter: number | undefined, maxScoreFilter: number | undefined, minScoreFilter: number | undefined, productCategoryNameFilter: string | undefined, mediaLibraryNameFilter: string | undefined, measurementUnitNameFilter: string | undefined, currencyNameFilter: string | undefined, ratingLikeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetProductForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (shortDescriptionFilter === null)
            throw new Error("The parameter 'shortDescriptionFilter' cannot be null.");
        else if (shortDescriptionFilter !== undefined)
            url_ += "ShortDescriptionFilter=" + encodeURIComponent("" + shortDescriptionFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (skuFilter === null)
            throw new Error("The parameter 'skuFilter' cannot be null.");
        else if (skuFilter !== undefined)
            url_ += "SkuFilter=" + encodeURIComponent("" + skuFilter) + "&";
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&";
        if (seoTitleFilter === null)
            throw new Error("The parameter 'seoTitleFilter' cannot be null.");
        else if (seoTitleFilter !== undefined)
            url_ += "SeoTitleFilter=" + encodeURIComponent("" + seoTitleFilter) + "&";
        if (metaKeywordsFilter === null)
            throw new Error("The parameter 'metaKeywordsFilter' cannot be null.");
        else if (metaKeywordsFilter !== undefined)
            url_ += "MetaKeywordsFilter=" + encodeURIComponent("" + metaKeywordsFilter) + "&";
        if (metaDescriptionFilter === null)
            throw new Error("The parameter 'metaDescriptionFilter' cannot be null.");
        else if (metaDescriptionFilter !== undefined)
            url_ += "MetaDescriptionFilter=" + encodeURIComponent("" + metaDescriptionFilter) + "&";
        if (maxRegularPriceFilter === null)
            throw new Error("The parameter 'maxRegularPriceFilter' cannot be null.");
        else if (maxRegularPriceFilter !== undefined)
            url_ += "MaxRegularPriceFilter=" + encodeURIComponent("" + maxRegularPriceFilter) + "&";
        if (minRegularPriceFilter === null)
            throw new Error("The parameter 'minRegularPriceFilter' cannot be null.");
        else if (minRegularPriceFilter !== undefined)
            url_ += "MinRegularPriceFilter=" + encodeURIComponent("" + minRegularPriceFilter) + "&";
        if (maxSalePriceFilter === null)
            throw new Error("The parameter 'maxSalePriceFilter' cannot be null.");
        else if (maxSalePriceFilter !== undefined)
            url_ += "MaxSalePriceFilter=" + encodeURIComponent("" + maxSalePriceFilter) + "&";
        if (minSalePriceFilter === null)
            throw new Error("The parameter 'minSalePriceFilter' cannot be null.");
        else if (minSalePriceFilter !== undefined)
            url_ += "MinSalePriceFilter=" + encodeURIComponent("" + minSalePriceFilter) + "&";
        if (maxPriceDiscountPercentageFilter === null)
            throw new Error("The parameter 'maxPriceDiscountPercentageFilter' cannot be null.");
        else if (maxPriceDiscountPercentageFilter !== undefined)
            url_ += "MaxPriceDiscountPercentageFilter=" + encodeURIComponent("" + maxPriceDiscountPercentageFilter) + "&";
        if (minPriceDiscountPercentageFilter === null)
            throw new Error("The parameter 'minPriceDiscountPercentageFilter' cannot be null.");
        else if (minPriceDiscountPercentageFilter !== undefined)
            url_ += "MinPriceDiscountPercentageFilter=" + encodeURIComponent("" + minPriceDiscountPercentageFilter) + "&";
        if (callForPriceFilter === null)
            throw new Error("The parameter 'callForPriceFilter' cannot be null.");
        else if (callForPriceFilter !== undefined)
            url_ += "CallForPriceFilter=" + encodeURIComponent("" + callForPriceFilter) + "&";
        if (maxUnitPriceFilter === null)
            throw new Error("The parameter 'maxUnitPriceFilter' cannot be null.");
        else if (maxUnitPriceFilter !== undefined)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&";
        if (minUnitPriceFilter === null)
            throw new Error("The parameter 'minUnitPriceFilter' cannot be null.");
        else if (minUnitPriceFilter !== undefined)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&";
        if (maxMeasurementAmountFilter === null)
            throw new Error("The parameter 'maxMeasurementAmountFilter' cannot be null.");
        else if (maxMeasurementAmountFilter !== undefined)
            url_ += "MaxMeasurementAmountFilter=" + encodeURIComponent("" + maxMeasurementAmountFilter) + "&";
        if (minMeasurementAmountFilter === null)
            throw new Error("The parameter 'minMeasurementAmountFilter' cannot be null.");
        else if (minMeasurementAmountFilter !== undefined)
            url_ += "MinMeasurementAmountFilter=" + encodeURIComponent("" + minMeasurementAmountFilter) + "&";
        if (isTaxExemptFilter === null)
            throw new Error("The parameter 'isTaxExemptFilter' cannot be null.");
        else if (isTaxExemptFilter !== undefined)
            url_ += "IsTaxExemptFilter=" + encodeURIComponent("" + isTaxExemptFilter) + "&";
        if (maxStockQuantityFilter === null)
            throw new Error("The parameter 'maxStockQuantityFilter' cannot be null.");
        else if (maxStockQuantityFilter !== undefined)
            url_ += "MaxStockQuantityFilter=" + encodeURIComponent("" + maxStockQuantityFilter) + "&";
        if (minStockQuantityFilter === null)
            throw new Error("The parameter 'minStockQuantityFilter' cannot be null.");
        else if (minStockQuantityFilter !== undefined)
            url_ += "MinStockQuantityFilter=" + encodeURIComponent("" + minStockQuantityFilter) + "&";
        if (isDisplayStockQuantityFilter === null)
            throw new Error("The parameter 'isDisplayStockQuantityFilter' cannot be null.");
        else if (isDisplayStockQuantityFilter !== undefined)
            url_ += "IsDisplayStockQuantityFilter=" + encodeURIComponent("" + isDisplayStockQuantityFilter) + "&";
        if (isPublishedFilter === null)
            throw new Error("The parameter 'isPublishedFilter' cannot be null.");
        else if (isPublishedFilter !== undefined)
            url_ += "IsPublishedFilter=" + encodeURIComponent("" + isPublishedFilter) + "&";
        if (isPackageProductFilter === null)
            throw new Error("The parameter 'isPackageProductFilter' cannot be null.");
        else if (isPackageProductFilter !== undefined)
            url_ += "IsPackageProductFilter=" + encodeURIComponent("" + isPackageProductFilter) + "&";
        if (internalNotesFilter === null)
            throw new Error("The parameter 'internalNotesFilter' cannot be null.");
        else if (internalNotesFilter !== undefined)
            url_ += "InternalNotesFilter=" + encodeURIComponent("" + internalNotesFilter) + "&";
        if (isTemplateFilter === null)
            throw new Error("The parameter 'isTemplateFilter' cannot be null.");
        else if (isTemplateFilter !== undefined)
            url_ += "IsTemplateFilter=" + encodeURIComponent("" + isTemplateFilter) + "&";
        if (maxPriceDiscountAmountFilter === null)
            throw new Error("The parameter 'maxPriceDiscountAmountFilter' cannot be null.");
        else if (maxPriceDiscountAmountFilter !== undefined)
            url_ += "MaxPriceDiscountAmountFilter=" + encodeURIComponent("" + maxPriceDiscountAmountFilter) + "&";
        if (minPriceDiscountAmountFilter === null)
            throw new Error("The parameter 'minPriceDiscountAmountFilter' cannot be null.");
        else if (minPriceDiscountAmountFilter !== undefined)
            url_ += "MinPriceDiscountAmountFilter=" + encodeURIComponent("" + minPriceDiscountAmountFilter) + "&";
        if (isServiceFilter === null)
            throw new Error("The parameter 'isServiceFilter' cannot be null.");
        else if (isServiceFilter !== undefined)
            url_ += "IsServiceFilter=" + encodeURIComponent("" + isServiceFilter) + "&";
        if (isWholeSaleProductFilter === null)
            throw new Error("The parameter 'isWholeSaleProductFilter' cannot be null.");
        else if (isWholeSaleProductFilter !== undefined)
            url_ += "IsWholeSaleProductFilter=" + encodeURIComponent("" + isWholeSaleProductFilter) + "&";
        if (productManufacturerSkuFilter === null)
            throw new Error("The parameter 'productManufacturerSkuFilter' cannot be null.");
        else if (productManufacturerSkuFilter !== undefined)
            url_ += "ProductManufacturerSkuFilter=" + encodeURIComponent("" + productManufacturerSkuFilter) + "&";
        if (byOrderOnlyFilter === null)
            throw new Error("The parameter 'byOrderOnlyFilter' cannot be null.");
        else if (byOrderOnlyFilter !== undefined)
            url_ += "ByOrderOnlyFilter=" + encodeURIComponent("" + byOrderOnlyFilter) + "&";
        if (maxScoreFilter === null)
            throw new Error("The parameter 'maxScoreFilter' cannot be null.");
        else if (maxScoreFilter !== undefined)
            url_ += "MaxScoreFilter=" + encodeURIComponent("" + maxScoreFilter) + "&";
        if (minScoreFilter === null)
            throw new Error("The parameter 'minScoreFilter' cannot be null.");
        else if (minScoreFilter !== undefined)
            url_ += "MinScoreFilter=" + encodeURIComponent("" + minScoreFilter) + "&";
        if (productCategoryNameFilter === null)
            throw new Error("The parameter 'productCategoryNameFilter' cannot be null.");
        else if (productCategoryNameFilter !== undefined)
            url_ += "ProductCategoryNameFilter=" + encodeURIComponent("" + productCategoryNameFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        if (measurementUnitNameFilter === null)
            throw new Error("The parameter 'measurementUnitNameFilter' cannot be null.");
        else if (measurementUnitNameFilter !== undefined)
            url_ += "MeasurementUnitNameFilter=" + encodeURIComponent("" + measurementUnitNameFilter) + "&";
        if (currencyNameFilter === null)
            throw new Error("The parameter 'currencyNameFilter' cannot be null.");
        else if (currencyNameFilter !== undefined)
            url_ += "CurrencyNameFilter=" + encodeURIComponent("" + currencyNameFilter) + "&";
        if (ratingLikeNameFilter === null)
            throw new Error("The parameter 'ratingLikeNameFilter' cannot be null.");
        else if (ratingLikeNameFilter !== undefined)
            url_ += "RatingLikeNameFilter=" + encodeURIComponent("" + ratingLikeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetProductForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetProductForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetProductForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProductForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductForView(id: number | undefined): Observable<GetProductForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetProductForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductForViewDto>;
        }));
    }

    protected processGetProductForView(response: HttpResponseBase): Observable<GetProductForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductForEdit(id: number | undefined): Observable<GetProductForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetProductForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductForEditOutput>;
        }));
    }

    protected processGetProductForEdit(response: HttpResponseBase): Observable<GetProductForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProductDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Products/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Products/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param shortDescriptionFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param skuFilter (optional) 
     * @param urlFilter (optional) 
     * @param seoTitleFilter (optional) 
     * @param metaKeywordsFilter (optional) 
     * @param metaDescriptionFilter (optional) 
     * @param maxRegularPriceFilter (optional) 
     * @param minRegularPriceFilter (optional) 
     * @param maxSalePriceFilter (optional) 
     * @param minSalePriceFilter (optional) 
     * @param maxPriceDiscountPercentageFilter (optional) 
     * @param minPriceDiscountPercentageFilter (optional) 
     * @param callForPriceFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxMeasurementAmountFilter (optional) 
     * @param minMeasurementAmountFilter (optional) 
     * @param isTaxExemptFilter (optional) 
     * @param maxStockQuantityFilter (optional) 
     * @param minStockQuantityFilter (optional) 
     * @param isDisplayStockQuantityFilter (optional) 
     * @param isPublishedFilter (optional) 
     * @param isPackageProductFilter (optional) 
     * @param internalNotesFilter (optional) 
     * @param isTemplateFilter (optional) 
     * @param maxPriceDiscountAmountFilter (optional) 
     * @param minPriceDiscountAmountFilter (optional) 
     * @param isServiceFilter (optional) 
     * @param isWholeSaleProductFilter (optional) 
     * @param productManufacturerSkuFilter (optional) 
     * @param byOrderOnlyFilter (optional) 
     * @param maxScoreFilter (optional) 
     * @param minScoreFilter (optional) 
     * @param productCategoryNameFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @param measurementUnitNameFilter (optional) 
     * @param currencyNameFilter (optional) 
     * @param ratingLikeNameFilter (optional) 
     * @return Success
     */
    getProductsToExcel(filter: string | undefined, nameFilter: string | undefined, shortDescriptionFilter: string | undefined, descriptionFilter: string | undefined, skuFilter: string | undefined, urlFilter: string | undefined, seoTitleFilter: string | undefined, metaKeywordsFilter: string | undefined, metaDescriptionFilter: string | undefined, maxRegularPriceFilter: number | undefined, minRegularPriceFilter: number | undefined, maxSalePriceFilter: number | undefined, minSalePriceFilter: number | undefined, maxPriceDiscountPercentageFilter: number | undefined, minPriceDiscountPercentageFilter: number | undefined, callForPriceFilter: number | undefined, maxUnitPriceFilter: number | undefined, minUnitPriceFilter: number | undefined, maxMeasurementAmountFilter: number | undefined, minMeasurementAmountFilter: number | undefined, isTaxExemptFilter: number | undefined, maxStockQuantityFilter: number | undefined, minStockQuantityFilter: number | undefined, isDisplayStockQuantityFilter: number | undefined, isPublishedFilter: number | undefined, isPackageProductFilter: number | undefined, internalNotesFilter: string | undefined, isTemplateFilter: number | undefined, maxPriceDiscountAmountFilter: number | undefined, minPriceDiscountAmountFilter: number | undefined, isServiceFilter: number | undefined, isWholeSaleProductFilter: number | undefined, productManufacturerSkuFilter: string | undefined, byOrderOnlyFilter: number | undefined, maxScoreFilter: number | undefined, minScoreFilter: number | undefined, productCategoryNameFilter: string | undefined, mediaLibraryNameFilter: string | undefined, measurementUnitNameFilter: string | undefined, currencyNameFilter: string | undefined, ratingLikeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetProductsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (shortDescriptionFilter === null)
            throw new Error("The parameter 'shortDescriptionFilter' cannot be null.");
        else if (shortDescriptionFilter !== undefined)
            url_ += "ShortDescriptionFilter=" + encodeURIComponent("" + shortDescriptionFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (skuFilter === null)
            throw new Error("The parameter 'skuFilter' cannot be null.");
        else if (skuFilter !== undefined)
            url_ += "SkuFilter=" + encodeURIComponent("" + skuFilter) + "&";
        if (urlFilter === null)
            throw new Error("The parameter 'urlFilter' cannot be null.");
        else if (urlFilter !== undefined)
            url_ += "UrlFilter=" + encodeURIComponent("" + urlFilter) + "&";
        if (seoTitleFilter === null)
            throw new Error("The parameter 'seoTitleFilter' cannot be null.");
        else if (seoTitleFilter !== undefined)
            url_ += "SeoTitleFilter=" + encodeURIComponent("" + seoTitleFilter) + "&";
        if (metaKeywordsFilter === null)
            throw new Error("The parameter 'metaKeywordsFilter' cannot be null.");
        else if (metaKeywordsFilter !== undefined)
            url_ += "MetaKeywordsFilter=" + encodeURIComponent("" + metaKeywordsFilter) + "&";
        if (metaDescriptionFilter === null)
            throw new Error("The parameter 'metaDescriptionFilter' cannot be null.");
        else if (metaDescriptionFilter !== undefined)
            url_ += "MetaDescriptionFilter=" + encodeURIComponent("" + metaDescriptionFilter) + "&";
        if (maxRegularPriceFilter === null)
            throw new Error("The parameter 'maxRegularPriceFilter' cannot be null.");
        else if (maxRegularPriceFilter !== undefined)
            url_ += "MaxRegularPriceFilter=" + encodeURIComponent("" + maxRegularPriceFilter) + "&";
        if (minRegularPriceFilter === null)
            throw new Error("The parameter 'minRegularPriceFilter' cannot be null.");
        else if (minRegularPriceFilter !== undefined)
            url_ += "MinRegularPriceFilter=" + encodeURIComponent("" + minRegularPriceFilter) + "&";
        if (maxSalePriceFilter === null)
            throw new Error("The parameter 'maxSalePriceFilter' cannot be null.");
        else if (maxSalePriceFilter !== undefined)
            url_ += "MaxSalePriceFilter=" + encodeURIComponent("" + maxSalePriceFilter) + "&";
        if (minSalePriceFilter === null)
            throw new Error("The parameter 'minSalePriceFilter' cannot be null.");
        else if (minSalePriceFilter !== undefined)
            url_ += "MinSalePriceFilter=" + encodeURIComponent("" + minSalePriceFilter) + "&";
        if (maxPriceDiscountPercentageFilter === null)
            throw new Error("The parameter 'maxPriceDiscountPercentageFilter' cannot be null.");
        else if (maxPriceDiscountPercentageFilter !== undefined)
            url_ += "MaxPriceDiscountPercentageFilter=" + encodeURIComponent("" + maxPriceDiscountPercentageFilter) + "&";
        if (minPriceDiscountPercentageFilter === null)
            throw new Error("The parameter 'minPriceDiscountPercentageFilter' cannot be null.");
        else if (minPriceDiscountPercentageFilter !== undefined)
            url_ += "MinPriceDiscountPercentageFilter=" + encodeURIComponent("" + minPriceDiscountPercentageFilter) + "&";
        if (callForPriceFilter === null)
            throw new Error("The parameter 'callForPriceFilter' cannot be null.");
        else if (callForPriceFilter !== undefined)
            url_ += "CallForPriceFilter=" + encodeURIComponent("" + callForPriceFilter) + "&";
        if (maxUnitPriceFilter === null)
            throw new Error("The parameter 'maxUnitPriceFilter' cannot be null.");
        else if (maxUnitPriceFilter !== undefined)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&";
        if (minUnitPriceFilter === null)
            throw new Error("The parameter 'minUnitPriceFilter' cannot be null.");
        else if (minUnitPriceFilter !== undefined)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&";
        if (maxMeasurementAmountFilter === null)
            throw new Error("The parameter 'maxMeasurementAmountFilter' cannot be null.");
        else if (maxMeasurementAmountFilter !== undefined)
            url_ += "MaxMeasurementAmountFilter=" + encodeURIComponent("" + maxMeasurementAmountFilter) + "&";
        if (minMeasurementAmountFilter === null)
            throw new Error("The parameter 'minMeasurementAmountFilter' cannot be null.");
        else if (minMeasurementAmountFilter !== undefined)
            url_ += "MinMeasurementAmountFilter=" + encodeURIComponent("" + minMeasurementAmountFilter) + "&";
        if (isTaxExemptFilter === null)
            throw new Error("The parameter 'isTaxExemptFilter' cannot be null.");
        else if (isTaxExemptFilter !== undefined)
            url_ += "IsTaxExemptFilter=" + encodeURIComponent("" + isTaxExemptFilter) + "&";
        if (maxStockQuantityFilter === null)
            throw new Error("The parameter 'maxStockQuantityFilter' cannot be null.");
        else if (maxStockQuantityFilter !== undefined)
            url_ += "MaxStockQuantityFilter=" + encodeURIComponent("" + maxStockQuantityFilter) + "&";
        if (minStockQuantityFilter === null)
            throw new Error("The parameter 'minStockQuantityFilter' cannot be null.");
        else if (minStockQuantityFilter !== undefined)
            url_ += "MinStockQuantityFilter=" + encodeURIComponent("" + minStockQuantityFilter) + "&";
        if (isDisplayStockQuantityFilter === null)
            throw new Error("The parameter 'isDisplayStockQuantityFilter' cannot be null.");
        else if (isDisplayStockQuantityFilter !== undefined)
            url_ += "IsDisplayStockQuantityFilter=" + encodeURIComponent("" + isDisplayStockQuantityFilter) + "&";
        if (isPublishedFilter === null)
            throw new Error("The parameter 'isPublishedFilter' cannot be null.");
        else if (isPublishedFilter !== undefined)
            url_ += "IsPublishedFilter=" + encodeURIComponent("" + isPublishedFilter) + "&";
        if (isPackageProductFilter === null)
            throw new Error("The parameter 'isPackageProductFilter' cannot be null.");
        else if (isPackageProductFilter !== undefined)
            url_ += "IsPackageProductFilter=" + encodeURIComponent("" + isPackageProductFilter) + "&";
        if (internalNotesFilter === null)
            throw new Error("The parameter 'internalNotesFilter' cannot be null.");
        else if (internalNotesFilter !== undefined)
            url_ += "InternalNotesFilter=" + encodeURIComponent("" + internalNotesFilter) + "&";
        if (isTemplateFilter === null)
            throw new Error("The parameter 'isTemplateFilter' cannot be null.");
        else if (isTemplateFilter !== undefined)
            url_ += "IsTemplateFilter=" + encodeURIComponent("" + isTemplateFilter) + "&";
        if (maxPriceDiscountAmountFilter === null)
            throw new Error("The parameter 'maxPriceDiscountAmountFilter' cannot be null.");
        else if (maxPriceDiscountAmountFilter !== undefined)
            url_ += "MaxPriceDiscountAmountFilter=" + encodeURIComponent("" + maxPriceDiscountAmountFilter) + "&";
        if (minPriceDiscountAmountFilter === null)
            throw new Error("The parameter 'minPriceDiscountAmountFilter' cannot be null.");
        else if (minPriceDiscountAmountFilter !== undefined)
            url_ += "MinPriceDiscountAmountFilter=" + encodeURIComponent("" + minPriceDiscountAmountFilter) + "&";
        if (isServiceFilter === null)
            throw new Error("The parameter 'isServiceFilter' cannot be null.");
        else if (isServiceFilter !== undefined)
            url_ += "IsServiceFilter=" + encodeURIComponent("" + isServiceFilter) + "&";
        if (isWholeSaleProductFilter === null)
            throw new Error("The parameter 'isWholeSaleProductFilter' cannot be null.");
        else if (isWholeSaleProductFilter !== undefined)
            url_ += "IsWholeSaleProductFilter=" + encodeURIComponent("" + isWholeSaleProductFilter) + "&";
        if (productManufacturerSkuFilter === null)
            throw new Error("The parameter 'productManufacturerSkuFilter' cannot be null.");
        else if (productManufacturerSkuFilter !== undefined)
            url_ += "ProductManufacturerSkuFilter=" + encodeURIComponent("" + productManufacturerSkuFilter) + "&";
        if (byOrderOnlyFilter === null)
            throw new Error("The parameter 'byOrderOnlyFilter' cannot be null.");
        else if (byOrderOnlyFilter !== undefined)
            url_ += "ByOrderOnlyFilter=" + encodeURIComponent("" + byOrderOnlyFilter) + "&";
        if (maxScoreFilter === null)
            throw new Error("The parameter 'maxScoreFilter' cannot be null.");
        else if (maxScoreFilter !== undefined)
            url_ += "MaxScoreFilter=" + encodeURIComponent("" + maxScoreFilter) + "&";
        if (minScoreFilter === null)
            throw new Error("The parameter 'minScoreFilter' cannot be null.");
        else if (minScoreFilter !== undefined)
            url_ += "MinScoreFilter=" + encodeURIComponent("" + minScoreFilter) + "&";
        if (productCategoryNameFilter === null)
            throw new Error("The parameter 'productCategoryNameFilter' cannot be null.");
        else if (productCategoryNameFilter !== undefined)
            url_ += "ProductCategoryNameFilter=" + encodeURIComponent("" + productCategoryNameFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        if (measurementUnitNameFilter === null)
            throw new Error("The parameter 'measurementUnitNameFilter' cannot be null.");
        else if (measurementUnitNameFilter !== undefined)
            url_ += "MeasurementUnitNameFilter=" + encodeURIComponent("" + measurementUnitNameFilter) + "&";
        if (currencyNameFilter === null)
            throw new Error("The parameter 'currencyNameFilter' cannot be null.");
        else if (currencyNameFilter !== undefined)
            url_ += "CurrencyNameFilter=" + encodeURIComponent("" + currencyNameFilter) + "&";
        if (ratingLikeNameFilter === null)
            throw new Error("The parameter 'ratingLikeNameFilter' cannot be null.");
        else if (ratingLikeNameFilter !== undefined)
            url_ += "RatingLikeNameFilter=" + encodeURIComponent("" + ratingLikeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetProductsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductProductCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetAllProductCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProductProductCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProductProductCategoryLookupTableDto>;
        }));
    }

    protected processGetAllProductCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductProductCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductProductCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMediaLibraryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductMediaLibraryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetAllMediaLibraryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMediaLibraryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMediaLibraryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProductMediaLibraryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProductMediaLibraryLookupTableDto>;
        }));
    }

    protected processGetAllMediaLibraryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductMediaLibraryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductMediaLibraryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMeasurementUnitForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductMeasurementUnitLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetAllMeasurementUnitForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMeasurementUnitForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMeasurementUnitForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProductMeasurementUnitLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProductMeasurementUnitLookupTableDto>;
        }));
    }

    protected processGetAllMeasurementUnitForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductMeasurementUnitLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductMeasurementUnitLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCurrencyForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductCurrencyLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetAllCurrencyForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencyForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProductCurrencyLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProductCurrencyLookupTableDto>;
        }));
    }

    protected processGetAllCurrencyForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductCurrencyLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductCurrencyLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRatingLikeForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductRatingLikeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Products/GetAllRatingLikeForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRatingLikeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRatingLikeForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProductRatingLikeLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProductRatingLikeLookupTableDto>;
        }));
    }

    protected processGetAllRatingLikeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductRatingLikeLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductRatingLikeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param productNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, productNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetProductTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductTags/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetProductTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetProductTagForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetProductTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProductTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductTagForView(id: number | undefined): Observable<GetProductTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductTags/GetProductTagForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTagForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTagForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductTagForViewDto>;
        }));
    }

    protected processGetProductTagForView(response: HttpResponseBase): Observable<GetProductTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProductTagForEdit(id: number | undefined): Observable<GetProductTagForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ProductTags/GetProductTagForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTagForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTagForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProductTagForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProductTagForEditOutput>;
        }));
    }

    protected processGetProductTagForEdit(response: HttpResponseBase): Observable<GetProductTagForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductTagForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditProductTagDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductTags/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductTags/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param productNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @return Success
     */
    getProductTagsToExcel(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, productNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductTags/GetProductTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTagsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetProductTagsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductTagProductLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductTags/GetAllProductForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProductTagProductLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProductTagProductLookupTableDto>;
        }));
    }

    protected processGetAllProductForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductTagProductLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductTagProductLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductTagMasterTagCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductTags/GetAllMasterTagCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProductTagMasterTagCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProductTagMasterTagCategoryLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductTagMasterTagCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductTagMasterTagCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfProductTagMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductTags/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfProductTagMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfProductTagMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfProductTagMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductTagMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentUserProfileEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentUserProfileEditDto>;
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserProfileEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    disableGoogleAuthenticator(body: VerifyAuthenticatorCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/DisableGoogleAuthenticator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableGoogleAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableGoogleAuthenticator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisableGoogleAuthenticator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    viewRecoveryCodes(body: VerifyAuthenticatorCodeInput | undefined): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ViewRecoveryCodes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewRecoveryCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewRecoveryCodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
        }));
    }

    protected processViewRecoveryCodes(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    generateGoogleAuthenticatorKey(): Observable<GenerateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GenerateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateGoogleAuthenticatorKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenerateGoogleAuthenticatorKeyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenerateGoogleAuthenticatorKeyOutput>;
        }));
    }

    protected processGenerateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<GenerateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenerateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGoogleAuthenticatorKey(body: UpdateGoogleAuthenticatorKeyInput | undefined): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendVerificationSms(body: SendVerificationSmsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyAuthenticatorCode(body: VerifyAuthenticatorCodeInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifyAuthenticatorCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyAuthenticatorCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyAuthenticatorCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processVerifyAuthenticatorCode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPasswordComplexitySettingOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPasswordComplexitySettingOutput>;
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    getProfilePictureByUserName(username: string | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByUserName?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePictureByUserName(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePicture(userId: number | undefined, tenantId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePicture?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetFriendProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getProfilePictureByUser(userId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePictureByUser(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RatingLikesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param maxScoreFilter (optional) 
     * @param minScoreFilter (optional) 
     * @param iconLinkFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, maxScoreFilter: number | undefined, minScoreFilter: number | undefined, iconLinkFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetRatingLikeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RatingLikes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (maxScoreFilter === null)
            throw new Error("The parameter 'maxScoreFilter' cannot be null.");
        else if (maxScoreFilter !== undefined)
            url_ += "MaxScoreFilter=" + encodeURIComponent("" + maxScoreFilter) + "&";
        if (minScoreFilter === null)
            throw new Error("The parameter 'minScoreFilter' cannot be null.");
        else if (minScoreFilter !== undefined)
            url_ += "MinScoreFilter=" + encodeURIComponent("" + minScoreFilter) + "&";
        if (iconLinkFilter === null)
            throw new Error("The parameter 'iconLinkFilter' cannot be null.");
        else if (iconLinkFilter !== undefined)
            url_ += "IconLinkFilter=" + encodeURIComponent("" + iconLinkFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetRatingLikeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetRatingLikeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRatingLikeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetRatingLikeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRatingLikeForView(id: number | undefined): Observable<GetRatingLikeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RatingLikes/GetRatingLikeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatingLikeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatingLikeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRatingLikeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRatingLikeForViewDto>;
        }));
    }

    protected processGetRatingLikeForView(response: HttpResponseBase): Observable<GetRatingLikeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRatingLikeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRatingLikeForEdit(id: number | undefined): Observable<GetRatingLikeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RatingLikes/GetRatingLikeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatingLikeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatingLikeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRatingLikeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRatingLikeForEditOutput>;
        }));
    }

    protected processGetRatingLikeForEdit(response: HttpResponseBase): Observable<GetRatingLikeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRatingLikeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditRatingLikeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RatingLikes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RatingLikes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param maxScoreFilter (optional) 
     * @param minScoreFilter (optional) 
     * @param iconLinkFilter (optional) 
     * @return Success
     */
    getRatingLikesToExcel(filter: string | undefined, nameFilter: string | undefined, maxScoreFilter: number | undefined, minScoreFilter: number | undefined, iconLinkFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/RatingLikes/GetRatingLikesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (maxScoreFilter === null)
            throw new Error("The parameter 'maxScoreFilter' cannot be null.");
        else if (maxScoreFilter !== undefined)
            url_ += "MaxScoreFilter=" + encodeURIComponent("" + maxScoreFilter) + "&";
        if (minScoreFilter === null)
            throw new Error("The parameter 'minScoreFilter' cannot be null.");
        else if (minScoreFilter !== undefined)
            url_ += "MinScoreFilter=" + encodeURIComponent("" + minScoreFilter) + "&";
        if (iconLinkFilter === null)
            throw new Error("The parameter 'iconLinkFilter' cannot be null.");
        else if (iconLinkFilter !== undefined)
            url_ += "IconLinkFilter=" + encodeURIComponent("" + iconLinkFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatingLikesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatingLikesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetRatingLikesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRoles(body: GetRolesInput | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfRoleListDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateUserSignInTokenOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateUserSignInTokenOutput>;
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SmsTemplatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param contentFilter (optional) 
     * @param publishedFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, titleFilter: string | undefined, contentFilter: string | undefined, publishedFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetSmsTemplateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SmsTemplates/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (titleFilter === null)
            throw new Error("The parameter 'titleFilter' cannot be null.");
        else if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&";
        if (contentFilter === null)
            throw new Error("The parameter 'contentFilter' cannot be null.");
        else if (contentFilter !== undefined)
            url_ += "ContentFilter=" + encodeURIComponent("" + contentFilter) + "&";
        if (publishedFilter === null)
            throw new Error("The parameter 'publishedFilter' cannot be null.");
        else if (publishedFilter !== undefined)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetSmsTemplateForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetSmsTemplateForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSmsTemplateForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSmsTemplateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSmsTemplateForView(id: number | undefined): Observable<GetSmsTemplateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SmsTemplates/GetSmsTemplateForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSmsTemplateForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSmsTemplateForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSmsTemplateForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSmsTemplateForViewDto>;
        }));
    }

    protected processGetSmsTemplateForView(response: HttpResponseBase): Observable<GetSmsTemplateForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSmsTemplateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSmsTemplateForEdit(id: number | undefined): Observable<GetSmsTemplateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SmsTemplates/GetSmsTemplateForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSmsTemplateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSmsTemplateForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSmsTemplateForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSmsTemplateForEditOutput>;
        }));
    }

    protected processGetSmsTemplateForEdit(response: HttpResponseBase): Observable<GetSmsTemplateForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSmsTemplateForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditSmsTemplateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SmsTemplates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SmsTemplates/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param contentFilter (optional) 
     * @param publishedFilter (optional) 
     * @return Success
     */
    getSmsTemplatesToExcel(filter: string | undefined, titleFilter: string | undefined, contentFilter: string | undefined, publishedFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SmsTemplates/GetSmsTemplatesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (titleFilter === null)
            throw new Error("The parameter 'titleFilter' cannot be null.");
        else if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&";
        if (contentFilter === null)
            throw new Error("The parameter 'contentFilter' cannot be null.");
        else if (contentFilter !== undefined)
            url_ += "ContentFilter=" + encodeURIComponent("" + contentFilter) + "&";
        if (publishedFilter === null)
            throw new Error("The parameter 'publishedFilter' cannot be null.");
        else if (publishedFilter !== undefined)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSmsTemplatesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSmsTemplatesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetSmsTemplatesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param tickerFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, tickerFilter: string | undefined, countryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/States/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (tickerFilter === null)
            throw new Error("The parameter 'tickerFilter' cannot be null.");
        else if (tickerFilter !== undefined)
            url_ += "TickerFilter=" + encodeURIComponent("" + tickerFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStateForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStateForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStateForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStateForView(id: number | undefined): Observable<GetStateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/States/GetStateForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStateForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStateForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStateForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStateForViewDto>;
        }));
    }

    protected processGetStateForView(response: HttpResponseBase): Observable<GetStateForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStateForEdit(id: number | undefined): Observable<GetStateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/States/GetStateForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStateForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStateForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStateForEditOutput>;
        }));
    }

    protected processGetStateForEdit(response: HttpResponseBase): Observable<GetStateForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStateForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStateDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/States/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/States/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param tickerFilter (optional) 
     * @param countryNameFilter (optional) 
     * @return Success
     */
    getStatesToExcel(filter: string | undefined, nameFilter: string | undefined, tickerFilter: string | undefined, countryNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/States/GetStatesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (tickerFilter === null)
            throw new Error("The parameter 'tickerFilter' cannot be null.");
        else if (tickerFilter !== undefined)
            url_ += "TickerFilter=" + encodeURIComponent("" + tickerFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStatesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountryForTableDropdown(): Observable<StateCountryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/States/GetAllCountryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StateCountryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StateCountryLookupTableDto[]>;
        }));
    }

    protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<StateCountryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StateCountryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreAccountTeamsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param primaryFilter (optional) 
     * @param activeFilter (optional) 
     * @param orderEmailNotificationFilter (optional) 
     * @param orderSmsNotificationFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param employeeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, primaryFilter: number | undefined, activeFilter: number | undefined, orderEmailNotificationFilter: number | undefined, orderSmsNotificationFilter: number | undefined, storeNameFilter: string | undefined, employeeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreAccountTeamForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreAccountTeams/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (primaryFilter === null)
            throw new Error("The parameter 'primaryFilter' cannot be null.");
        else if (primaryFilter !== undefined)
            url_ += "PrimaryFilter=" + encodeURIComponent("" + primaryFilter) + "&";
        if (activeFilter === null)
            throw new Error("The parameter 'activeFilter' cannot be null.");
        else if (activeFilter !== undefined)
            url_ += "ActiveFilter=" + encodeURIComponent("" + activeFilter) + "&";
        if (orderEmailNotificationFilter === null)
            throw new Error("The parameter 'orderEmailNotificationFilter' cannot be null.");
        else if (orderEmailNotificationFilter !== undefined)
            url_ += "OrderEmailNotificationFilter=" + encodeURIComponent("" + orderEmailNotificationFilter) + "&";
        if (orderSmsNotificationFilter === null)
            throw new Error("The parameter 'orderSmsNotificationFilter' cannot be null.");
        else if (orderSmsNotificationFilter !== undefined)
            url_ += "OrderSmsNotificationFilter=" + encodeURIComponent("" + orderSmsNotificationFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (employeeNameFilter === null)
            throw new Error("The parameter 'employeeNameFilter' cannot be null.");
        else if (employeeNameFilter !== undefined)
            url_ += "EmployeeNameFilter=" + encodeURIComponent("" + employeeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreAccountTeamForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreAccountTeamForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreAccountTeamForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreAccountTeamForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreAccountTeamForView(id: number | undefined): Observable<GetStoreAccountTeamForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreAccountTeams/GetStoreAccountTeamForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreAccountTeamForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreAccountTeamForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreAccountTeamForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreAccountTeamForViewDto>;
        }));
    }

    protected processGetStoreAccountTeamForView(response: HttpResponseBase): Observable<GetStoreAccountTeamForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreAccountTeamForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreAccountTeamForEdit(id: number | undefined): Observable<GetStoreAccountTeamForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreAccountTeams/GetStoreAccountTeamForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreAccountTeamForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreAccountTeamForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreAccountTeamForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreAccountTeamForEditOutput>;
        }));
    }

    protected processGetStoreAccountTeamForEdit(response: HttpResponseBase): Observable<GetStoreAccountTeamForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreAccountTeamForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreAccountTeamDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreAccountTeams/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreAccountTeams/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param primaryFilter (optional) 
     * @param activeFilter (optional) 
     * @param orderEmailNotificationFilter (optional) 
     * @param orderSmsNotificationFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param employeeNameFilter (optional) 
     * @return Success
     */
    getStoreAccountTeamsToExcel(filter: string | undefined, primaryFilter: number | undefined, activeFilter: number | undefined, orderEmailNotificationFilter: number | undefined, orderSmsNotificationFilter: number | undefined, storeNameFilter: string | undefined, employeeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreAccountTeams/GetStoreAccountTeamsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (primaryFilter === null)
            throw new Error("The parameter 'primaryFilter' cannot be null.");
        else if (primaryFilter !== undefined)
            url_ += "PrimaryFilter=" + encodeURIComponent("" + primaryFilter) + "&";
        if (activeFilter === null)
            throw new Error("The parameter 'activeFilter' cannot be null.");
        else if (activeFilter !== undefined)
            url_ += "ActiveFilter=" + encodeURIComponent("" + activeFilter) + "&";
        if (orderEmailNotificationFilter === null)
            throw new Error("The parameter 'orderEmailNotificationFilter' cannot be null.");
        else if (orderEmailNotificationFilter !== undefined)
            url_ += "OrderEmailNotificationFilter=" + encodeURIComponent("" + orderEmailNotificationFilter) + "&";
        if (orderSmsNotificationFilter === null)
            throw new Error("The parameter 'orderSmsNotificationFilter' cannot be null.");
        else if (orderSmsNotificationFilter !== undefined)
            url_ += "OrderSmsNotificationFilter=" + encodeURIComponent("" + orderSmsNotificationFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (employeeNameFilter === null)
            throw new Error("The parameter 'employeeNameFilter' cannot be null.");
        else if (employeeNameFilter !== undefined)
            url_ += "EmployeeNameFilter=" + encodeURIComponent("" + employeeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreAccountTeamsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreAccountTeamsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreAccountTeamsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreAccountTeamStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreAccountTeams/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreAccountTeamStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreAccountTeamStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreAccountTeamStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreAccountTeamStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllEmployeeForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreAccountTeams/GetAllEmployeeForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployeeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployeeForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto>;
        }));
    }

    protected processGetAllEmployeeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreBankAccountsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param accountNameFilter (optional) 
     * @param accountNoFilter (optional) 
     * @param bankNameFilter (optional) 
     * @param routingNoFilter (optional) 
     * @param bankAddressFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, accountNameFilter: string | undefined, accountNoFilter: string | undefined, bankNameFilter: string | undefined, routingNoFilter: string | undefined, bankAddressFilter: string | undefined, storeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreBankAccountForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBankAccounts/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (accountNameFilter === null)
            throw new Error("The parameter 'accountNameFilter' cannot be null.");
        else if (accountNameFilter !== undefined)
            url_ += "AccountNameFilter=" + encodeURIComponent("" + accountNameFilter) + "&";
        if (accountNoFilter === null)
            throw new Error("The parameter 'accountNoFilter' cannot be null.");
        else if (accountNoFilter !== undefined)
            url_ += "AccountNoFilter=" + encodeURIComponent("" + accountNoFilter) + "&";
        if (bankNameFilter === null)
            throw new Error("The parameter 'bankNameFilter' cannot be null.");
        else if (bankNameFilter !== undefined)
            url_ += "BankNameFilter=" + encodeURIComponent("" + bankNameFilter) + "&";
        if (routingNoFilter === null)
            throw new Error("The parameter 'routingNoFilter' cannot be null.");
        else if (routingNoFilter !== undefined)
            url_ += "RoutingNoFilter=" + encodeURIComponent("" + routingNoFilter) + "&";
        if (bankAddressFilter === null)
            throw new Error("The parameter 'bankAddressFilter' cannot be null.");
        else if (bankAddressFilter !== undefined)
            url_ += "BankAddressFilter=" + encodeURIComponent("" + bankAddressFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreBankAccountForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreBankAccountForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreBankAccountForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreBankAccountForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreBankAccountForView(id: number | undefined): Observable<GetStoreBankAccountForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBankAccounts/GetStoreBankAccountForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreBankAccountForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreBankAccountForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreBankAccountForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreBankAccountForViewDto>;
        }));
    }

    protected processGetStoreBankAccountForView(response: HttpResponseBase): Observable<GetStoreBankAccountForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreBankAccountForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreBankAccountForEdit(id: number | undefined): Observable<GetStoreBankAccountForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreBankAccounts/GetStoreBankAccountForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreBankAccountForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreBankAccountForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreBankAccountForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreBankAccountForEditOutput>;
        }));
    }

    protected processGetStoreBankAccountForEdit(response: HttpResponseBase): Observable<GetStoreBankAccountForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreBankAccountForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreBankAccountDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreBankAccounts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreBankAccounts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param accountNameFilter (optional) 
     * @param accountNoFilter (optional) 
     * @param bankNameFilter (optional) 
     * @param routingNoFilter (optional) 
     * @param bankAddressFilter (optional) 
     * @param storeNameFilter (optional) 
     * @return Success
     */
    getStoreBankAccountsToExcel(filter: string | undefined, accountNameFilter: string | undefined, accountNoFilter: string | undefined, bankNameFilter: string | undefined, routingNoFilter: string | undefined, bankAddressFilter: string | undefined, storeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBankAccounts/GetStoreBankAccountsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (accountNameFilter === null)
            throw new Error("The parameter 'accountNameFilter' cannot be null.");
        else if (accountNameFilter !== undefined)
            url_ += "AccountNameFilter=" + encodeURIComponent("" + accountNameFilter) + "&";
        if (accountNoFilter === null)
            throw new Error("The parameter 'accountNoFilter' cannot be null.");
        else if (accountNoFilter !== undefined)
            url_ += "AccountNoFilter=" + encodeURIComponent("" + accountNoFilter) + "&";
        if (bankNameFilter === null)
            throw new Error("The parameter 'bankNameFilter' cannot be null.");
        else if (bankNameFilter !== undefined)
            url_ += "BankNameFilter=" + encodeURIComponent("" + bankNameFilter) + "&";
        if (routingNoFilter === null)
            throw new Error("The parameter 'routingNoFilter' cannot be null.");
        else if (routingNoFilter !== undefined)
            url_ += "RoutingNoFilter=" + encodeURIComponent("" + routingNoFilter) + "&";
        if (bankAddressFilter === null)
            throw new Error("The parameter 'bankAddressFilter' cannot be null.");
        else if (bankAddressFilter !== undefined)
            url_ += "BankAddressFilter=" + encodeURIComponent("" + bankAddressFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreBankAccountsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreBankAccountsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreBankAccountsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreBankAccountStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBankAccounts/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreBankAccountStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreBankAccountStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreBankAccountStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreBankAccountStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreBusinessCustomerMapsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param paidCustomerFilter (optional) 
     * @param maxLifeTimeSalesAmountFilter (optional) 
     * @param minLifeTimeSalesAmountFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param businessNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, paidCustomerFilter: number | undefined, maxLifeTimeSalesAmountFilter: number | undefined, minLifeTimeSalesAmountFilter: number | undefined, storeNameFilter: string | undefined, businessNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreBusinessCustomerMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessCustomerMaps/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (paidCustomerFilter === null)
            throw new Error("The parameter 'paidCustomerFilter' cannot be null.");
        else if (paidCustomerFilter !== undefined)
            url_ += "PaidCustomerFilter=" + encodeURIComponent("" + paidCustomerFilter) + "&";
        if (maxLifeTimeSalesAmountFilter === null)
            throw new Error("The parameter 'maxLifeTimeSalesAmountFilter' cannot be null.");
        else if (maxLifeTimeSalesAmountFilter !== undefined)
            url_ += "MaxLifeTimeSalesAmountFilter=" + encodeURIComponent("" + maxLifeTimeSalesAmountFilter) + "&";
        if (minLifeTimeSalesAmountFilter === null)
            throw new Error("The parameter 'minLifeTimeSalesAmountFilter' cannot be null.");
        else if (minLifeTimeSalesAmountFilter !== undefined)
            url_ += "MinLifeTimeSalesAmountFilter=" + encodeURIComponent("" + minLifeTimeSalesAmountFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreBusinessCustomerMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreBusinessCustomerMapForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreBusinessCustomerMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreBusinessCustomerMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreBusinessCustomerMapForView(id: number | undefined): Observable<GetStoreBusinessCustomerMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessCustomerMaps/GetStoreBusinessCustomerMapForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreBusinessCustomerMapForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreBusinessCustomerMapForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreBusinessCustomerMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreBusinessCustomerMapForViewDto>;
        }));
    }

    protected processGetStoreBusinessCustomerMapForView(response: HttpResponseBase): Observable<GetStoreBusinessCustomerMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreBusinessCustomerMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreBusinessCustomerMapForEdit(id: number | undefined): Observable<GetStoreBusinessCustomerMapForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessCustomerMaps/GetStoreBusinessCustomerMapForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreBusinessCustomerMapForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreBusinessCustomerMapForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreBusinessCustomerMapForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreBusinessCustomerMapForEditOutput>;
        }));
    }

    protected processGetStoreBusinessCustomerMapForEdit(response: HttpResponseBase): Observable<GetStoreBusinessCustomerMapForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreBusinessCustomerMapForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreBusinessCustomerMapDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessCustomerMaps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessCustomerMaps/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param paidCustomerFilter (optional) 
     * @param maxLifeTimeSalesAmountFilter (optional) 
     * @param minLifeTimeSalesAmountFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param businessNameFilter (optional) 
     * @return Success
     */
    getStoreBusinessCustomerMapsToExcel(filter: string | undefined, paidCustomerFilter: number | undefined, maxLifeTimeSalesAmountFilter: number | undefined, minLifeTimeSalesAmountFilter: number | undefined, storeNameFilter: string | undefined, businessNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessCustomerMaps/GetStoreBusinessCustomerMapsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (paidCustomerFilter === null)
            throw new Error("The parameter 'paidCustomerFilter' cannot be null.");
        else if (paidCustomerFilter !== undefined)
            url_ += "PaidCustomerFilter=" + encodeURIComponent("" + paidCustomerFilter) + "&";
        if (maxLifeTimeSalesAmountFilter === null)
            throw new Error("The parameter 'maxLifeTimeSalesAmountFilter' cannot be null.");
        else if (maxLifeTimeSalesAmountFilter !== undefined)
            url_ += "MaxLifeTimeSalesAmountFilter=" + encodeURIComponent("" + maxLifeTimeSalesAmountFilter) + "&";
        if (minLifeTimeSalesAmountFilter === null)
            throw new Error("The parameter 'minLifeTimeSalesAmountFilter' cannot be null.");
        else if (minLifeTimeSalesAmountFilter !== undefined)
            url_ += "MinLifeTimeSalesAmountFilter=" + encodeURIComponent("" + minLifeTimeSalesAmountFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (businessNameFilter === null)
            throw new Error("The parameter 'businessNameFilter' cannot be null.");
        else if (businessNameFilter !== undefined)
            url_ += "BusinessNameFilter=" + encodeURIComponent("" + businessNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreBusinessCustomerMapsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreBusinessCustomerMapsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreBusinessCustomerMapsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessCustomerMaps/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBusinessForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessCustomerMaps/GetAllBusinessForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBusinessForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBusinessForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto>;
        }));
    }

    protected processGetAllBusinessForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreBusinessHoursServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nowOpenOrClosedFilter (optional) 
     * @param isOpen24HoursFilter (optional) 
     * @param mondayStartTimeFilter (optional) 
     * @param mondayEndTimeFilter (optional) 
     * @param tuesdayStartTimeFilter (optional) 
     * @param tuesdayEndTimeFilter (optional) 
     * @param wednesdayStartTimeFilter (optional) 
     * @param wednesdayEndTimeFilter (optional) 
     * @param thursdayStartTimeFilter (optional) 
     * @param thursdayEndTimeFilter (optional) 
     * @param fridayStartTimeFilter (optional) 
     * @param fridayEndTimeFilter (optional) 
     * @param saturdayStartTimeFilter (optional) 
     * @param saturdayEndTimeFilter (optional) 
     * @param sundayStartTimeFilter (optional) 
     * @param sundayEndTimeFilter (optional) 
     * @param isAcceptOnlyBusinessHourFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nowOpenOrClosedFilter: number | undefined, isOpen24HoursFilter: number | undefined, mondayStartTimeFilter: string | undefined, mondayEndTimeFilter: string | undefined, tuesdayStartTimeFilter: string | undefined, tuesdayEndTimeFilter: string | undefined, wednesdayStartTimeFilter: string | undefined, wednesdayEndTimeFilter: string | undefined, thursdayStartTimeFilter: string | undefined, thursdayEndTimeFilter: string | undefined, fridayStartTimeFilter: string | undefined, fridayEndTimeFilter: string | undefined, saturdayStartTimeFilter: string | undefined, saturdayEndTimeFilter: string | undefined, sundayStartTimeFilter: string | undefined, sundayEndTimeFilter: string | undefined, isAcceptOnlyBusinessHourFilter: number | undefined, storeNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreBusinessHourForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessHours/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nowOpenOrClosedFilter === null)
            throw new Error("The parameter 'nowOpenOrClosedFilter' cannot be null.");
        else if (nowOpenOrClosedFilter !== undefined)
            url_ += "NowOpenOrClosedFilter=" + encodeURIComponent("" + nowOpenOrClosedFilter) + "&";
        if (isOpen24HoursFilter === null)
            throw new Error("The parameter 'isOpen24HoursFilter' cannot be null.");
        else if (isOpen24HoursFilter !== undefined)
            url_ += "IsOpen24HoursFilter=" + encodeURIComponent("" + isOpen24HoursFilter) + "&";
        if (mondayStartTimeFilter === null)
            throw new Error("The parameter 'mondayStartTimeFilter' cannot be null.");
        else if (mondayStartTimeFilter !== undefined)
            url_ += "MondayStartTimeFilter=" + encodeURIComponent("" + mondayStartTimeFilter) + "&";
        if (mondayEndTimeFilter === null)
            throw new Error("The parameter 'mondayEndTimeFilter' cannot be null.");
        else if (mondayEndTimeFilter !== undefined)
            url_ += "MondayEndTimeFilter=" + encodeURIComponent("" + mondayEndTimeFilter) + "&";
        if (tuesdayStartTimeFilter === null)
            throw new Error("The parameter 'tuesdayStartTimeFilter' cannot be null.");
        else if (tuesdayStartTimeFilter !== undefined)
            url_ += "TuesdayStartTimeFilter=" + encodeURIComponent("" + tuesdayStartTimeFilter) + "&";
        if (tuesdayEndTimeFilter === null)
            throw new Error("The parameter 'tuesdayEndTimeFilter' cannot be null.");
        else if (tuesdayEndTimeFilter !== undefined)
            url_ += "TuesdayEndTimeFilter=" + encodeURIComponent("" + tuesdayEndTimeFilter) + "&";
        if (wednesdayStartTimeFilter === null)
            throw new Error("The parameter 'wednesdayStartTimeFilter' cannot be null.");
        else if (wednesdayStartTimeFilter !== undefined)
            url_ += "WednesdayStartTimeFilter=" + encodeURIComponent("" + wednesdayStartTimeFilter) + "&";
        if (wednesdayEndTimeFilter === null)
            throw new Error("The parameter 'wednesdayEndTimeFilter' cannot be null.");
        else if (wednesdayEndTimeFilter !== undefined)
            url_ += "WednesdayEndTimeFilter=" + encodeURIComponent("" + wednesdayEndTimeFilter) + "&";
        if (thursdayStartTimeFilter === null)
            throw new Error("The parameter 'thursdayStartTimeFilter' cannot be null.");
        else if (thursdayStartTimeFilter !== undefined)
            url_ += "ThursdayStartTimeFilter=" + encodeURIComponent("" + thursdayStartTimeFilter) + "&";
        if (thursdayEndTimeFilter === null)
            throw new Error("The parameter 'thursdayEndTimeFilter' cannot be null.");
        else if (thursdayEndTimeFilter !== undefined)
            url_ += "ThursdayEndTimeFilter=" + encodeURIComponent("" + thursdayEndTimeFilter) + "&";
        if (fridayStartTimeFilter === null)
            throw new Error("The parameter 'fridayStartTimeFilter' cannot be null.");
        else if (fridayStartTimeFilter !== undefined)
            url_ += "FridayStartTimeFilter=" + encodeURIComponent("" + fridayStartTimeFilter) + "&";
        if (fridayEndTimeFilter === null)
            throw new Error("The parameter 'fridayEndTimeFilter' cannot be null.");
        else if (fridayEndTimeFilter !== undefined)
            url_ += "FridayEndTimeFilter=" + encodeURIComponent("" + fridayEndTimeFilter) + "&";
        if (saturdayStartTimeFilter === null)
            throw new Error("The parameter 'saturdayStartTimeFilter' cannot be null.");
        else if (saturdayStartTimeFilter !== undefined)
            url_ += "SaturdayStartTimeFilter=" + encodeURIComponent("" + saturdayStartTimeFilter) + "&";
        if (saturdayEndTimeFilter === null)
            throw new Error("The parameter 'saturdayEndTimeFilter' cannot be null.");
        else if (saturdayEndTimeFilter !== undefined)
            url_ += "SaturdayEndTimeFilter=" + encodeURIComponent("" + saturdayEndTimeFilter) + "&";
        if (sundayStartTimeFilter === null)
            throw new Error("The parameter 'sundayStartTimeFilter' cannot be null.");
        else if (sundayStartTimeFilter !== undefined)
            url_ += "SundayStartTimeFilter=" + encodeURIComponent("" + sundayStartTimeFilter) + "&";
        if (sundayEndTimeFilter === null)
            throw new Error("The parameter 'sundayEndTimeFilter' cannot be null.");
        else if (sundayEndTimeFilter !== undefined)
            url_ += "SundayEndTimeFilter=" + encodeURIComponent("" + sundayEndTimeFilter) + "&";
        if (isAcceptOnlyBusinessHourFilter === null)
            throw new Error("The parameter 'isAcceptOnlyBusinessHourFilter' cannot be null.");
        else if (isAcceptOnlyBusinessHourFilter !== undefined)
            url_ += "IsAcceptOnlyBusinessHourFilter=" + encodeURIComponent("" + isAcceptOnlyBusinessHourFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreBusinessHourForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreBusinessHourForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreBusinessHourForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreBusinessHourForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreBusinessHourForView(id: number | undefined): Observable<GetStoreBusinessHourForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessHours/GetStoreBusinessHourForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreBusinessHourForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreBusinessHourForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreBusinessHourForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreBusinessHourForViewDto>;
        }));
    }

    protected processGetStoreBusinessHourForView(response: HttpResponseBase): Observable<GetStoreBusinessHourForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreBusinessHourForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreBusinessHourForEdit(id: number | undefined): Observable<GetStoreBusinessHourForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessHours/GetStoreBusinessHourForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreBusinessHourForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreBusinessHourForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreBusinessHourForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreBusinessHourForEditOutput>;
        }));
    }

    protected processGetStoreBusinessHourForEdit(response: HttpResponseBase): Observable<GetStoreBusinessHourForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreBusinessHourForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreBusinessHourDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessHours/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessHours/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nowOpenOrClosedFilter (optional) 
     * @param isOpen24HoursFilter (optional) 
     * @param mondayStartTimeFilter (optional) 
     * @param mondayEndTimeFilter (optional) 
     * @param tuesdayStartTimeFilter (optional) 
     * @param tuesdayEndTimeFilter (optional) 
     * @param wednesdayStartTimeFilter (optional) 
     * @param wednesdayEndTimeFilter (optional) 
     * @param thursdayStartTimeFilter (optional) 
     * @param thursdayEndTimeFilter (optional) 
     * @param fridayStartTimeFilter (optional) 
     * @param fridayEndTimeFilter (optional) 
     * @param saturdayStartTimeFilter (optional) 
     * @param saturdayEndTimeFilter (optional) 
     * @param sundayStartTimeFilter (optional) 
     * @param sundayEndTimeFilter (optional) 
     * @param isAcceptOnlyBusinessHourFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @return Success
     */
    getStoreBusinessHoursToExcel(filter: string | undefined, nowOpenOrClosedFilter: number | undefined, isOpen24HoursFilter: number | undefined, mondayStartTimeFilter: string | undefined, mondayEndTimeFilter: string | undefined, tuesdayStartTimeFilter: string | undefined, tuesdayEndTimeFilter: string | undefined, wednesdayStartTimeFilter: string | undefined, wednesdayEndTimeFilter: string | undefined, thursdayStartTimeFilter: string | undefined, thursdayEndTimeFilter: string | undefined, fridayStartTimeFilter: string | undefined, fridayEndTimeFilter: string | undefined, saturdayStartTimeFilter: string | undefined, saturdayEndTimeFilter: string | undefined, sundayStartTimeFilter: string | undefined, sundayEndTimeFilter: string | undefined, isAcceptOnlyBusinessHourFilter: number | undefined, storeNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessHours/GetStoreBusinessHoursToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nowOpenOrClosedFilter === null)
            throw new Error("The parameter 'nowOpenOrClosedFilter' cannot be null.");
        else if (nowOpenOrClosedFilter !== undefined)
            url_ += "NowOpenOrClosedFilter=" + encodeURIComponent("" + nowOpenOrClosedFilter) + "&";
        if (isOpen24HoursFilter === null)
            throw new Error("The parameter 'isOpen24HoursFilter' cannot be null.");
        else if (isOpen24HoursFilter !== undefined)
            url_ += "IsOpen24HoursFilter=" + encodeURIComponent("" + isOpen24HoursFilter) + "&";
        if (mondayStartTimeFilter === null)
            throw new Error("The parameter 'mondayStartTimeFilter' cannot be null.");
        else if (mondayStartTimeFilter !== undefined)
            url_ += "MondayStartTimeFilter=" + encodeURIComponent("" + mondayStartTimeFilter) + "&";
        if (mondayEndTimeFilter === null)
            throw new Error("The parameter 'mondayEndTimeFilter' cannot be null.");
        else if (mondayEndTimeFilter !== undefined)
            url_ += "MondayEndTimeFilter=" + encodeURIComponent("" + mondayEndTimeFilter) + "&";
        if (tuesdayStartTimeFilter === null)
            throw new Error("The parameter 'tuesdayStartTimeFilter' cannot be null.");
        else if (tuesdayStartTimeFilter !== undefined)
            url_ += "TuesdayStartTimeFilter=" + encodeURIComponent("" + tuesdayStartTimeFilter) + "&";
        if (tuesdayEndTimeFilter === null)
            throw new Error("The parameter 'tuesdayEndTimeFilter' cannot be null.");
        else if (tuesdayEndTimeFilter !== undefined)
            url_ += "TuesdayEndTimeFilter=" + encodeURIComponent("" + tuesdayEndTimeFilter) + "&";
        if (wednesdayStartTimeFilter === null)
            throw new Error("The parameter 'wednesdayStartTimeFilter' cannot be null.");
        else if (wednesdayStartTimeFilter !== undefined)
            url_ += "WednesdayStartTimeFilter=" + encodeURIComponent("" + wednesdayStartTimeFilter) + "&";
        if (wednesdayEndTimeFilter === null)
            throw new Error("The parameter 'wednesdayEndTimeFilter' cannot be null.");
        else if (wednesdayEndTimeFilter !== undefined)
            url_ += "WednesdayEndTimeFilter=" + encodeURIComponent("" + wednesdayEndTimeFilter) + "&";
        if (thursdayStartTimeFilter === null)
            throw new Error("The parameter 'thursdayStartTimeFilter' cannot be null.");
        else if (thursdayStartTimeFilter !== undefined)
            url_ += "ThursdayStartTimeFilter=" + encodeURIComponent("" + thursdayStartTimeFilter) + "&";
        if (thursdayEndTimeFilter === null)
            throw new Error("The parameter 'thursdayEndTimeFilter' cannot be null.");
        else if (thursdayEndTimeFilter !== undefined)
            url_ += "ThursdayEndTimeFilter=" + encodeURIComponent("" + thursdayEndTimeFilter) + "&";
        if (fridayStartTimeFilter === null)
            throw new Error("The parameter 'fridayStartTimeFilter' cannot be null.");
        else if (fridayStartTimeFilter !== undefined)
            url_ += "FridayStartTimeFilter=" + encodeURIComponent("" + fridayStartTimeFilter) + "&";
        if (fridayEndTimeFilter === null)
            throw new Error("The parameter 'fridayEndTimeFilter' cannot be null.");
        else if (fridayEndTimeFilter !== undefined)
            url_ += "FridayEndTimeFilter=" + encodeURIComponent("" + fridayEndTimeFilter) + "&";
        if (saturdayStartTimeFilter === null)
            throw new Error("The parameter 'saturdayStartTimeFilter' cannot be null.");
        else if (saturdayStartTimeFilter !== undefined)
            url_ += "SaturdayStartTimeFilter=" + encodeURIComponent("" + saturdayStartTimeFilter) + "&";
        if (saturdayEndTimeFilter === null)
            throw new Error("The parameter 'saturdayEndTimeFilter' cannot be null.");
        else if (saturdayEndTimeFilter !== undefined)
            url_ += "SaturdayEndTimeFilter=" + encodeURIComponent("" + saturdayEndTimeFilter) + "&";
        if (sundayStartTimeFilter === null)
            throw new Error("The parameter 'sundayStartTimeFilter' cannot be null.");
        else if (sundayStartTimeFilter !== undefined)
            url_ += "SundayStartTimeFilter=" + encodeURIComponent("" + sundayStartTimeFilter) + "&";
        if (sundayEndTimeFilter === null)
            throw new Error("The parameter 'sundayEndTimeFilter' cannot be null.");
        else if (sundayEndTimeFilter !== undefined)
            url_ += "SundayEndTimeFilter=" + encodeURIComponent("" + sundayEndTimeFilter) + "&";
        if (isAcceptOnlyBusinessHourFilter === null)
            throw new Error("The parameter 'isAcceptOnlyBusinessHourFilter' cannot be null.");
        else if (isAcceptOnlyBusinessHourFilter !== undefined)
            url_ += "IsAcceptOnlyBusinessHourFilter=" + encodeURIComponent("" + isAcceptOnlyBusinessHourFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreBusinessHoursToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreBusinessHoursToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreBusinessHoursToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreBusinessHourStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessHours/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreBusinessHourStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreBusinessHourStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreBusinessHourStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreBusinessHourStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessHours/GetAllMasterTagCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreBusinessHours/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreContactMapsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param paidCustomerFilter (optional) 
     * @param maxLifeTimeSalesAmountFilter (optional) 
     * @param minLifeTimeSalesAmountFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param contactFullNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, paidCustomerFilter: number | undefined, maxLifeTimeSalesAmountFilter: number | undefined, minLifeTimeSalesAmountFilter: number | undefined, storeNameFilter: string | undefined, contactFullNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreContactMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreContactMaps/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (paidCustomerFilter === null)
            throw new Error("The parameter 'paidCustomerFilter' cannot be null.");
        else if (paidCustomerFilter !== undefined)
            url_ += "PaidCustomerFilter=" + encodeURIComponent("" + paidCustomerFilter) + "&";
        if (maxLifeTimeSalesAmountFilter === null)
            throw new Error("The parameter 'maxLifeTimeSalesAmountFilter' cannot be null.");
        else if (maxLifeTimeSalesAmountFilter !== undefined)
            url_ += "MaxLifeTimeSalesAmountFilter=" + encodeURIComponent("" + maxLifeTimeSalesAmountFilter) + "&";
        if (minLifeTimeSalesAmountFilter === null)
            throw new Error("The parameter 'minLifeTimeSalesAmountFilter' cannot be null.");
        else if (minLifeTimeSalesAmountFilter !== undefined)
            url_ += "MinLifeTimeSalesAmountFilter=" + encodeURIComponent("" + minLifeTimeSalesAmountFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (contactFullNameFilter === null)
            throw new Error("The parameter 'contactFullNameFilter' cannot be null.");
        else if (contactFullNameFilter !== undefined)
            url_ += "ContactFullNameFilter=" + encodeURIComponent("" + contactFullNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreContactMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreContactMapForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreContactMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreContactMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreContactMapForView(id: number | undefined): Observable<GetStoreContactMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreContactMaps/GetStoreContactMapForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreContactMapForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreContactMapForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreContactMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreContactMapForViewDto>;
        }));
    }

    protected processGetStoreContactMapForView(response: HttpResponseBase): Observable<GetStoreContactMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreContactMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreContactMapForEdit(id: number | undefined): Observable<GetStoreContactMapForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreContactMaps/GetStoreContactMapForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreContactMapForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreContactMapForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreContactMapForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreContactMapForEditOutput>;
        }));
    }

    protected processGetStoreContactMapForEdit(response: HttpResponseBase): Observable<GetStoreContactMapForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreContactMapForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreContactMapDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreContactMaps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreContactMaps/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param paidCustomerFilter (optional) 
     * @param maxLifeTimeSalesAmountFilter (optional) 
     * @param minLifeTimeSalesAmountFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param contactFullNameFilter (optional) 
     * @return Success
     */
    getStoreContactMapsToExcel(filter: string | undefined, paidCustomerFilter: number | undefined, maxLifeTimeSalesAmountFilter: number | undefined, minLifeTimeSalesAmountFilter: number | undefined, storeNameFilter: string | undefined, contactFullNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreContactMaps/GetStoreContactMapsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (paidCustomerFilter === null)
            throw new Error("The parameter 'paidCustomerFilter' cannot be null.");
        else if (paidCustomerFilter !== undefined)
            url_ += "PaidCustomerFilter=" + encodeURIComponent("" + paidCustomerFilter) + "&";
        if (maxLifeTimeSalesAmountFilter === null)
            throw new Error("The parameter 'maxLifeTimeSalesAmountFilter' cannot be null.");
        else if (maxLifeTimeSalesAmountFilter !== undefined)
            url_ += "MaxLifeTimeSalesAmountFilter=" + encodeURIComponent("" + maxLifeTimeSalesAmountFilter) + "&";
        if (minLifeTimeSalesAmountFilter === null)
            throw new Error("The parameter 'minLifeTimeSalesAmountFilter' cannot be null.");
        else if (minLifeTimeSalesAmountFilter !== undefined)
            url_ += "MinLifeTimeSalesAmountFilter=" + encodeURIComponent("" + minLifeTimeSalesAmountFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (contactFullNameFilter === null)
            throw new Error("The parameter 'contactFullNameFilter' cannot be null.");
        else if (contactFullNameFilter !== undefined)
            url_ += "ContactFullNameFilter=" + encodeURIComponent("" + contactFullNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreContactMapsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreContactMapsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreContactMapsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreContactMapStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreContactMaps/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreContactMapStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreContactMapStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreContactMapStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreContactMapStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllContactForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreContactMapContactLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreContactMaps/GetAllContactForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContactForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContactForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreContactMapContactLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreContactMapContactLookupTableDto>;
        }));
    }

    protected processGetAllContactForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreContactMapContactLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreContactMapContactLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreLocationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param locationNameFilter (optional) 
     * @param fullAddressFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param addressFilter (optional) 
     * @param mobileFilter (optional) 
     * @param emailFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param cityNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, locationNameFilter: string | undefined, fullAddressFilter: string | undefined, maxLatitudeFilter: number | undefined, minLatitudeFilter: number | undefined, maxLongitudeFilter: number | undefined, minLongitudeFilter: number | undefined, addressFilter: string | undefined, mobileFilter: string | undefined, emailFilter: string | undefined, zipCodeFilter: string | undefined, cityNameFilter: string | undefined, stateNameFilter: string | undefined, countryNameFilter: string | undefined, storeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreLocationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreLocations/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (locationNameFilter === null)
            throw new Error("The parameter 'locationNameFilter' cannot be null.");
        else if (locationNameFilter !== undefined)
            url_ += "LocationNameFilter=" + encodeURIComponent("" + locationNameFilter) + "&";
        if (fullAddressFilter === null)
            throw new Error("The parameter 'fullAddressFilter' cannot be null.");
        else if (fullAddressFilter !== undefined)
            url_ += "FullAddressFilter=" + encodeURIComponent("" + fullAddressFilter) + "&";
        if (maxLatitudeFilter === null)
            throw new Error("The parameter 'maxLatitudeFilter' cannot be null.");
        else if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&";
        if (minLatitudeFilter === null)
            throw new Error("The parameter 'minLatitudeFilter' cannot be null.");
        else if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&";
        if (maxLongitudeFilter === null)
            throw new Error("The parameter 'maxLongitudeFilter' cannot be null.");
        else if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&";
        if (minLongitudeFilter === null)
            throw new Error("The parameter 'minLongitudeFilter' cannot be null.");
        else if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&";
        if (addressFilter === null)
            throw new Error("The parameter 'addressFilter' cannot be null.");
        else if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&";
        if (mobileFilter === null)
            throw new Error("The parameter 'mobileFilter' cannot be null.");
        else if (mobileFilter !== undefined)
            url_ += "MobileFilter=" + encodeURIComponent("" + mobileFilter) + "&";
        if (emailFilter === null)
            throw new Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (cityNameFilter === null)
            throw new Error("The parameter 'cityNameFilter' cannot be null.");
        else if (cityNameFilter !== undefined)
            url_ += "CityNameFilter=" + encodeURIComponent("" + cityNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreLocationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreLocationForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreLocationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreLocationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreLocationForView(id: number | undefined): Observable<GetStoreLocationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreLocations/GetStoreLocationForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreLocationForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreLocationForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreLocationForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreLocationForViewDto>;
        }));
    }

    protected processGetStoreLocationForView(response: HttpResponseBase): Observable<GetStoreLocationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreLocationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreLocationForEdit(id: number | undefined): Observable<GetStoreLocationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreLocations/GetStoreLocationForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreLocationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreLocationForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreLocationForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreLocationForEditOutput>;
        }));
    }

    protected processGetStoreLocationForEdit(response: HttpResponseBase): Observable<GetStoreLocationForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreLocationForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreLocationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreLocations/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreLocations/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param locationNameFilter (optional) 
     * @param fullAddressFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param addressFilter (optional) 
     * @param mobileFilter (optional) 
     * @param emailFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param cityNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param storeNameFilter (optional) 
     * @return Success
     */
    getStoreLocationsToExcel(filter: string | undefined, locationNameFilter: string | undefined, fullAddressFilter: string | undefined, maxLatitudeFilter: number | undefined, minLatitudeFilter: number | undefined, maxLongitudeFilter: number | undefined, minLongitudeFilter: number | undefined, addressFilter: string | undefined, mobileFilter: string | undefined, emailFilter: string | undefined, zipCodeFilter: string | undefined, cityNameFilter: string | undefined, stateNameFilter: string | undefined, countryNameFilter: string | undefined, storeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreLocations/GetStoreLocationsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (locationNameFilter === null)
            throw new Error("The parameter 'locationNameFilter' cannot be null.");
        else if (locationNameFilter !== undefined)
            url_ += "LocationNameFilter=" + encodeURIComponent("" + locationNameFilter) + "&";
        if (fullAddressFilter === null)
            throw new Error("The parameter 'fullAddressFilter' cannot be null.");
        else if (fullAddressFilter !== undefined)
            url_ += "FullAddressFilter=" + encodeURIComponent("" + fullAddressFilter) + "&";
        if (maxLatitudeFilter === null)
            throw new Error("The parameter 'maxLatitudeFilter' cannot be null.");
        else if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&";
        if (minLatitudeFilter === null)
            throw new Error("The parameter 'minLatitudeFilter' cannot be null.");
        else if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&";
        if (maxLongitudeFilter === null)
            throw new Error("The parameter 'maxLongitudeFilter' cannot be null.");
        else if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&";
        if (minLongitudeFilter === null)
            throw new Error("The parameter 'minLongitudeFilter' cannot be null.");
        else if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&";
        if (addressFilter === null)
            throw new Error("The parameter 'addressFilter' cannot be null.");
        else if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&";
        if (mobileFilter === null)
            throw new Error("The parameter 'mobileFilter' cannot be null.");
        else if (mobileFilter !== undefined)
            url_ += "MobileFilter=" + encodeURIComponent("" + mobileFilter) + "&";
        if (emailFilter === null)
            throw new Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (cityNameFilter === null)
            throw new Error("The parameter 'cityNameFilter' cannot be null.");
        else if (cityNameFilter !== undefined)
            url_ += "CityNameFilter=" + encodeURIComponent("" + cityNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreLocationsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreLocationsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreLocationsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCityForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreLocationCityLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreLocations/GetAllCityForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCityForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCityForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreLocationCityLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreLocationCityLookupTableDto>;
        }));
    }

    protected processGetAllCityForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreLocationCityLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreLocationCityLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStateForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreLocationStateLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreLocations/GetAllStateForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStateForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStateForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreLocationStateLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreLocationStateLookupTableDto>;
        }));
    }

    protected processGetAllStateForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreLocationStateLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreLocationStateLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCountryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreLocationCountryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreLocations/GetAllCountryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreLocationCountryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreLocationCountryLookupTableDto>;
        }));
    }

    protected processGetAllCountryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreLocationCountryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreLocationCountryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreLocationStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreLocations/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreLocationStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreLocationStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreLocationStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreLocationStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreMarketplaceCommissionSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxPercentageFilter (optional) 
     * @param minPercentageFilter (optional) 
     * @param maxFixedAmountFilter (optional) 
     * @param minFixedAmountFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param marketplaceCommissionTypeNameFilter (optional) 
     * @param productCategoryNameFilter (optional) 
     * @param productNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxPercentageFilter: number | undefined, minPercentageFilter: number | undefined, maxFixedAmountFilter: number | undefined, minFixedAmountFilter: number | undefined, maxStartDateFilter: DateTime | undefined, minStartDateFilter: DateTime | undefined, maxEndDateFilter: DateTime | undefined, minEndDateFilter: DateTime | undefined, storeNameFilter: string | undefined, marketplaceCommissionTypeNameFilter: string | undefined, productCategoryNameFilter: string | undefined, productNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMarketplaceCommissionSettings/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxPercentageFilter === null)
            throw new Error("The parameter 'maxPercentageFilter' cannot be null.");
        else if (maxPercentageFilter !== undefined)
            url_ += "MaxPercentageFilter=" + encodeURIComponent("" + maxPercentageFilter) + "&";
        if (minPercentageFilter === null)
            throw new Error("The parameter 'minPercentageFilter' cannot be null.");
        else if (minPercentageFilter !== undefined)
            url_ += "MinPercentageFilter=" + encodeURIComponent("" + minPercentageFilter) + "&";
        if (maxFixedAmountFilter === null)
            throw new Error("The parameter 'maxFixedAmountFilter' cannot be null.");
        else if (maxFixedAmountFilter !== undefined)
            url_ += "MaxFixedAmountFilter=" + encodeURIComponent("" + maxFixedAmountFilter) + "&";
        if (minFixedAmountFilter === null)
            throw new Error("The parameter 'minFixedAmountFilter' cannot be null.");
        else if (minFixedAmountFilter !== undefined)
            url_ += "MinFixedAmountFilter=" + encodeURIComponent("" + minFixedAmountFilter) + "&";
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toString() : "") + "&";
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toString() : "") + "&";
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toString() : "") + "&";
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toString() : "") + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (marketplaceCommissionTypeNameFilter === null)
            throw new Error("The parameter 'marketplaceCommissionTypeNameFilter' cannot be null.");
        else if (marketplaceCommissionTypeNameFilter !== undefined)
            url_ += "MarketplaceCommissionTypeNameFilter=" + encodeURIComponent("" + marketplaceCommissionTypeNameFilter) + "&";
        if (productCategoryNameFilter === null)
            throw new Error("The parameter 'productCategoryNameFilter' cannot be null.");
        else if (productCategoryNameFilter !== undefined)
            url_ += "ProductCategoryNameFilter=" + encodeURIComponent("" + productCategoryNameFilter) + "&";
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreMarketplaceCommissionSettingForView(id: number | undefined): Observable<GetStoreMarketplaceCommissionSettingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMarketplaceCommissionSettings/GetStoreMarketplaceCommissionSettingForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreMarketplaceCommissionSettingForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreMarketplaceCommissionSettingForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreMarketplaceCommissionSettingForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreMarketplaceCommissionSettingForViewDto>;
        }));
    }

    protected processGetStoreMarketplaceCommissionSettingForView(response: HttpResponseBase): Observable<GetStoreMarketplaceCommissionSettingForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreMarketplaceCommissionSettingForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreMarketplaceCommissionSettingForEdit(id: number | undefined): Observable<GetStoreMarketplaceCommissionSettingForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreMarketplaceCommissionSettings/GetStoreMarketplaceCommissionSettingForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreMarketplaceCommissionSettingForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreMarketplaceCommissionSettingForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreMarketplaceCommissionSettingForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreMarketplaceCommissionSettingForEditOutput>;
        }));
    }

    protected processGetStoreMarketplaceCommissionSettingForEdit(response: HttpResponseBase): Observable<GetStoreMarketplaceCommissionSettingForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreMarketplaceCommissionSettingForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreMarketplaceCommissionSettingDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreMarketplaceCommissionSettings/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreMarketplaceCommissionSettings/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxPercentageFilter (optional) 
     * @param minPercentageFilter (optional) 
     * @param maxFixedAmountFilter (optional) 
     * @param minFixedAmountFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param marketplaceCommissionTypeNameFilter (optional) 
     * @param productCategoryNameFilter (optional) 
     * @param productNameFilter (optional) 
     * @return Success
     */
    getStoreMarketplaceCommissionSettingsToExcel(filter: string | undefined, maxPercentageFilter: number | undefined, minPercentageFilter: number | undefined, maxFixedAmountFilter: number | undefined, minFixedAmountFilter: number | undefined, maxStartDateFilter: DateTime | undefined, minStartDateFilter: DateTime | undefined, maxEndDateFilter: DateTime | undefined, minEndDateFilter: DateTime | undefined, storeNameFilter: string | undefined, marketplaceCommissionTypeNameFilter: string | undefined, productCategoryNameFilter: string | undefined, productNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMarketplaceCommissionSettings/GetStoreMarketplaceCommissionSettingsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxPercentageFilter === null)
            throw new Error("The parameter 'maxPercentageFilter' cannot be null.");
        else if (maxPercentageFilter !== undefined)
            url_ += "MaxPercentageFilter=" + encodeURIComponent("" + maxPercentageFilter) + "&";
        if (minPercentageFilter === null)
            throw new Error("The parameter 'minPercentageFilter' cannot be null.");
        else if (minPercentageFilter !== undefined)
            url_ += "MinPercentageFilter=" + encodeURIComponent("" + minPercentageFilter) + "&";
        if (maxFixedAmountFilter === null)
            throw new Error("The parameter 'maxFixedAmountFilter' cannot be null.");
        else if (maxFixedAmountFilter !== undefined)
            url_ += "MaxFixedAmountFilter=" + encodeURIComponent("" + maxFixedAmountFilter) + "&";
        if (minFixedAmountFilter === null)
            throw new Error("The parameter 'minFixedAmountFilter' cannot be null.");
        else if (minFixedAmountFilter !== undefined)
            url_ += "MinFixedAmountFilter=" + encodeURIComponent("" + minFixedAmountFilter) + "&";
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toString() : "") + "&";
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toString() : "") + "&";
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toString() : "") + "&";
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toString() : "") + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (marketplaceCommissionTypeNameFilter === null)
            throw new Error("The parameter 'marketplaceCommissionTypeNameFilter' cannot be null.");
        else if (marketplaceCommissionTypeNameFilter !== undefined)
            url_ += "MarketplaceCommissionTypeNameFilter=" + encodeURIComponent("" + marketplaceCommissionTypeNameFilter) + "&";
        if (productCategoryNameFilter === null)
            throw new Error("The parameter 'productCategoryNameFilter' cannot be null.");
        else if (productCategoryNameFilter !== undefined)
            url_ += "ProductCategoryNameFilter=" + encodeURIComponent("" + productCategoryNameFilter) + "&";
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreMarketplaceCommissionSettingsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreMarketplaceCommissionSettingsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreMarketplaceCommissionSettingsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMarketplaceCommissionSettings/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMarketplaceCommissionTypeForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMarketplaceCommissionSettings/GetAllMarketplaceCommissionTypeForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMarketplaceCommissionTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMarketplaceCommissionTypeForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto>;
        }));
    }

    protected processGetAllMarketplaceCommissionTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMarketplaceCommissionSettings/GetAllProductCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto>;
        }));
    }

    protected processGetAllProductCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMarketplaceCommissionSettings/GetAllProductForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto>;
        }));
    }

    protected processGetAllProductForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreMediasServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, storeNameFilter: string | undefined, mediaLibraryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreMediaForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMedias/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreMediaForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreMediaForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreMediaForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreMediaForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreMediaForView(id: number | undefined): Observable<GetStoreMediaForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMedias/GetStoreMediaForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreMediaForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreMediaForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreMediaForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreMediaForViewDto>;
        }));
    }

    protected processGetStoreMediaForView(response: HttpResponseBase): Observable<GetStoreMediaForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreMediaForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreMediaForEdit(id: number | undefined): Observable<GetStoreMediaForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreMedias/GetStoreMediaForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreMediaForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreMediaForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreMediaForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreMediaForEditOutput>;
        }));
    }

    protected processGetStoreMediaForEdit(response: HttpResponseBase): Observable<GetStoreMediaForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreMediaForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreMediaDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreMedias/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreMedias/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @return Success
     */
    getStoreMediasToExcel(filter: string | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, storeNameFilter: string | undefined, mediaLibraryNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMedias/GetStoreMediasToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreMediasToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreMediasToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreMediasToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreMediaStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMedias/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreMediaStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreMediaStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreMediaStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreMediaStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMediaLibraryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreMediaMediaLibraryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreMedias/GetAllMediaLibraryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMediaLibraryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMediaLibraryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreMediaMediaLibraryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreMediaMediaLibraryLookupTableDto>;
        }));
    }

    protected processGetAllMediaLibraryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreMediaMediaLibraryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreMediaMediaLibraryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreNotesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param notesFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, notesFilter: string | undefined, storeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreNoteForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreNotes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (notesFilter === null)
            throw new Error("The parameter 'notesFilter' cannot be null.");
        else if (notesFilter !== undefined)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreNoteForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreNoteForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreNoteForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreNoteForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreNoteForView(id: number | undefined): Observable<GetStoreNoteForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreNotes/GetStoreNoteForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreNoteForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreNoteForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreNoteForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreNoteForViewDto>;
        }));
    }

    protected processGetStoreNoteForView(response: HttpResponseBase): Observable<GetStoreNoteForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreNoteForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreNoteForEdit(id: number | undefined): Observable<GetStoreNoteForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreNotes/GetStoreNoteForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreNoteForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreNoteForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreNoteForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreNoteForEditOutput>;
        }));
    }

    protected processGetStoreNoteForEdit(response: HttpResponseBase): Observable<GetStoreNoteForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreNoteForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreNoteDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreNotes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreNotes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param notesFilter (optional) 
     * @param storeNameFilter (optional) 
     * @return Success
     */
    getStoreNotesToExcel(filter: string | undefined, notesFilter: string | undefined, storeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreNotes/GetStoreNotesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (notesFilter === null)
            throw new Error("The parameter 'notesFilter' cannot be null.");
        else if (notesFilter !== undefined)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreNotesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreNotesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreNotesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreNoteStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreNotes/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreNoteStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreNoteStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreNoteStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreNoteStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreOwnerTeamsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param activeFilter (optional) 
     * @param primaryFilter (optional) 
     * @param orderEmailNotificationFilter (optional) 
     * @param orderSmsNotificationFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, activeFilter: number | undefined, primaryFilter: number | undefined, orderEmailNotificationFilter: number | undefined, orderSmsNotificationFilter: number | undefined, storeNameFilter: string | undefined, userNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreOwnerTeamForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreOwnerTeams/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (activeFilter === null)
            throw new Error("The parameter 'activeFilter' cannot be null.");
        else if (activeFilter !== undefined)
            url_ += "ActiveFilter=" + encodeURIComponent("" + activeFilter) + "&";
        if (primaryFilter === null)
            throw new Error("The parameter 'primaryFilter' cannot be null.");
        else if (primaryFilter !== undefined)
            url_ += "PrimaryFilter=" + encodeURIComponent("" + primaryFilter) + "&";
        if (orderEmailNotificationFilter === null)
            throw new Error("The parameter 'orderEmailNotificationFilter' cannot be null.");
        else if (orderEmailNotificationFilter !== undefined)
            url_ += "OrderEmailNotificationFilter=" + encodeURIComponent("" + orderEmailNotificationFilter) + "&";
        if (orderSmsNotificationFilter === null)
            throw new Error("The parameter 'orderSmsNotificationFilter' cannot be null.");
        else if (orderSmsNotificationFilter !== undefined)
            url_ += "OrderSmsNotificationFilter=" + encodeURIComponent("" + orderSmsNotificationFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreOwnerTeamForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreOwnerTeamForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreOwnerTeamForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreOwnerTeamForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreOwnerTeamForView(id: number | undefined): Observable<GetStoreOwnerTeamForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreOwnerTeams/GetStoreOwnerTeamForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreOwnerTeamForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreOwnerTeamForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreOwnerTeamForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreOwnerTeamForViewDto>;
        }));
    }

    protected processGetStoreOwnerTeamForView(response: HttpResponseBase): Observable<GetStoreOwnerTeamForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreOwnerTeamForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreOwnerTeamForEdit(id: number | undefined): Observable<GetStoreOwnerTeamForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreOwnerTeams/GetStoreOwnerTeamForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreOwnerTeamForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreOwnerTeamForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreOwnerTeamForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreOwnerTeamForEditOutput>;
        }));
    }

    protected processGetStoreOwnerTeamForEdit(response: HttpResponseBase): Observable<GetStoreOwnerTeamForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreOwnerTeamForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreOwnerTeamDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreOwnerTeams/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreOwnerTeams/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param activeFilter (optional) 
     * @param primaryFilter (optional) 
     * @param orderEmailNotificationFilter (optional) 
     * @param orderSmsNotificationFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @return Success
     */
    getStoreOwnerTeamsToExcel(filter: string | undefined, activeFilter: number | undefined, primaryFilter: number | undefined, orderEmailNotificationFilter: number | undefined, orderSmsNotificationFilter: number | undefined, storeNameFilter: string | undefined, userNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreOwnerTeams/GetStoreOwnerTeamsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (activeFilter === null)
            throw new Error("The parameter 'activeFilter' cannot be null.");
        else if (activeFilter !== undefined)
            url_ += "ActiveFilter=" + encodeURIComponent("" + activeFilter) + "&";
        if (primaryFilter === null)
            throw new Error("The parameter 'primaryFilter' cannot be null.");
        else if (primaryFilter !== undefined)
            url_ += "PrimaryFilter=" + encodeURIComponent("" + primaryFilter) + "&";
        if (orderEmailNotificationFilter === null)
            throw new Error("The parameter 'orderEmailNotificationFilter' cannot be null.");
        else if (orderEmailNotificationFilter !== undefined)
            url_ += "OrderEmailNotificationFilter=" + encodeURIComponent("" + orderEmailNotificationFilter) + "&";
        if (orderSmsNotificationFilter === null)
            throw new Error("The parameter 'orderSmsNotificationFilter' cannot be null.");
        else if (orderSmsNotificationFilter !== undefined)
            url_ += "OrderSmsNotificationFilter=" + encodeURIComponent("" + orderSmsNotificationFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreOwnerTeamsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreOwnerTeamsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreOwnerTeamsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreOwnerTeamStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreOwnerTeams/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreOwnerTeamStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreOwnerTeamStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreOwnerTeamStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreOwnerTeamStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreOwnerTeamUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreOwnerTeams/GetAllUserForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreOwnerTeamUserLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreOwnerTeamUserLookupTableDto>;
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreOwnerTeamUserLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreOwnerTeamUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreProductCategoryMapsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param publishedFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param productCategoryNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, publishedFilter: number | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, storeNameFilter: string | undefined, productCategoryNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreProductCategoryMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductCategoryMaps/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (publishedFilter === null)
            throw new Error("The parameter 'publishedFilter' cannot be null.");
        else if (publishedFilter !== undefined)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (productCategoryNameFilter === null)
            throw new Error("The parameter 'productCategoryNameFilter' cannot be null.");
        else if (productCategoryNameFilter !== undefined)
            url_ += "ProductCategoryNameFilter=" + encodeURIComponent("" + productCategoryNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreProductCategoryMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreProductCategoryMapForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreProductCategoryMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreProductCategoryMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreProductCategoryMapForView(id: number | undefined): Observable<GetStoreProductCategoryMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductCategoryMaps/GetStoreProductCategoryMapForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreProductCategoryMapForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreProductCategoryMapForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreProductCategoryMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreProductCategoryMapForViewDto>;
        }));
    }

    protected processGetStoreProductCategoryMapForView(response: HttpResponseBase): Observable<GetStoreProductCategoryMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreProductCategoryMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreProductCategoryMapForEdit(id: number | undefined): Observable<GetStoreProductCategoryMapForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductCategoryMaps/GetStoreProductCategoryMapForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreProductCategoryMapForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreProductCategoryMapForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreProductCategoryMapForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreProductCategoryMapForEditOutput>;
        }));
    }

    protected processGetStoreProductCategoryMapForEdit(response: HttpResponseBase): Observable<GetStoreProductCategoryMapForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreProductCategoryMapForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreProductCategoryMapDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductCategoryMaps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductCategoryMaps/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param publishedFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param productCategoryNameFilter (optional) 
     * @return Success
     */
    getStoreProductCategoryMapsToExcel(filter: string | undefined, publishedFilter: number | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, storeNameFilter: string | undefined, productCategoryNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductCategoryMaps/GetStoreProductCategoryMapsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (publishedFilter === null)
            throw new Error("The parameter 'publishedFilter' cannot be null.");
        else if (publishedFilter !== undefined)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (productCategoryNameFilter === null)
            throw new Error("The parameter 'productCategoryNameFilter' cannot be null.");
        else if (productCategoryNameFilter !== undefined)
            url_ += "ProductCategoryNameFilter=" + encodeURIComponent("" + productCategoryNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreProductCategoryMapsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreProductCategoryMapsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreProductCategoryMapsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductCategoryMaps/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductCategoryMaps/GetAllProductCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto>;
        }));
    }

    protected processGetAllProductCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreProductMapsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param publishedFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param productNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, publishedFilter: number | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, storeNameFilter: string | undefined, productNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreProductMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductMaps/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (publishedFilter === null)
            throw new Error("The parameter 'publishedFilter' cannot be null.");
        else if (publishedFilter !== undefined)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreProductMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreProductMapForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreProductMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreProductMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreProductMapForView(id: number | undefined): Observable<GetStoreProductMapForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductMaps/GetStoreProductMapForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreProductMapForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreProductMapForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreProductMapForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreProductMapForViewDto>;
        }));
    }

    protected processGetStoreProductMapForView(response: HttpResponseBase): Observable<GetStoreProductMapForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreProductMapForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreProductMapForEdit(id: number | undefined): Observable<GetStoreProductMapForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductMaps/GetStoreProductMapForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreProductMapForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreProductMapForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreProductMapForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreProductMapForEditOutput>;
        }));
    }

    protected processGetStoreProductMapForEdit(response: HttpResponseBase): Observable<GetStoreProductMapForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreProductMapForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreProductMapDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductMaps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductMaps/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param publishedFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param productNameFilter (optional) 
     * @return Success
     */
    getStoreProductMapsToExcel(filter: string | undefined, publishedFilter: number | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, storeNameFilter: string | undefined, productNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductMaps/GetStoreProductMapsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (publishedFilter === null)
            throw new Error("The parameter 'publishedFilter' cannot be null.");
        else if (publishedFilter !== undefined)
            url_ += "PublishedFilter=" + encodeURIComponent("" + publishedFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (productNameFilter === null)
            throw new Error("The parameter 'productNameFilter' cannot be null.");
        else if (productNameFilter !== undefined)
            url_ += "ProductNameFilter=" + encodeURIComponent("" + productNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreProductMapsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreProductMapsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreProductMapsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreProductMapStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductMaps/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreProductMapStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreProductMapStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreProductMapStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreProductMapStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProductForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreProductMapProductLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreProductMaps/GetAllProductForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreProductMapProductLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreProductMapProductLookupTableDto>;
        }));
    }

    protected processGetAllProductForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreProductMapProductLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreProductMapProductLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param storeUrlFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param metaTagFilter (optional) 
     * @param metaDescriptionFilter (optional) 
     * @param fullAddressFilter (optional) 
     * @param addressFilter (optional) 
     * @param cityFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param phoneFilter (optional) 
     * @param mobileFilter (optional) 
     * @param emailFilter (optional) 
     * @param isPublishedFilter (optional) 
     * @param facebookFilter (optional) 
     * @param instagramFilter (optional) 
     * @param linkedInFilter (optional) 
     * @param youtubeFilter (optional) 
     * @param faxFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param websiteFilter (optional) 
     * @param yearOfEstablishmentFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param maxScoreFilter (optional) 
     * @param minScoreFilter (optional) 
     * @param legalNameFilter (optional) 
     * @param isLocalOrOnlineStoreFilter (optional) 
     * @param isVerifiedFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param ratingLikeNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, storeUrlFilter: string | undefined, descriptionFilter: string | undefined, metaTagFilter: string | undefined, metaDescriptionFilter: string | undefined, fullAddressFilter: string | undefined, addressFilter: string | undefined, cityFilter: string | undefined, maxLatitudeFilter: number | undefined, minLatitudeFilter: number | undefined, maxLongitudeFilter: number | undefined, minLongitudeFilter: number | undefined, phoneFilter: string | undefined, mobileFilter: string | undefined, emailFilter: string | undefined, isPublishedFilter: number | undefined, facebookFilter: string | undefined, instagramFilter: string | undefined, linkedInFilter: string | undefined, youtubeFilter: string | undefined, faxFilter: string | undefined, zipCodeFilter: string | undefined, websiteFilter: string | undefined, yearOfEstablishmentFilter: string | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, maxScoreFilter: number | undefined, minScoreFilter: number | undefined, legalNameFilter: string | undefined, isLocalOrOnlineStoreFilter: number | undefined, isVerifiedFilter: number | undefined, mediaLibraryNameFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, ratingLikeNameFilter: string | undefined, masterTagNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Stores/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (storeUrlFilter === null)
            throw new Error("The parameter 'storeUrlFilter' cannot be null.");
        else if (storeUrlFilter !== undefined)
            url_ += "StoreUrlFilter=" + encodeURIComponent("" + storeUrlFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (metaTagFilter === null)
            throw new Error("The parameter 'metaTagFilter' cannot be null.");
        else if (metaTagFilter !== undefined)
            url_ += "MetaTagFilter=" + encodeURIComponent("" + metaTagFilter) + "&";
        if (metaDescriptionFilter === null)
            throw new Error("The parameter 'metaDescriptionFilter' cannot be null.");
        else if (metaDescriptionFilter !== undefined)
            url_ += "MetaDescriptionFilter=" + encodeURIComponent("" + metaDescriptionFilter) + "&";
        if (fullAddressFilter === null)
            throw new Error("The parameter 'fullAddressFilter' cannot be null.");
        else if (fullAddressFilter !== undefined)
            url_ += "FullAddressFilter=" + encodeURIComponent("" + fullAddressFilter) + "&";
        if (addressFilter === null)
            throw new Error("The parameter 'addressFilter' cannot be null.");
        else if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (maxLatitudeFilter === null)
            throw new Error("The parameter 'maxLatitudeFilter' cannot be null.");
        else if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&";
        if (minLatitudeFilter === null)
            throw new Error("The parameter 'minLatitudeFilter' cannot be null.");
        else if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&";
        if (maxLongitudeFilter === null)
            throw new Error("The parameter 'maxLongitudeFilter' cannot be null.");
        else if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&";
        if (minLongitudeFilter === null)
            throw new Error("The parameter 'minLongitudeFilter' cannot be null.");
        else if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&";
        if (phoneFilter === null)
            throw new Error("The parameter 'phoneFilter' cannot be null.");
        else if (phoneFilter !== undefined)
            url_ += "PhoneFilter=" + encodeURIComponent("" + phoneFilter) + "&";
        if (mobileFilter === null)
            throw new Error("The parameter 'mobileFilter' cannot be null.");
        else if (mobileFilter !== undefined)
            url_ += "MobileFilter=" + encodeURIComponent("" + mobileFilter) + "&";
        if (emailFilter === null)
            throw new Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&";
        if (isPublishedFilter === null)
            throw new Error("The parameter 'isPublishedFilter' cannot be null.");
        else if (isPublishedFilter !== undefined)
            url_ += "IsPublishedFilter=" + encodeURIComponent("" + isPublishedFilter) + "&";
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&";
        if (instagramFilter === null)
            throw new Error("The parameter 'instagramFilter' cannot be null.");
        else if (instagramFilter !== undefined)
            url_ += "InstagramFilter=" + encodeURIComponent("" + instagramFilter) + "&";
        if (linkedInFilter === null)
            throw new Error("The parameter 'linkedInFilter' cannot be null.");
        else if (linkedInFilter !== undefined)
            url_ += "LinkedInFilter=" + encodeURIComponent("" + linkedInFilter) + "&";
        if (youtubeFilter === null)
            throw new Error("The parameter 'youtubeFilter' cannot be null.");
        else if (youtubeFilter !== undefined)
            url_ += "YoutubeFilter=" + encodeURIComponent("" + youtubeFilter) + "&";
        if (faxFilter === null)
            throw new Error("The parameter 'faxFilter' cannot be null.");
        else if (faxFilter !== undefined)
            url_ += "FaxFilter=" + encodeURIComponent("" + faxFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (websiteFilter === null)
            throw new Error("The parameter 'websiteFilter' cannot be null.");
        else if (websiteFilter !== undefined)
            url_ += "WebsiteFilter=" + encodeURIComponent("" + websiteFilter) + "&";
        if (yearOfEstablishmentFilter === null)
            throw new Error("The parameter 'yearOfEstablishmentFilter' cannot be null.");
        else if (yearOfEstablishmentFilter !== undefined)
            url_ += "YearOfEstablishmentFilter=" + encodeURIComponent("" + yearOfEstablishmentFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (maxScoreFilter === null)
            throw new Error("The parameter 'maxScoreFilter' cannot be null.");
        else if (maxScoreFilter !== undefined)
            url_ += "MaxScoreFilter=" + encodeURIComponent("" + maxScoreFilter) + "&";
        if (minScoreFilter === null)
            throw new Error("The parameter 'minScoreFilter' cannot be null.");
        else if (minScoreFilter !== undefined)
            url_ += "MinScoreFilter=" + encodeURIComponent("" + minScoreFilter) + "&";
        if (legalNameFilter === null)
            throw new Error("The parameter 'legalNameFilter' cannot be null.");
        else if (legalNameFilter !== undefined)
            url_ += "LegalNameFilter=" + encodeURIComponent("" + legalNameFilter) + "&";
        if (isLocalOrOnlineStoreFilter === null)
            throw new Error("The parameter 'isLocalOrOnlineStoreFilter' cannot be null.");
        else if (isLocalOrOnlineStoreFilter !== undefined)
            url_ += "IsLocalOrOnlineStoreFilter=" + encodeURIComponent("" + isLocalOrOnlineStoreFilter) + "&";
        if (isVerifiedFilter === null)
            throw new Error("The parameter 'isVerifiedFilter' cannot be null.");
        else if (isVerifiedFilter !== undefined)
            url_ += "IsVerifiedFilter=" + encodeURIComponent("" + isVerifiedFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (ratingLikeNameFilter === null)
            throw new Error("The parameter 'ratingLikeNameFilter' cannot be null.");
        else if (ratingLikeNameFilter !== undefined)
            url_ += "RatingLikeNameFilter=" + encodeURIComponent("" + ratingLikeNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreForView(id: number | undefined): Observable<GetStoreForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Stores/GetStoreForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreForViewDto>;
        }));
    }

    protected processGetStoreForView(response: HttpResponseBase): Observable<GetStoreForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreForEdit(id: number | undefined): Observable<GetStoreForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Stores/GetStoreForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreForEditOutput>;
        }));
    }

    protected processGetStoreForEdit(response: HttpResponseBase): Observable<GetStoreForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Stores/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Stores/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param storeUrlFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param metaTagFilter (optional) 
     * @param metaDescriptionFilter (optional) 
     * @param fullAddressFilter (optional) 
     * @param addressFilter (optional) 
     * @param cityFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param phoneFilter (optional) 
     * @param mobileFilter (optional) 
     * @param emailFilter (optional) 
     * @param isPublishedFilter (optional) 
     * @param facebookFilter (optional) 
     * @param instagramFilter (optional) 
     * @param linkedInFilter (optional) 
     * @param youtubeFilter (optional) 
     * @param faxFilter (optional) 
     * @param zipCodeFilter (optional) 
     * @param websiteFilter (optional) 
     * @param yearOfEstablishmentFilter (optional) 
     * @param maxDisplaySequenceFilter (optional) 
     * @param minDisplaySequenceFilter (optional) 
     * @param maxScoreFilter (optional) 
     * @param minScoreFilter (optional) 
     * @param legalNameFilter (optional) 
     * @param isLocalOrOnlineStoreFilter (optional) 
     * @param isVerifiedFilter (optional) 
     * @param mediaLibraryNameFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param ratingLikeNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @return Success
     */
    getStoresToExcel(filter: string | undefined, nameFilter: string | undefined, storeUrlFilter: string | undefined, descriptionFilter: string | undefined, metaTagFilter: string | undefined, metaDescriptionFilter: string | undefined, fullAddressFilter: string | undefined, addressFilter: string | undefined, cityFilter: string | undefined, maxLatitudeFilter: number | undefined, minLatitudeFilter: number | undefined, maxLongitudeFilter: number | undefined, minLongitudeFilter: number | undefined, phoneFilter: string | undefined, mobileFilter: string | undefined, emailFilter: string | undefined, isPublishedFilter: number | undefined, facebookFilter: string | undefined, instagramFilter: string | undefined, linkedInFilter: string | undefined, youtubeFilter: string | undefined, faxFilter: string | undefined, zipCodeFilter: string | undefined, websiteFilter: string | undefined, yearOfEstablishmentFilter: string | undefined, maxDisplaySequenceFilter: number | undefined, minDisplaySequenceFilter: number | undefined, maxScoreFilter: number | undefined, minScoreFilter: number | undefined, legalNameFilter: string | undefined, isLocalOrOnlineStoreFilter: number | undefined, isVerifiedFilter: number | undefined, mediaLibraryNameFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, ratingLikeNameFilter: string | undefined, masterTagNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Stores/GetStoresToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (storeUrlFilter === null)
            throw new Error("The parameter 'storeUrlFilter' cannot be null.");
        else if (storeUrlFilter !== undefined)
            url_ += "StoreUrlFilter=" + encodeURIComponent("" + storeUrlFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (metaTagFilter === null)
            throw new Error("The parameter 'metaTagFilter' cannot be null.");
        else if (metaTagFilter !== undefined)
            url_ += "MetaTagFilter=" + encodeURIComponent("" + metaTagFilter) + "&";
        if (metaDescriptionFilter === null)
            throw new Error("The parameter 'metaDescriptionFilter' cannot be null.");
        else if (metaDescriptionFilter !== undefined)
            url_ += "MetaDescriptionFilter=" + encodeURIComponent("" + metaDescriptionFilter) + "&";
        if (fullAddressFilter === null)
            throw new Error("The parameter 'fullAddressFilter' cannot be null.");
        else if (fullAddressFilter !== undefined)
            url_ += "FullAddressFilter=" + encodeURIComponent("" + fullAddressFilter) + "&";
        if (addressFilter === null)
            throw new Error("The parameter 'addressFilter' cannot be null.");
        else if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (maxLatitudeFilter === null)
            throw new Error("The parameter 'maxLatitudeFilter' cannot be null.");
        else if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&";
        if (minLatitudeFilter === null)
            throw new Error("The parameter 'minLatitudeFilter' cannot be null.");
        else if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&";
        if (maxLongitudeFilter === null)
            throw new Error("The parameter 'maxLongitudeFilter' cannot be null.");
        else if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&";
        if (minLongitudeFilter === null)
            throw new Error("The parameter 'minLongitudeFilter' cannot be null.");
        else if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&";
        if (phoneFilter === null)
            throw new Error("The parameter 'phoneFilter' cannot be null.");
        else if (phoneFilter !== undefined)
            url_ += "PhoneFilter=" + encodeURIComponent("" + phoneFilter) + "&";
        if (mobileFilter === null)
            throw new Error("The parameter 'mobileFilter' cannot be null.");
        else if (mobileFilter !== undefined)
            url_ += "MobileFilter=" + encodeURIComponent("" + mobileFilter) + "&";
        if (emailFilter === null)
            throw new Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&";
        if (isPublishedFilter === null)
            throw new Error("The parameter 'isPublishedFilter' cannot be null.");
        else if (isPublishedFilter !== undefined)
            url_ += "IsPublishedFilter=" + encodeURIComponent("" + isPublishedFilter) + "&";
        if (facebookFilter === null)
            throw new Error("The parameter 'facebookFilter' cannot be null.");
        else if (facebookFilter !== undefined)
            url_ += "FacebookFilter=" + encodeURIComponent("" + facebookFilter) + "&";
        if (instagramFilter === null)
            throw new Error("The parameter 'instagramFilter' cannot be null.");
        else if (instagramFilter !== undefined)
            url_ += "InstagramFilter=" + encodeURIComponent("" + instagramFilter) + "&";
        if (linkedInFilter === null)
            throw new Error("The parameter 'linkedInFilter' cannot be null.");
        else if (linkedInFilter !== undefined)
            url_ += "LinkedInFilter=" + encodeURIComponent("" + linkedInFilter) + "&";
        if (youtubeFilter === null)
            throw new Error("The parameter 'youtubeFilter' cannot be null.");
        else if (youtubeFilter !== undefined)
            url_ += "YoutubeFilter=" + encodeURIComponent("" + youtubeFilter) + "&";
        if (faxFilter === null)
            throw new Error("The parameter 'faxFilter' cannot be null.");
        else if (faxFilter !== undefined)
            url_ += "FaxFilter=" + encodeURIComponent("" + faxFilter) + "&";
        if (zipCodeFilter === null)
            throw new Error("The parameter 'zipCodeFilter' cannot be null.");
        else if (zipCodeFilter !== undefined)
            url_ += "ZipCodeFilter=" + encodeURIComponent("" + zipCodeFilter) + "&";
        if (websiteFilter === null)
            throw new Error("The parameter 'websiteFilter' cannot be null.");
        else if (websiteFilter !== undefined)
            url_ += "WebsiteFilter=" + encodeURIComponent("" + websiteFilter) + "&";
        if (yearOfEstablishmentFilter === null)
            throw new Error("The parameter 'yearOfEstablishmentFilter' cannot be null.");
        else if (yearOfEstablishmentFilter !== undefined)
            url_ += "YearOfEstablishmentFilter=" + encodeURIComponent("" + yearOfEstablishmentFilter) + "&";
        if (maxDisplaySequenceFilter === null)
            throw new Error("The parameter 'maxDisplaySequenceFilter' cannot be null.");
        else if (maxDisplaySequenceFilter !== undefined)
            url_ += "MaxDisplaySequenceFilter=" + encodeURIComponent("" + maxDisplaySequenceFilter) + "&";
        if (minDisplaySequenceFilter === null)
            throw new Error("The parameter 'minDisplaySequenceFilter' cannot be null.");
        else if (minDisplaySequenceFilter !== undefined)
            url_ += "MinDisplaySequenceFilter=" + encodeURIComponent("" + minDisplaySequenceFilter) + "&";
        if (maxScoreFilter === null)
            throw new Error("The parameter 'maxScoreFilter' cannot be null.");
        else if (maxScoreFilter !== undefined)
            url_ += "MaxScoreFilter=" + encodeURIComponent("" + maxScoreFilter) + "&";
        if (minScoreFilter === null)
            throw new Error("The parameter 'minScoreFilter' cannot be null.");
        else if (minScoreFilter !== undefined)
            url_ += "MinScoreFilter=" + encodeURIComponent("" + minScoreFilter) + "&";
        if (legalNameFilter === null)
            throw new Error("The parameter 'legalNameFilter' cannot be null.");
        else if (legalNameFilter !== undefined)
            url_ += "LegalNameFilter=" + encodeURIComponent("" + legalNameFilter) + "&";
        if (isLocalOrOnlineStoreFilter === null)
            throw new Error("The parameter 'isLocalOrOnlineStoreFilter' cannot be null.");
        else if (isLocalOrOnlineStoreFilter !== undefined)
            url_ += "IsLocalOrOnlineStoreFilter=" + encodeURIComponent("" + isLocalOrOnlineStoreFilter) + "&";
        if (isVerifiedFilter === null)
            throw new Error("The parameter 'isVerifiedFilter' cannot be null.");
        else if (isVerifiedFilter !== undefined)
            url_ += "IsVerifiedFilter=" + encodeURIComponent("" + isVerifiedFilter) + "&";
        if (mediaLibraryNameFilter === null)
            throw new Error("The parameter 'mediaLibraryNameFilter' cannot be null.");
        else if (mediaLibraryNameFilter !== undefined)
            url_ += "MediaLibraryNameFilter=" + encodeURIComponent("" + mediaLibraryNameFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (ratingLikeNameFilter === null)
            throw new Error("The parameter 'ratingLikeNameFilter' cannot be null.");
        else if (ratingLikeNameFilter !== undefined)
            url_ += "RatingLikeNameFilter=" + encodeURIComponent("" + ratingLikeNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoresToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoresToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoresToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMediaLibraryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreMediaLibraryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Stores/GetAllMediaLibraryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMediaLibraryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMediaLibraryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreMediaLibraryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreMediaLibraryLookupTableDto>;
        }));
    }

    protected processGetAllMediaLibraryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreMediaLibraryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreMediaLibraryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountryForTableDropdown(): Observable<StoreCountryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Stores/GetAllCountryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreCountryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreCountryLookupTableDto[]>;
        }));
    }

    protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<StoreCountryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreCountryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllStateForTableDropdown(): Observable<StoreStateLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Stores/GetAllStateForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStateForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStateForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreStateLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreStateLookupTableDto[]>;
        }));
    }

    protected processGetAllStateForTableDropdown(response: HttpResponseBase): Observable<StoreStateLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreStateLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllRatingLikeForTableDropdown(): Observable<StoreRatingLikeLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Stores/GetAllRatingLikeForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRatingLikeForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRatingLikeForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StoreRatingLikeLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StoreRatingLikeLookupTableDto[]>;
        }));
    }

    protected processGetAllRatingLikeForTableDropdown(response: HttpResponseBase): Observable<StoreRatingLikeLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StoreRatingLikeLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Stores/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreSalesAlertsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param messageFilter (optional) 
     * @param currentFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, messageFilter: string | undefined, currentFilter: number | undefined, maxStartDateFilter: DateTime | undefined, minStartDateFilter: DateTime | undefined, maxEndDateFilter: DateTime | undefined, minEndDateFilter: DateTime | undefined, storeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreSalesAlertForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreSalesAlerts/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (messageFilter === null)
            throw new Error("The parameter 'messageFilter' cannot be null.");
        else if (messageFilter !== undefined)
            url_ += "MessageFilter=" + encodeURIComponent("" + messageFilter) + "&";
        if (currentFilter === null)
            throw new Error("The parameter 'currentFilter' cannot be null.");
        else if (currentFilter !== undefined)
            url_ += "CurrentFilter=" + encodeURIComponent("" + currentFilter) + "&";
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toString() : "") + "&";
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toString() : "") + "&";
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toString() : "") + "&";
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toString() : "") + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreSalesAlertForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreSalesAlertForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreSalesAlertForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreSalesAlertForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreSalesAlertForView(id: number | undefined): Observable<GetStoreSalesAlertForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreSalesAlerts/GetStoreSalesAlertForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreSalesAlertForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreSalesAlertForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreSalesAlertForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreSalesAlertForViewDto>;
        }));
    }

    protected processGetStoreSalesAlertForView(response: HttpResponseBase): Observable<GetStoreSalesAlertForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreSalesAlertForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreSalesAlertForEdit(id: number | undefined): Observable<GetStoreSalesAlertForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreSalesAlerts/GetStoreSalesAlertForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreSalesAlertForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreSalesAlertForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreSalesAlertForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreSalesAlertForEditOutput>;
        }));
    }

    protected processGetStoreSalesAlertForEdit(response: HttpResponseBase): Observable<GetStoreSalesAlertForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreSalesAlertForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreSalesAlertDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreSalesAlerts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreSalesAlerts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param messageFilter (optional) 
     * @param currentFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param storeNameFilter (optional) 
     * @return Success
     */
    getStoreSalesAlertsToExcel(filter: string | undefined, messageFilter: string | undefined, currentFilter: number | undefined, maxStartDateFilter: DateTime | undefined, minStartDateFilter: DateTime | undefined, maxEndDateFilter: DateTime | undefined, minEndDateFilter: DateTime | undefined, storeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreSalesAlerts/GetStoreSalesAlertsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (messageFilter === null)
            throw new Error("The parameter 'messageFilter' cannot be null.");
        else if (messageFilter !== undefined)
            url_ += "MessageFilter=" + encodeURIComponent("" + messageFilter) + "&";
        if (currentFilter === null)
            throw new Error("The parameter 'currentFilter' cannot be null.");
        else if (currentFilter !== undefined)
            url_ += "CurrentFilter=" + encodeURIComponent("" + currentFilter) + "&";
        if (maxStartDateFilter === null)
            throw new Error("The parameter 'maxStartDateFilter' cannot be null.");
        else if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toString() : "") + "&";
        if (minStartDateFilter === null)
            throw new Error("The parameter 'minStartDateFilter' cannot be null.");
        else if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toString() : "") + "&";
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toString() : "") + "&";
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toString() : "") + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreSalesAlertsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreSalesAlertsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreSalesAlertsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreSalesAlertStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreSalesAlerts/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreSalesAlertStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreSalesAlertStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreSalesAlertStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreSalesAlertStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, storeNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreTags/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreTagForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreTagForView(id: number | undefined): Observable<GetStoreTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreTags/GetStoreTagForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreTagForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreTagForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreTagForViewDto>;
        }));
    }

    protected processGetStoreTagForView(response: HttpResponseBase): Observable<GetStoreTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreTagForEdit(id: number | undefined): Observable<GetStoreTagForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreTags/GetStoreTagForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreTagForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreTagForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreTagForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreTagForEditOutput>;
        }));
    }

    protected processGetStoreTagForEdit(response: HttpResponseBase): Observable<GetStoreTagForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreTagForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreTagDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreTags/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreTags/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verifiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @return Success
     */
    getStoreTagsToExcel(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verifiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, storeNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreTags/GetStoreTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verifiedFilter === null)
            throw new Error("The parameter 'verifiedFilter' cannot be null.");
        else if (verifiedFilter !== undefined)
            url_ += "VerifiedFilter=" + encodeURIComponent("" + verifiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreTagsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreTagsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreTagStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreTags/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreTagStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreTagStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreTagStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreTagStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreTags/GetAllMasterTagCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreTagMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreTags/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreTagMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreTagMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreTagMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreTagMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StoreTaxesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param taxNameFilter (optional) 
     * @param percentageOrAmountFilter (optional) 
     * @param maxTaxRatePercentageFilter (optional) 
     * @param minTaxRatePercentageFilter (optional) 
     * @param maxTaxAmountFilter (optional) 
     * @param minTaxAmountFilter (optional) 
     * @param storeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, taxNameFilter: string | undefined, percentageOrAmountFilter: number | undefined, maxTaxRatePercentageFilter: number | undefined, minTaxRatePercentageFilter: number | undefined, maxTaxAmountFilter: number | undefined, minTaxAmountFilter: number | undefined, storeNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetStoreTaxForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreTaxes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (taxNameFilter === null)
            throw new Error("The parameter 'taxNameFilter' cannot be null.");
        else if (taxNameFilter !== undefined)
            url_ += "TaxNameFilter=" + encodeURIComponent("" + taxNameFilter) + "&";
        if (percentageOrAmountFilter === null)
            throw new Error("The parameter 'percentageOrAmountFilter' cannot be null.");
        else if (percentageOrAmountFilter !== undefined)
            url_ += "PercentageOrAmountFilter=" + encodeURIComponent("" + percentageOrAmountFilter) + "&";
        if (maxTaxRatePercentageFilter === null)
            throw new Error("The parameter 'maxTaxRatePercentageFilter' cannot be null.");
        else if (maxTaxRatePercentageFilter !== undefined)
            url_ += "MaxTaxRatePercentageFilter=" + encodeURIComponent("" + maxTaxRatePercentageFilter) + "&";
        if (minTaxRatePercentageFilter === null)
            throw new Error("The parameter 'minTaxRatePercentageFilter' cannot be null.");
        else if (minTaxRatePercentageFilter !== undefined)
            url_ += "MinTaxRatePercentageFilter=" + encodeURIComponent("" + minTaxRatePercentageFilter) + "&";
        if (maxTaxAmountFilter === null)
            throw new Error("The parameter 'maxTaxAmountFilter' cannot be null.");
        else if (maxTaxAmountFilter !== undefined)
            url_ += "MaxTaxAmountFilter=" + encodeURIComponent("" + maxTaxAmountFilter) + "&";
        if (minTaxAmountFilter === null)
            throw new Error("The parameter 'minTaxAmountFilter' cannot be null.");
        else if (minTaxAmountFilter !== undefined)
            url_ += "MinTaxAmountFilter=" + encodeURIComponent("" + minTaxAmountFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetStoreTaxForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetStoreTaxForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStoreTaxForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetStoreTaxForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreTaxForView(id: number | undefined): Observable<GetStoreTaxForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreTaxes/GetStoreTaxForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreTaxForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreTaxForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreTaxForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreTaxForViewDto>;
        }));
    }

    protected processGetStoreTaxForView(response: HttpResponseBase): Observable<GetStoreTaxForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreTaxForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStoreTaxForEdit(id: number | undefined): Observable<GetStoreTaxForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StoreTaxes/GetStoreTaxForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreTaxForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreTaxForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetStoreTaxForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetStoreTaxForEditOutput>;
        }));
    }

    protected processGetStoreTaxForEdit(response: HttpResponseBase): Observable<GetStoreTaxForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetStoreTaxForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditStoreTaxDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreTaxes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreTaxes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param taxNameFilter (optional) 
     * @param percentageOrAmountFilter (optional) 
     * @param maxTaxRatePercentageFilter (optional) 
     * @param minTaxRatePercentageFilter (optional) 
     * @param maxTaxAmountFilter (optional) 
     * @param minTaxAmountFilter (optional) 
     * @param storeNameFilter (optional) 
     * @return Success
     */
    getStoreTaxesToExcel(filter: string | undefined, taxNameFilter: string | undefined, percentageOrAmountFilter: number | undefined, maxTaxRatePercentageFilter: number | undefined, minTaxRatePercentageFilter: number | undefined, maxTaxAmountFilter: number | undefined, minTaxAmountFilter: number | undefined, storeNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreTaxes/GetStoreTaxesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (taxNameFilter === null)
            throw new Error("The parameter 'taxNameFilter' cannot be null.");
        else if (taxNameFilter !== undefined)
            url_ += "TaxNameFilter=" + encodeURIComponent("" + taxNameFilter) + "&";
        if (percentageOrAmountFilter === null)
            throw new Error("The parameter 'percentageOrAmountFilter' cannot be null.");
        else if (percentageOrAmountFilter !== undefined)
            url_ += "PercentageOrAmountFilter=" + encodeURIComponent("" + percentageOrAmountFilter) + "&";
        if (maxTaxRatePercentageFilter === null)
            throw new Error("The parameter 'maxTaxRatePercentageFilter' cannot be null.");
        else if (maxTaxRatePercentageFilter !== undefined)
            url_ += "MaxTaxRatePercentageFilter=" + encodeURIComponent("" + maxTaxRatePercentageFilter) + "&";
        if (minTaxRatePercentageFilter === null)
            throw new Error("The parameter 'minTaxRatePercentageFilter' cannot be null.");
        else if (minTaxRatePercentageFilter !== undefined)
            url_ += "MinTaxRatePercentageFilter=" + encodeURIComponent("" + minTaxRatePercentageFilter) + "&";
        if (maxTaxAmountFilter === null)
            throw new Error("The parameter 'maxTaxAmountFilter' cannot be null.");
        else if (maxTaxAmountFilter !== undefined)
            url_ += "MaxTaxAmountFilter=" + encodeURIComponent("" + maxTaxAmountFilter) + "&";
        if (minTaxAmountFilter === null)
            throw new Error("The parameter 'minTaxAmountFilter' cannot be null.");
        else if (minTaxAmountFilter !== undefined)
            url_ += "MinTaxAmountFilter=" + encodeURIComponent("" + minTaxAmountFilter) + "&";
        if (storeNameFilter === null)
            throw new Error("The parameter 'storeNameFilter' cannot be null.");
        else if (storeNameFilter !== undefined)
            url_ += "StoreNameFilter=" + encodeURIComponent("" + storeNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreTaxesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreTaxesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetStoreTaxesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStoreForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfStoreTaxStoreLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreTaxes/GetAllStoreForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfStoreTaxStoreLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfStoreTaxStoreLookupTableDto>;
        }));
    }

    protected processGetAllStoreForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStoreTaxStoreLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreTaxStoreLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StripeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StripeConfigurationDto>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param stripeSessionId (optional) 
     * @return Success
     */
    getPayment(stripeSessionId: string | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPayment?";
        if (stripeSessionId === null)
            throw new Error("The parameter 'stripeSessionId' cannot be null.");
        else if (stripeSessionId !== undefined)
            url_ += "StripeSessionId=" + encodeURIComponent("" + stripeSessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPaymentSession(body: StripeCreatePaymentSessionInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreatePaymentSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaymentSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaymentSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreatePaymentSession(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPaymentResult(paymentId: number | undefined): Observable<StripePaymentResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPaymentResult?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "PaymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StripePaymentResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StripePaymentResultOutput>;
        }));
    }

    protected processGetPaymentResult(response: HttpResponseBase): Observable<StripePaymentResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripePaymentResultOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TaskEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param statusFilter (optional) 
     * @param priorityFilter (optional) 
     * @param maxEventDateFilter (optional) 
     * @param minEventDateFilter (optional) 
     * @param startTimeFilter (optional) 
     * @param endTimeFilter (optional) 
     * @param templateFilter (optional) 
     * @param actualTimeFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param estimatedTimeFilter (optional) 
     * @param hourAndMinutesFilter (optional) 
     * @param taskStatusNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, statusFilter: number | undefined, priorityFilter: number | undefined, maxEventDateFilter: DateTime | undefined, minEventDateFilter: DateTime | undefined, startTimeFilter: string | undefined, endTimeFilter: string | undefined, templateFilter: number | undefined, actualTimeFilter: string | undefined, maxEndDateFilter: DateTime | undefined, minEndDateFilter: DateTime | undefined, estimatedTimeFilter: string | undefined, hourAndMinutesFilter: string | undefined, taskStatusNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTaskEventForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskEvents/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&";
        if (priorityFilter === null)
            throw new Error("The parameter 'priorityFilter' cannot be null.");
        else if (priorityFilter !== undefined)
            url_ += "PriorityFilter=" + encodeURIComponent("" + priorityFilter) + "&";
        if (maxEventDateFilter === null)
            throw new Error("The parameter 'maxEventDateFilter' cannot be null.");
        else if (maxEventDateFilter !== undefined)
            url_ += "MaxEventDateFilter=" + encodeURIComponent(maxEventDateFilter ? "" + maxEventDateFilter.toString() : "") + "&";
        if (minEventDateFilter === null)
            throw new Error("The parameter 'minEventDateFilter' cannot be null.");
        else if (minEventDateFilter !== undefined)
            url_ += "MinEventDateFilter=" + encodeURIComponent(minEventDateFilter ? "" + minEventDateFilter.toString() : "") + "&";
        if (startTimeFilter === null)
            throw new Error("The parameter 'startTimeFilter' cannot be null.");
        else if (startTimeFilter !== undefined)
            url_ += "StartTimeFilter=" + encodeURIComponent("" + startTimeFilter) + "&";
        if (endTimeFilter === null)
            throw new Error("The parameter 'endTimeFilter' cannot be null.");
        else if (endTimeFilter !== undefined)
            url_ += "EndTimeFilter=" + encodeURIComponent("" + endTimeFilter) + "&";
        if (templateFilter === null)
            throw new Error("The parameter 'templateFilter' cannot be null.");
        else if (templateFilter !== undefined)
            url_ += "TemplateFilter=" + encodeURIComponent("" + templateFilter) + "&";
        if (actualTimeFilter === null)
            throw new Error("The parameter 'actualTimeFilter' cannot be null.");
        else if (actualTimeFilter !== undefined)
            url_ += "ActualTimeFilter=" + encodeURIComponent("" + actualTimeFilter) + "&";
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toString() : "") + "&";
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toString() : "") + "&";
        if (estimatedTimeFilter === null)
            throw new Error("The parameter 'estimatedTimeFilter' cannot be null.");
        else if (estimatedTimeFilter !== undefined)
            url_ += "EstimatedTimeFilter=" + encodeURIComponent("" + estimatedTimeFilter) + "&";
        if (hourAndMinutesFilter === null)
            throw new Error("The parameter 'hourAndMinutesFilter' cannot be null.");
        else if (hourAndMinutesFilter !== undefined)
            url_ += "HourAndMinutesFilter=" + encodeURIComponent("" + hourAndMinutesFilter) + "&";
        if (taskStatusNameFilter === null)
            throw new Error("The parameter 'taskStatusNameFilter' cannot be null.");
        else if (taskStatusNameFilter !== undefined)
            url_ += "TaskStatusNameFilter=" + encodeURIComponent("" + taskStatusNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetTaskEventForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetTaskEventForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTaskEventForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTaskEventForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTaskEventForView(id: number | undefined): Observable<GetTaskEventForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskEvents/GetTaskEventForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskEventForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskEventForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTaskEventForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTaskEventForViewDto>;
        }));
    }

    protected processGetTaskEventForView(response: HttpResponseBase): Observable<GetTaskEventForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTaskEventForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTaskEventForEdit(id: number | undefined): Observable<GetTaskEventForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TaskEvents/GetTaskEventForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskEventForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskEventForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTaskEventForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTaskEventForEditOutput>;
        }));
    }

    protected processGetTaskEventForEdit(response: HttpResponseBase): Observable<GetTaskEventForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTaskEventForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTaskEventDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaskEvents/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaskEvents/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param statusFilter (optional) 
     * @param priorityFilter (optional) 
     * @param maxEventDateFilter (optional) 
     * @param minEventDateFilter (optional) 
     * @param startTimeFilter (optional) 
     * @param endTimeFilter (optional) 
     * @param templateFilter (optional) 
     * @param actualTimeFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param estimatedTimeFilter (optional) 
     * @param hourAndMinutesFilter (optional) 
     * @param taskStatusNameFilter (optional) 
     * @return Success
     */
    getTaskEventsToExcel(filter: string | undefined, nameFilter: string | undefined, descriptionFilter: string | undefined, statusFilter: number | undefined, priorityFilter: number | undefined, maxEventDateFilter: DateTime | undefined, minEventDateFilter: DateTime | undefined, startTimeFilter: string | undefined, endTimeFilter: string | undefined, templateFilter: number | undefined, actualTimeFilter: string | undefined, maxEndDateFilter: DateTime | undefined, minEndDateFilter: DateTime | undefined, estimatedTimeFilter: string | undefined, hourAndMinutesFilter: string | undefined, taskStatusNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskEvents/GetTaskEventsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&";
        if (priorityFilter === null)
            throw new Error("The parameter 'priorityFilter' cannot be null.");
        else if (priorityFilter !== undefined)
            url_ += "PriorityFilter=" + encodeURIComponent("" + priorityFilter) + "&";
        if (maxEventDateFilter === null)
            throw new Error("The parameter 'maxEventDateFilter' cannot be null.");
        else if (maxEventDateFilter !== undefined)
            url_ += "MaxEventDateFilter=" + encodeURIComponent(maxEventDateFilter ? "" + maxEventDateFilter.toString() : "") + "&";
        if (minEventDateFilter === null)
            throw new Error("The parameter 'minEventDateFilter' cannot be null.");
        else if (minEventDateFilter !== undefined)
            url_ += "MinEventDateFilter=" + encodeURIComponent(minEventDateFilter ? "" + minEventDateFilter.toString() : "") + "&";
        if (startTimeFilter === null)
            throw new Error("The parameter 'startTimeFilter' cannot be null.");
        else if (startTimeFilter !== undefined)
            url_ += "StartTimeFilter=" + encodeURIComponent("" + startTimeFilter) + "&";
        if (endTimeFilter === null)
            throw new Error("The parameter 'endTimeFilter' cannot be null.");
        else if (endTimeFilter !== undefined)
            url_ += "EndTimeFilter=" + encodeURIComponent("" + endTimeFilter) + "&";
        if (templateFilter === null)
            throw new Error("The parameter 'templateFilter' cannot be null.");
        else if (templateFilter !== undefined)
            url_ += "TemplateFilter=" + encodeURIComponent("" + templateFilter) + "&";
        if (actualTimeFilter === null)
            throw new Error("The parameter 'actualTimeFilter' cannot be null.");
        else if (actualTimeFilter !== undefined)
            url_ += "ActualTimeFilter=" + encodeURIComponent("" + actualTimeFilter) + "&";
        if (maxEndDateFilter === null)
            throw new Error("The parameter 'maxEndDateFilter' cannot be null.");
        else if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toString() : "") + "&";
        if (minEndDateFilter === null)
            throw new Error("The parameter 'minEndDateFilter' cannot be null.");
        else if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toString() : "") + "&";
        if (estimatedTimeFilter === null)
            throw new Error("The parameter 'estimatedTimeFilter' cannot be null.");
        else if (estimatedTimeFilter !== undefined)
            url_ += "EstimatedTimeFilter=" + encodeURIComponent("" + estimatedTimeFilter) + "&";
        if (hourAndMinutesFilter === null)
            throw new Error("The parameter 'hourAndMinutesFilter' cannot be null.");
        else if (hourAndMinutesFilter !== undefined)
            url_ += "HourAndMinutesFilter=" + encodeURIComponent("" + hourAndMinutesFilter) + "&";
        if (taskStatusNameFilter === null)
            throw new Error("The parameter 'taskStatusNameFilter' cannot be null.");
        else if (taskStatusNameFilter !== undefined)
            url_ += "TaskStatusNameFilter=" + encodeURIComponent("" + taskStatusNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskEventsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskEventsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetTaskEventsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllTaskStatusForTableDropdown(): Observable<TaskEventTaskStatusLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TaskEvents/GetAllTaskStatusForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaskStatusForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaskStatusForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TaskEventTaskStatusLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TaskEventTaskStatusLookupTableDto[]>;
        }));
    }

    protected processGetAllTaskStatusForTableDropdown(response: HttpResponseBase): Observable<TaskEventTaskStatusLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaskEventTaskStatusLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TaskStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTaskStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskStatuses/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetTaskStatusForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetTaskStatusForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTaskStatusForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTaskStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTaskStatusForView(id: number | undefined): Observable<GetTaskStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskStatuses/GetTaskStatusForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskStatusForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTaskStatusForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTaskStatusForViewDto>;
        }));
    }

    protected processGetTaskStatusForView(response: HttpResponseBase): Observable<GetTaskStatusForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTaskStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTaskStatusForEdit(id: number | undefined): Observable<GetTaskStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TaskStatuses/GetTaskStatusForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskStatusForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTaskStatusForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTaskStatusForEditOutput>;
        }));
    }

    protected processGetTaskStatusForEdit(response: HttpResponseBase): Observable<GetTaskStatusForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTaskStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTaskStatusDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaskStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaskStatuses/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @return Success
     */
    getTaskStatusesToExcel(filter: string | undefined, nameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskStatuses/GetTaskStatusesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskStatusesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskStatusesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetTaskStatusesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TaskTagsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verfiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param taskEventNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verfiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, taskEventNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTaskTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskTags/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verfiedFilter === null)
            throw new Error("The parameter 'verfiedFilter' cannot be null.");
        else if (verfiedFilter !== undefined)
            url_ += "VerfiedFilter=" + encodeURIComponent("" + verfiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (taskEventNameFilter === null)
            throw new Error("The parameter 'taskEventNameFilter' cannot be null.");
        else if (taskEventNameFilter !== undefined)
            url_ += "TaskEventNameFilter=" + encodeURIComponent("" + taskEventNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetTaskTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetTaskTagForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTaskTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTaskTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTaskTagForView(id: number | undefined): Observable<GetTaskTagForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskTags/GetTaskTagForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskTagForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskTagForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTaskTagForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTaskTagForViewDto>;
        }));
    }

    protected processGetTaskTagForView(response: HttpResponseBase): Observable<GetTaskTagForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTaskTagForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTaskTagForEdit(id: number | undefined): Observable<GetTaskTagForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TaskTags/GetTaskTagForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskTagForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskTagForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTaskTagForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTaskTagForEditOutput>;
        }));
    }

    protected processGetTaskTagForEdit(response: HttpResponseBase): Observable<GetTaskTagForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTaskTagForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTaskTagDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaskTags/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaskTags/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param customTagFilter (optional) 
     * @param tagValueFilter (optional) 
     * @param verfiedFilter (optional) 
     * @param maxSequenceFilter (optional) 
     * @param minSequenceFilter (optional) 
     * @param taskEventNameFilter (optional) 
     * @param masterTagCategoryNameFilter (optional) 
     * @param masterTagNameFilter (optional) 
     * @return Success
     */
    getTaskTagsToExcel(filter: string | undefined, customTagFilter: string | undefined, tagValueFilter: string | undefined, verfiedFilter: number | undefined, maxSequenceFilter: number | undefined, minSequenceFilter: number | undefined, taskEventNameFilter: string | undefined, masterTagCategoryNameFilter: string | undefined, masterTagNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskTags/GetTaskTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (customTagFilter === null)
            throw new Error("The parameter 'customTagFilter' cannot be null.");
        else if (customTagFilter !== undefined)
            url_ += "CustomTagFilter=" + encodeURIComponent("" + customTagFilter) + "&";
        if (tagValueFilter === null)
            throw new Error("The parameter 'tagValueFilter' cannot be null.");
        else if (tagValueFilter !== undefined)
            url_ += "TagValueFilter=" + encodeURIComponent("" + tagValueFilter) + "&";
        if (verfiedFilter === null)
            throw new Error("The parameter 'verfiedFilter' cannot be null.");
        else if (verfiedFilter !== undefined)
            url_ += "VerfiedFilter=" + encodeURIComponent("" + verfiedFilter) + "&";
        if (maxSequenceFilter === null)
            throw new Error("The parameter 'maxSequenceFilter' cannot be null.");
        else if (maxSequenceFilter !== undefined)
            url_ += "MaxSequenceFilter=" + encodeURIComponent("" + maxSequenceFilter) + "&";
        if (minSequenceFilter === null)
            throw new Error("The parameter 'minSequenceFilter' cannot be null.");
        else if (minSequenceFilter !== undefined)
            url_ += "MinSequenceFilter=" + encodeURIComponent("" + minSequenceFilter) + "&";
        if (taskEventNameFilter === null)
            throw new Error("The parameter 'taskEventNameFilter' cannot be null.");
        else if (taskEventNameFilter !== undefined)
            url_ += "TaskEventNameFilter=" + encodeURIComponent("" + taskEventNameFilter) + "&";
        if (masterTagCategoryNameFilter === null)
            throw new Error("The parameter 'masterTagCategoryNameFilter' cannot be null.");
        else if (masterTagCategoryNameFilter !== undefined)
            url_ += "MasterTagCategoryNameFilter=" + encodeURIComponent("" + masterTagCategoryNameFilter) + "&";
        if (masterTagNameFilter === null)
            throw new Error("The parameter 'masterTagNameFilter' cannot be null.");
        else if (masterTagNameFilter !== undefined)
            url_ += "MasterTagNameFilter=" + encodeURIComponent("" + masterTagNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskTagsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetTaskTagsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTaskEventForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTaskTagTaskEventLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskTags/GetAllTaskEventForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaskEventForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaskEventForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTaskTagTaskEventLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTaskTagTaskEventLookupTableDto>;
        }));
    }

    protected processGetAllTaskEventForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTaskTagTaskEventLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTaskTagTaskEventLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagCategoryForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskTags/GetAllMasterTagCategoryForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagCategoryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagCategoryForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagCategoryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMasterTagForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTaskTagMasterTagLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TaskTags/GetAllMasterTagForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMasterTagForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMasterTagForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTaskTagMasterTagLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTaskTagMasterTagLookupTableDto>;
        }));
    }

    protected processGetAllMasterTagForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTaskTagMasterTagLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTaskTagMasterTagLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | undefined, subscriptionEndDateStart: DateTime | undefined, subscriptionEndDateEnd: DateTime | undefined, creationDateStart: DateTime | undefined, creationDateEnd: DateTime | undefined, editionId: number | undefined, editionIdSpecified: boolean | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (subscriptionEndDateStart === null)
            throw new Error("The parameter 'subscriptionEndDateStart' cannot be null.");
        else if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toString() : "") + "&";
        if (subscriptionEndDateEnd === null)
            throw new Error("The parameter 'subscriptionEndDateEnd' cannot be null.");
        else if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toString() : "") + "&";
        if (creationDateStart === null)
            throw new Error("The parameter 'creationDateStart' cannot be null.");
        else if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toString() : "") + "&";
        if (creationDateEnd === null)
            throw new Error("The parameter 'creationDateEnd' cannot be null.");
        else if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toString() : "") + "&";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (editionIdSpecified === null)
            throw new Error("The parameter 'editionIdSpecified' cannot be null.");
        else if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTenantListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTenantListDto>;
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantEditDto>;
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTenantFeaturesEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTenantFeaturesEditOutput>;
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @param extension (optional) 
     * @return Success
     */
    getTenantLogo(skin: string, tenantId: number | undefined, extension: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/TenantCustomization/GetTenantLogo/{skin}/{tenantId}/{extension}?";
        if (skin === undefined || skin === null)
            throw new Error("The parameter 'skin' must be defined.");
        url_ = url_.replace("{skin}", encodeURIComponent("" + skin));
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (extension === null)
            throw new Error("The parameter 'extension' cannot be null.");
        else if (extension !== undefined)
            url_ += "extension=" + encodeURIComponent("" + extension) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetTenantLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMemberActivityOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMemberActivityOutput>;
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberActivityOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDashboardDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDashboardDataOutput>;
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDashboardDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTopStats(): Observable<GetTopStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetTopStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTopStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTopStatsOutput>;
        }));
    }

    protected processGetTopStats(response: HttpResponseBase): Observable<GetTopStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTopStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getProfitShare(): Observable<GetProfitShareOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetProfitShare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfitShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfitShare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfitShareOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfitShareOutput>;
        }));
    }

    protected processGetProfitShare(response: HttpResponseBase): Observable<GetProfitShareOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfitShareOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDailySales(): Observable<GetDailySalesOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDailySales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailySales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailySales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDailySalesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDailySalesOutput>;
        }));
    }

    protected processGetDailySales(response: HttpResponseBase): Observable<GetDailySalesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDailySalesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSalesSummaryOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSalesSummaryOutput>;
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSalesSummaryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRegionalStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRegionalStatsOutput>;
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegionalStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGeneralStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGeneralStatsOutput>;
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantInput | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterTenantOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterTenantOutput>;
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterTenantOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditionsSelectOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditionsSelectOutput>;
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionsSelectOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditionSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditionSelectDto>;
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginSettingsDto>;
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfNameValueDto>;
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId === null)
            throw new Error("The parameter 'selectedTimezoneId' cannot be null.");
        else if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefreshTokenResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefreshTokenResult>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken === null)
            throw new Error("The parameter 'impersonationToken' cannot be null.");
        else if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userDelegationId (optional) 
     * @param impersonationToken (optional) 
     * @return Success
     */
    delegatedImpersonatedAuthenticate(userDelegationId: number | undefined, impersonationToken: string | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/DelegatedImpersonatedAuthenticate?";
        if (userDelegationId === null)
            throw new Error("The parameter 'userDelegationId' cannot be null.");
        else if (userDelegationId !== undefined)
            url_ += "userDelegationId=" + encodeURIComponent("" + userDelegationId) + "&";
        if (impersonationToken === null)
            throw new Error("The parameter 'impersonationToken' cannot be null.");
        else if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processDelegatedImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken === null)
            throw new Error("The parameter 'switchAccountToken' cannot be null.");
        else if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchedAccountAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchedAccountAuthenticateResultModel>;
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | undefined, severity: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message === null)
            throw new Error("The parameter 'message' cannot be null.");
        else if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (severity === null)
            throw new Error("The parameter 'severity' cannot be null.");
        else if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TwitterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRequestToken(): Observable<TwitterGetRequestTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetRequestToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwitterGetRequestTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwitterGetRequestTokenResponse>;
        }));
    }

    protected processGetRequestToken(response: HttpResponseBase): Observable<TwitterGetRequestTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetRequestTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param token (optional) 
     * @param verifier (optional) 
     * @return Success
     */
    getAccessToken(token: string | undefined, verifier: string | undefined): Observable<TwitterGetAccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetAccessToken?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (verifier === null)
            throw new Error("The parameter 'verifier' cannot be null.");
        else if (verifier !== undefined)
            url_ += "verifier=" + encodeURIComponent("" + verifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwitterGetAccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwitterGetAccessTokenResponse>;
        }));
    }

    protected processGetAccessToken(response: HttpResponseBase): Observable<TwitterGetAccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetAccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThemeSettingsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThemeSettingsDto[]>;
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName === null)
            throw new Error("The parameter 'themeName' cannot be null.");
        else if (themeName !== undefined)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isDarkModeActive (optional) 
     * @return Success
     */
    changeDarkModeOfCurrentTheme(isDarkModeActive: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeDarkModeOfCurrentTheme?";
        if (isDarkModeActive === null)
            throw new Error("The parameter 'isDarkModeActive' cannot be null.");
        else if (isDarkModeActive !== undefined)
            url_ += "isDarkModeActive=" + encodeURIComponent("" + isDarkModeActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeDarkModeOfCurrentTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeDarkModeOfCurrentTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeDarkModeOfCurrentTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUsers(body: GetUsersInput | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserListDto>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | undefined, permissions: string[] | undefined, role: number | undefined, onlyLockedUsers: boolean | undefined, sorting: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserForEditOutput>;
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserPermissionsForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserPermissionsForEditOutput>;
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserDelegationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getDelegatedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined): Observable<PagedResultDtoOfUserDelegationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetDelegatedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDelegatedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDelegatedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserDelegationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserDelegationDto>;
        }));
    }

    protected processGetDelegatedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserDelegationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDelegationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegateNewUser(body: CreateUserDelegationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/DelegateNewUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegateNewUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegateNewUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelegateNewUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeDelegation(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/RemoveDelegation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDelegation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDelegation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveDelegation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getActiveUserDelegations(): Observable<UserDelegationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetActiveUserDelegations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveUserDelegations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveUserDelegations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDelegationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDelegationDto[]>;
        }));
    }

    protected processGetActiveUserDelegations(response: HttpResponseBase): Observable<UserDelegationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDelegationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLinkedUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLinkedUserDto>;
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfLinkedUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfLinkedUserDto>;
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param result (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserLoginAttempts(filter: string | undefined, startDate: DateTime | undefined, endDate: DateTime | undefined, result: AbpLoginResultType | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetUserLoginAttempts?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (result === null)
            throw new Error("The parameter 'result' cannot be null.");
        else if (result !== undefined)
            url_ += "Result=" + encodeURIComponent("" + result) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserLoginAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserLoginAttemptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserLoginAttemptDto>;
        }));
    }

    protected processGetUserLoginAttempts(response: HttpResponseBase): Observable<PagedResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<WebhookEvent> {
        let url_ = this.baseUrl + "/api/services/app/WebhookEvent/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebhookEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebhookEvent>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WebhookEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookSendAttemptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subscriptionId (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSendAttempts(subscriptionId: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttempts?";
        if (subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' cannot be null.");
        else if (subscriptionId !== undefined)
            url_ += "SubscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAllSendAttemptsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAllSendAttemptsOutput>;
        }));
    }

    protected processGetAllSendAttempts(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllSendAttemptsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllSendAttemptsOfWebhookEvent(id: string | undefined): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttemptsOfWebhookEvent?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttemptsOfWebhookEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttemptsOfWebhookEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>;
        }));
    }

    protected processGetAllSendAttemptsOfWebhookEvent(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sendAttemptId (optional) 
     * @return Success
     */
    resend(sendAttemptId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/Resend?";
        if (sendAttemptId === null)
            throw new Error("The parameter 'sendAttemptId' cannot be null.");
        else if (sendAttemptId !== undefined)
            url_ += "sendAttemptId=" + encodeURIComponent("" + sendAttemptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    publishTestWebhook(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/PublishTestWebhook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishTestWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishTestWebhook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPublishTestWebhook(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSubscriptions(): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
        }));
    }

    protected processGetAllSubscriptions(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param subscriptionId (optional) 
     * @return Success
     */
    getSubscription(subscriptionId: string | undefined): Observable<WebhookSubscription> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetSubscription?";
        if (subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' cannot be null.");
        else if (subscriptionId !== undefined)
            url_ += "subscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebhookSubscription>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebhookSubscription>;
        }));
    }

    protected processGetSubscription(response: HttpResponseBase): Observable<WebhookSubscription> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookSubscription.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/AddSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateWebhookSubscription(body: ActivateWebhookSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/ActivateWebhookSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateWebhookSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateWebhookSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateWebhookSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    isSubscribed(webhookName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/IsSubscribed?";
        if (webhookName === null)
            throw new Error("The parameter 'webhookName' cannot be null.");
        else if (webhookName !== undefined)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsSubscribed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsSubscribed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsSubscribed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    getAllSubscriptionsIfFeaturesGranted(webhookName: string | undefined): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptionsIfFeaturesGranted?";
        if (webhookName === null)
            throw new Error("The parameter 'webhookName' cannot be null.");
        else if (webhookName !== undefined)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptionsIfFeaturesGranted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptionsIfFeaturesGranted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
        }));
    }

    protected processGetAllSubscriptionsIfFeaturesGranted(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAvailableWebhooks(): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllAvailableWebhooks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAvailableWebhooks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAvailableWebhooks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>;
        }));
    }

    protected processGetAllAvailableWebhooks(response: HttpResponseBase): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllAvailableWebhooksOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLatestWebLogsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLatestWebLogsOutput>;
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLatestWebLogsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ZipCodesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param areaCodeFilter (optional) 
     * @param asianPopulationFilter (optional) 
     * @param averageHouseValueFilter (optional) 
     * @param blackPopulationFilter (optional) 
     * @param cBSAFilter (optional) 
     * @param cBSA_DivFilter (optional) 
     * @param cBSA_Div_NameFilter (optional) 
     * @param cBSA_NameFilter (optional) 
     * @param cBSA_TypeFilter (optional) 
     * @param cSAFilter (optional) 
     * @param cSANameFilter (optional) 
     * @param carrierRouteRateSortationFilter (optional) 
     * @param cityFilter (optional) 
     * @param cityAliasCodeFilter (optional) 
     * @param cityAliasMixedCaseFilter (optional) 
     * @param cityAliasNameFilter (optional) 
     * @param cityDeliveryIndicatorFilter (optional) 
     * @param cityMixedCaseFilter (optional) 
     * @param cityStateKeyFilter (optional) 
     * @param cityTypeFilter (optional) 
     * @param classificationCodeFilter (optional) 
     * @param countyFilter (optional) 
     * @param countyANSIFilter (optional) 
     * @param countyFIPSFilter (optional) 
     * @param countyMixedCaseFilter (optional) 
     * @param dayLightSavingFilter (optional) 
     * @param divisionFilter (optional) 
     * @param elevationFilter (optional) 
     * @param facilityCodeFilter (optional) 
     * @param femalePopulationFilter (optional) 
     * @param financeNumberFilter (optional) 
     * @param hawaiianPopulationFilter (optional) 
     * @param hispanicPopulationFilter (optional) 
     * @param householdsPerZipCodeFilter (optional) 
     * @param incomePerHouseholdFilter (optional) 
     * @param indianPopulationFilter (optional) 
     * @param latitudeFilter (optional) 
     * @param longitudeFilter (optional) 
     * @param mSAFilter (optional) 
     * @param mSA_NameFilter (optional) 
     * @param mailingNameFilter (optional) 
     * @param malePopulationFilter (optional) 
     * @param multiCountyFilter (optional) 
     * @param otherPopulationFilter (optional) 
     * @param pMSAFilter (optional) 
     * @param pMSA_NameFilter (optional) 
     * @param personsPerHouseholdFilter (optional) 
     * @param populationFilter (optional) 
     * @param preferredLastLineKeyFilter (optional) 
     * @param primaryRecordFilter (optional) 
     * @param regionFilter (optional) 
     * @param stateFilter (optional) 
     * @param stateANSIFilter (optional) 
     * @param stateFIPSFilter (optional) 
     * @param stateFullNameFilter (optional) 
     * @param timeZoneFilter (optional) 
     * @param uniqueZIPNameFilter (optional) 
     * @param whitePopulationFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param cityNameFilter (optional) 
     * @param countyNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, nameFilter: string | undefined, areaCodeFilter: string | undefined, asianPopulationFilter: string | undefined, averageHouseValueFilter: string | undefined, blackPopulationFilter: string | undefined, cBSAFilter: string | undefined, cBSA_DivFilter: string | undefined, cBSA_Div_NameFilter: string | undefined, cBSA_NameFilter: string | undefined, cBSA_TypeFilter: string | undefined, cSAFilter: string | undefined, cSANameFilter: string | undefined, carrierRouteRateSortationFilter: string | undefined, cityFilter: string | undefined, cityAliasCodeFilter: string | undefined, cityAliasMixedCaseFilter: string | undefined, cityAliasNameFilter: string | undefined, cityDeliveryIndicatorFilter: string | undefined, cityMixedCaseFilter: string | undefined, cityStateKeyFilter: string | undefined, cityTypeFilter: string | undefined, classificationCodeFilter: string | undefined, countyFilter: string | undefined, countyANSIFilter: string | undefined, countyFIPSFilter: string | undefined, countyMixedCaseFilter: string | undefined, dayLightSavingFilter: string | undefined, divisionFilter: string | undefined, elevationFilter: string | undefined, facilityCodeFilter: string | undefined, femalePopulationFilter: string | undefined, financeNumberFilter: string | undefined, hawaiianPopulationFilter: string | undefined, hispanicPopulationFilter: string | undefined, householdsPerZipCodeFilter: string | undefined, incomePerHouseholdFilter: string | undefined, indianPopulationFilter: string | undefined, latitudeFilter: string | undefined, longitudeFilter: string | undefined, mSAFilter: string | undefined, mSA_NameFilter: string | undefined, mailingNameFilter: string | undefined, malePopulationFilter: string | undefined, multiCountyFilter: string | undefined, otherPopulationFilter: string | undefined, pMSAFilter: string | undefined, pMSA_NameFilter: string | undefined, personsPerHouseholdFilter: string | undefined, populationFilter: string | undefined, preferredLastLineKeyFilter: string | undefined, primaryRecordFilter: string | undefined, regionFilter: string | undefined, stateFilter: string | undefined, stateANSIFilter: string | undefined, stateFIPSFilter: string | undefined, stateFullNameFilter: string | undefined, timeZoneFilter: string | undefined, uniqueZIPNameFilter: string | undefined, whitePopulationFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, cityNameFilter: string | undefined, countyNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetZipCodeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ZipCodes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (areaCodeFilter === null)
            throw new Error("The parameter 'areaCodeFilter' cannot be null.");
        else if (areaCodeFilter !== undefined)
            url_ += "AreaCodeFilter=" + encodeURIComponent("" + areaCodeFilter) + "&";
        if (asianPopulationFilter === null)
            throw new Error("The parameter 'asianPopulationFilter' cannot be null.");
        else if (asianPopulationFilter !== undefined)
            url_ += "AsianPopulationFilter=" + encodeURIComponent("" + asianPopulationFilter) + "&";
        if (averageHouseValueFilter === null)
            throw new Error("The parameter 'averageHouseValueFilter' cannot be null.");
        else if (averageHouseValueFilter !== undefined)
            url_ += "AverageHouseValueFilter=" + encodeURIComponent("" + averageHouseValueFilter) + "&";
        if (blackPopulationFilter === null)
            throw new Error("The parameter 'blackPopulationFilter' cannot be null.");
        else if (blackPopulationFilter !== undefined)
            url_ += "BlackPopulationFilter=" + encodeURIComponent("" + blackPopulationFilter) + "&";
        if (cBSAFilter === null)
            throw new Error("The parameter 'cBSAFilter' cannot be null.");
        else if (cBSAFilter !== undefined)
            url_ += "CBSAFilter=" + encodeURIComponent("" + cBSAFilter) + "&";
        if (cBSA_DivFilter === null)
            throw new Error("The parameter 'cBSA_DivFilter' cannot be null.");
        else if (cBSA_DivFilter !== undefined)
            url_ += "CBSA_DivFilter=" + encodeURIComponent("" + cBSA_DivFilter) + "&";
        if (cBSA_Div_NameFilter === null)
            throw new Error("The parameter 'cBSA_Div_NameFilter' cannot be null.");
        else if (cBSA_Div_NameFilter !== undefined)
            url_ += "CBSA_Div_NameFilter=" + encodeURIComponent("" + cBSA_Div_NameFilter) + "&";
        if (cBSA_NameFilter === null)
            throw new Error("The parameter 'cBSA_NameFilter' cannot be null.");
        else if (cBSA_NameFilter !== undefined)
            url_ += "CBSA_NameFilter=" + encodeURIComponent("" + cBSA_NameFilter) + "&";
        if (cBSA_TypeFilter === null)
            throw new Error("The parameter 'cBSA_TypeFilter' cannot be null.");
        else if (cBSA_TypeFilter !== undefined)
            url_ += "CBSA_TypeFilter=" + encodeURIComponent("" + cBSA_TypeFilter) + "&";
        if (cSAFilter === null)
            throw new Error("The parameter 'cSAFilter' cannot be null.");
        else if (cSAFilter !== undefined)
            url_ += "CSAFilter=" + encodeURIComponent("" + cSAFilter) + "&";
        if (cSANameFilter === null)
            throw new Error("The parameter 'cSANameFilter' cannot be null.");
        else if (cSANameFilter !== undefined)
            url_ += "CSANameFilter=" + encodeURIComponent("" + cSANameFilter) + "&";
        if (carrierRouteRateSortationFilter === null)
            throw new Error("The parameter 'carrierRouteRateSortationFilter' cannot be null.");
        else if (carrierRouteRateSortationFilter !== undefined)
            url_ += "CarrierRouteRateSortationFilter=" + encodeURIComponent("" + carrierRouteRateSortationFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (cityAliasCodeFilter === null)
            throw new Error("The parameter 'cityAliasCodeFilter' cannot be null.");
        else if (cityAliasCodeFilter !== undefined)
            url_ += "CityAliasCodeFilter=" + encodeURIComponent("" + cityAliasCodeFilter) + "&";
        if (cityAliasMixedCaseFilter === null)
            throw new Error("The parameter 'cityAliasMixedCaseFilter' cannot be null.");
        else if (cityAliasMixedCaseFilter !== undefined)
            url_ += "CityAliasMixedCaseFilter=" + encodeURIComponent("" + cityAliasMixedCaseFilter) + "&";
        if (cityAliasNameFilter === null)
            throw new Error("The parameter 'cityAliasNameFilter' cannot be null.");
        else if (cityAliasNameFilter !== undefined)
            url_ += "CityAliasNameFilter=" + encodeURIComponent("" + cityAliasNameFilter) + "&";
        if (cityDeliveryIndicatorFilter === null)
            throw new Error("The parameter 'cityDeliveryIndicatorFilter' cannot be null.");
        else if (cityDeliveryIndicatorFilter !== undefined)
            url_ += "CityDeliveryIndicatorFilter=" + encodeURIComponent("" + cityDeliveryIndicatorFilter) + "&";
        if (cityMixedCaseFilter === null)
            throw new Error("The parameter 'cityMixedCaseFilter' cannot be null.");
        else if (cityMixedCaseFilter !== undefined)
            url_ += "CityMixedCaseFilter=" + encodeURIComponent("" + cityMixedCaseFilter) + "&";
        if (cityStateKeyFilter === null)
            throw new Error("The parameter 'cityStateKeyFilter' cannot be null.");
        else if (cityStateKeyFilter !== undefined)
            url_ += "CityStateKeyFilter=" + encodeURIComponent("" + cityStateKeyFilter) + "&";
        if (cityTypeFilter === null)
            throw new Error("The parameter 'cityTypeFilter' cannot be null.");
        else if (cityTypeFilter !== undefined)
            url_ += "CityTypeFilter=" + encodeURIComponent("" + cityTypeFilter) + "&";
        if (classificationCodeFilter === null)
            throw new Error("The parameter 'classificationCodeFilter' cannot be null.");
        else if (classificationCodeFilter !== undefined)
            url_ += "ClassificationCodeFilter=" + encodeURIComponent("" + classificationCodeFilter) + "&";
        if (countyFilter === null)
            throw new Error("The parameter 'countyFilter' cannot be null.");
        else if (countyFilter !== undefined)
            url_ += "CountyFilter=" + encodeURIComponent("" + countyFilter) + "&";
        if (countyANSIFilter === null)
            throw new Error("The parameter 'countyANSIFilter' cannot be null.");
        else if (countyANSIFilter !== undefined)
            url_ += "CountyANSIFilter=" + encodeURIComponent("" + countyANSIFilter) + "&";
        if (countyFIPSFilter === null)
            throw new Error("The parameter 'countyFIPSFilter' cannot be null.");
        else if (countyFIPSFilter !== undefined)
            url_ += "CountyFIPSFilter=" + encodeURIComponent("" + countyFIPSFilter) + "&";
        if (countyMixedCaseFilter === null)
            throw new Error("The parameter 'countyMixedCaseFilter' cannot be null.");
        else if (countyMixedCaseFilter !== undefined)
            url_ += "CountyMixedCaseFilter=" + encodeURIComponent("" + countyMixedCaseFilter) + "&";
        if (dayLightSavingFilter === null)
            throw new Error("The parameter 'dayLightSavingFilter' cannot be null.");
        else if (dayLightSavingFilter !== undefined)
            url_ += "DayLightSavingFilter=" + encodeURIComponent("" + dayLightSavingFilter) + "&";
        if (divisionFilter === null)
            throw new Error("The parameter 'divisionFilter' cannot be null.");
        else if (divisionFilter !== undefined)
            url_ += "DivisionFilter=" + encodeURIComponent("" + divisionFilter) + "&";
        if (elevationFilter === null)
            throw new Error("The parameter 'elevationFilter' cannot be null.");
        else if (elevationFilter !== undefined)
            url_ += "ElevationFilter=" + encodeURIComponent("" + elevationFilter) + "&";
        if (facilityCodeFilter === null)
            throw new Error("The parameter 'facilityCodeFilter' cannot be null.");
        else if (facilityCodeFilter !== undefined)
            url_ += "FacilityCodeFilter=" + encodeURIComponent("" + facilityCodeFilter) + "&";
        if (femalePopulationFilter === null)
            throw new Error("The parameter 'femalePopulationFilter' cannot be null.");
        else if (femalePopulationFilter !== undefined)
            url_ += "FemalePopulationFilter=" + encodeURIComponent("" + femalePopulationFilter) + "&";
        if (financeNumberFilter === null)
            throw new Error("The parameter 'financeNumberFilter' cannot be null.");
        else if (financeNumberFilter !== undefined)
            url_ += "FinanceNumberFilter=" + encodeURIComponent("" + financeNumberFilter) + "&";
        if (hawaiianPopulationFilter === null)
            throw new Error("The parameter 'hawaiianPopulationFilter' cannot be null.");
        else if (hawaiianPopulationFilter !== undefined)
            url_ += "HawaiianPopulationFilter=" + encodeURIComponent("" + hawaiianPopulationFilter) + "&";
        if (hispanicPopulationFilter === null)
            throw new Error("The parameter 'hispanicPopulationFilter' cannot be null.");
        else if (hispanicPopulationFilter !== undefined)
            url_ += "HispanicPopulationFilter=" + encodeURIComponent("" + hispanicPopulationFilter) + "&";
        if (householdsPerZipCodeFilter === null)
            throw new Error("The parameter 'householdsPerZipCodeFilter' cannot be null.");
        else if (householdsPerZipCodeFilter !== undefined)
            url_ += "HouseholdsPerZipCodeFilter=" + encodeURIComponent("" + householdsPerZipCodeFilter) + "&";
        if (incomePerHouseholdFilter === null)
            throw new Error("The parameter 'incomePerHouseholdFilter' cannot be null.");
        else if (incomePerHouseholdFilter !== undefined)
            url_ += "IncomePerHouseholdFilter=" + encodeURIComponent("" + incomePerHouseholdFilter) + "&";
        if (indianPopulationFilter === null)
            throw new Error("The parameter 'indianPopulationFilter' cannot be null.");
        else if (indianPopulationFilter !== undefined)
            url_ += "IndianPopulationFilter=" + encodeURIComponent("" + indianPopulationFilter) + "&";
        if (latitudeFilter === null)
            throw new Error("The parameter 'latitudeFilter' cannot be null.");
        else if (latitudeFilter !== undefined)
            url_ += "LatitudeFilter=" + encodeURIComponent("" + latitudeFilter) + "&";
        if (longitudeFilter === null)
            throw new Error("The parameter 'longitudeFilter' cannot be null.");
        else if (longitudeFilter !== undefined)
            url_ += "LongitudeFilter=" + encodeURIComponent("" + longitudeFilter) + "&";
        if (mSAFilter === null)
            throw new Error("The parameter 'mSAFilter' cannot be null.");
        else if (mSAFilter !== undefined)
            url_ += "MSAFilter=" + encodeURIComponent("" + mSAFilter) + "&";
        if (mSA_NameFilter === null)
            throw new Error("The parameter 'mSA_NameFilter' cannot be null.");
        else if (mSA_NameFilter !== undefined)
            url_ += "MSA_NameFilter=" + encodeURIComponent("" + mSA_NameFilter) + "&";
        if (mailingNameFilter === null)
            throw new Error("The parameter 'mailingNameFilter' cannot be null.");
        else if (mailingNameFilter !== undefined)
            url_ += "MailingNameFilter=" + encodeURIComponent("" + mailingNameFilter) + "&";
        if (malePopulationFilter === null)
            throw new Error("The parameter 'malePopulationFilter' cannot be null.");
        else if (malePopulationFilter !== undefined)
            url_ += "MalePopulationFilter=" + encodeURIComponent("" + malePopulationFilter) + "&";
        if (multiCountyFilter === null)
            throw new Error("The parameter 'multiCountyFilter' cannot be null.");
        else if (multiCountyFilter !== undefined)
            url_ += "MultiCountyFilter=" + encodeURIComponent("" + multiCountyFilter) + "&";
        if (otherPopulationFilter === null)
            throw new Error("The parameter 'otherPopulationFilter' cannot be null.");
        else if (otherPopulationFilter !== undefined)
            url_ += "OtherPopulationFilter=" + encodeURIComponent("" + otherPopulationFilter) + "&";
        if (pMSAFilter === null)
            throw new Error("The parameter 'pMSAFilter' cannot be null.");
        else if (pMSAFilter !== undefined)
            url_ += "PMSAFilter=" + encodeURIComponent("" + pMSAFilter) + "&";
        if (pMSA_NameFilter === null)
            throw new Error("The parameter 'pMSA_NameFilter' cannot be null.");
        else if (pMSA_NameFilter !== undefined)
            url_ += "PMSA_NameFilter=" + encodeURIComponent("" + pMSA_NameFilter) + "&";
        if (personsPerHouseholdFilter === null)
            throw new Error("The parameter 'personsPerHouseholdFilter' cannot be null.");
        else if (personsPerHouseholdFilter !== undefined)
            url_ += "PersonsPerHouseholdFilter=" + encodeURIComponent("" + personsPerHouseholdFilter) + "&";
        if (populationFilter === null)
            throw new Error("The parameter 'populationFilter' cannot be null.");
        else if (populationFilter !== undefined)
            url_ += "PopulationFilter=" + encodeURIComponent("" + populationFilter) + "&";
        if (preferredLastLineKeyFilter === null)
            throw new Error("The parameter 'preferredLastLineKeyFilter' cannot be null.");
        else if (preferredLastLineKeyFilter !== undefined)
            url_ += "PreferredLastLineKeyFilter=" + encodeURIComponent("" + preferredLastLineKeyFilter) + "&";
        if (primaryRecordFilter === null)
            throw new Error("The parameter 'primaryRecordFilter' cannot be null.");
        else if (primaryRecordFilter !== undefined)
            url_ += "PrimaryRecordFilter=" + encodeURIComponent("" + primaryRecordFilter) + "&";
        if (regionFilter === null)
            throw new Error("The parameter 'regionFilter' cannot be null.");
        else if (regionFilter !== undefined)
            url_ += "RegionFilter=" + encodeURIComponent("" + regionFilter) + "&";
        if (stateFilter === null)
            throw new Error("The parameter 'stateFilter' cannot be null.");
        else if (stateFilter !== undefined)
            url_ += "StateFilter=" + encodeURIComponent("" + stateFilter) + "&";
        if (stateANSIFilter === null)
            throw new Error("The parameter 'stateANSIFilter' cannot be null.");
        else if (stateANSIFilter !== undefined)
            url_ += "StateANSIFilter=" + encodeURIComponent("" + stateANSIFilter) + "&";
        if (stateFIPSFilter === null)
            throw new Error("The parameter 'stateFIPSFilter' cannot be null.");
        else if (stateFIPSFilter !== undefined)
            url_ += "StateFIPSFilter=" + encodeURIComponent("" + stateFIPSFilter) + "&";
        if (stateFullNameFilter === null)
            throw new Error("The parameter 'stateFullNameFilter' cannot be null.");
        else if (stateFullNameFilter !== undefined)
            url_ += "StateFullNameFilter=" + encodeURIComponent("" + stateFullNameFilter) + "&";
        if (timeZoneFilter === null)
            throw new Error("The parameter 'timeZoneFilter' cannot be null.");
        else if (timeZoneFilter !== undefined)
            url_ += "TimeZoneFilter=" + encodeURIComponent("" + timeZoneFilter) + "&";
        if (uniqueZIPNameFilter === null)
            throw new Error("The parameter 'uniqueZIPNameFilter' cannot be null.");
        else if (uniqueZIPNameFilter !== undefined)
            url_ += "UniqueZIPNameFilter=" + encodeURIComponent("" + uniqueZIPNameFilter) + "&";
        if (whitePopulationFilter === null)
            throw new Error("The parameter 'whitePopulationFilter' cannot be null.");
        else if (whitePopulationFilter !== undefined)
            url_ += "WhitePopulationFilter=" + encodeURIComponent("" + whitePopulationFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (cityNameFilter === null)
            throw new Error("The parameter 'cityNameFilter' cannot be null.");
        else if (cityNameFilter !== undefined)
            url_ += "CityNameFilter=" + encodeURIComponent("" + cityNameFilter) + "&";
        if (countyNameFilter === null)
            throw new Error("The parameter 'countyNameFilter' cannot be null.");
        else if (countyNameFilter !== undefined)
            url_ += "CountyNameFilter=" + encodeURIComponent("" + countyNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetZipCodeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetZipCodeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetZipCodeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetZipCodeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getZipCodeForView(id: number | undefined): Observable<GetZipCodeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ZipCodes/GetZipCodeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZipCodeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZipCodeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetZipCodeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetZipCodeForViewDto>;
        }));
    }

    protected processGetZipCodeForView(response: HttpResponseBase): Observable<GetZipCodeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetZipCodeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getZipCodeForEdit(id: number | undefined): Observable<GetZipCodeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ZipCodes/GetZipCodeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZipCodeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZipCodeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetZipCodeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetZipCodeForEditOutput>;
        }));
    }

    protected processGetZipCodeForEdit(response: HttpResponseBase): Observable<GetZipCodeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetZipCodeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditZipCodeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ZipCodes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ZipCodes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param areaCodeFilter (optional) 
     * @param asianPopulationFilter (optional) 
     * @param averageHouseValueFilter (optional) 
     * @param blackPopulationFilter (optional) 
     * @param cBSAFilter (optional) 
     * @param cBSA_DivFilter (optional) 
     * @param cBSA_Div_NameFilter (optional) 
     * @param cBSA_NameFilter (optional) 
     * @param cBSA_TypeFilter (optional) 
     * @param cSAFilter (optional) 
     * @param cSANameFilter (optional) 
     * @param carrierRouteRateSortationFilter (optional) 
     * @param cityFilter (optional) 
     * @param cityAliasCodeFilter (optional) 
     * @param cityAliasMixedCaseFilter (optional) 
     * @param cityAliasNameFilter (optional) 
     * @param cityDeliveryIndicatorFilter (optional) 
     * @param cityMixedCaseFilter (optional) 
     * @param cityStateKeyFilter (optional) 
     * @param cityTypeFilter (optional) 
     * @param classificationCodeFilter (optional) 
     * @param countyFilter (optional) 
     * @param countyANSIFilter (optional) 
     * @param countyFIPSFilter (optional) 
     * @param countyMixedCaseFilter (optional) 
     * @param dayLightSavingFilter (optional) 
     * @param divisionFilter (optional) 
     * @param elevationFilter (optional) 
     * @param facilityCodeFilter (optional) 
     * @param femalePopulationFilter (optional) 
     * @param financeNumberFilter (optional) 
     * @param hawaiianPopulationFilter (optional) 
     * @param hispanicPopulationFilter (optional) 
     * @param householdsPerZipCodeFilter (optional) 
     * @param incomePerHouseholdFilter (optional) 
     * @param indianPopulationFilter (optional) 
     * @param latitudeFilter (optional) 
     * @param longitudeFilter (optional) 
     * @param mSAFilter (optional) 
     * @param mSA_NameFilter (optional) 
     * @param mailingNameFilter (optional) 
     * @param malePopulationFilter (optional) 
     * @param multiCountyFilter (optional) 
     * @param otherPopulationFilter (optional) 
     * @param pMSAFilter (optional) 
     * @param pMSA_NameFilter (optional) 
     * @param personsPerHouseholdFilter (optional) 
     * @param populationFilter (optional) 
     * @param preferredLastLineKeyFilter (optional) 
     * @param primaryRecordFilter (optional) 
     * @param regionFilter (optional) 
     * @param stateFilter (optional) 
     * @param stateANSIFilter (optional) 
     * @param stateFIPSFilter (optional) 
     * @param stateFullNameFilter (optional) 
     * @param timeZoneFilter (optional) 
     * @param uniqueZIPNameFilter (optional) 
     * @param whitePopulationFilter (optional) 
     * @param countryNameFilter (optional) 
     * @param stateNameFilter (optional) 
     * @param cityNameFilter (optional) 
     * @param countyNameFilter (optional) 
     * @return Success
     */
    getZipCodesToExcel(filter: string | undefined, nameFilter: string | undefined, areaCodeFilter: string | undefined, asianPopulationFilter: string | undefined, averageHouseValueFilter: string | undefined, blackPopulationFilter: string | undefined, cBSAFilter: string | undefined, cBSA_DivFilter: string | undefined, cBSA_Div_NameFilter: string | undefined, cBSA_NameFilter: string | undefined, cBSA_TypeFilter: string | undefined, cSAFilter: string | undefined, cSANameFilter: string | undefined, carrierRouteRateSortationFilter: string | undefined, cityFilter: string | undefined, cityAliasCodeFilter: string | undefined, cityAliasMixedCaseFilter: string | undefined, cityAliasNameFilter: string | undefined, cityDeliveryIndicatorFilter: string | undefined, cityMixedCaseFilter: string | undefined, cityStateKeyFilter: string | undefined, cityTypeFilter: string | undefined, classificationCodeFilter: string | undefined, countyFilter: string | undefined, countyANSIFilter: string | undefined, countyFIPSFilter: string | undefined, countyMixedCaseFilter: string | undefined, dayLightSavingFilter: string | undefined, divisionFilter: string | undefined, elevationFilter: string | undefined, facilityCodeFilter: string | undefined, femalePopulationFilter: string | undefined, financeNumberFilter: string | undefined, hawaiianPopulationFilter: string | undefined, hispanicPopulationFilter: string | undefined, householdsPerZipCodeFilter: string | undefined, incomePerHouseholdFilter: string | undefined, indianPopulationFilter: string | undefined, latitudeFilter: string | undefined, longitudeFilter: string | undefined, mSAFilter: string | undefined, mSA_NameFilter: string | undefined, mailingNameFilter: string | undefined, malePopulationFilter: string | undefined, multiCountyFilter: string | undefined, otherPopulationFilter: string | undefined, pMSAFilter: string | undefined, pMSA_NameFilter: string | undefined, personsPerHouseholdFilter: string | undefined, populationFilter: string | undefined, preferredLastLineKeyFilter: string | undefined, primaryRecordFilter: string | undefined, regionFilter: string | undefined, stateFilter: string | undefined, stateANSIFilter: string | undefined, stateFIPSFilter: string | undefined, stateFullNameFilter: string | undefined, timeZoneFilter: string | undefined, uniqueZIPNameFilter: string | undefined, whitePopulationFilter: string | undefined, countryNameFilter: string | undefined, stateNameFilter: string | undefined, cityNameFilter: string | undefined, countyNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ZipCodes/GetZipCodesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (nameFilter === null)
            throw new Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (areaCodeFilter === null)
            throw new Error("The parameter 'areaCodeFilter' cannot be null.");
        else if (areaCodeFilter !== undefined)
            url_ += "AreaCodeFilter=" + encodeURIComponent("" + areaCodeFilter) + "&";
        if (asianPopulationFilter === null)
            throw new Error("The parameter 'asianPopulationFilter' cannot be null.");
        else if (asianPopulationFilter !== undefined)
            url_ += "AsianPopulationFilter=" + encodeURIComponent("" + asianPopulationFilter) + "&";
        if (averageHouseValueFilter === null)
            throw new Error("The parameter 'averageHouseValueFilter' cannot be null.");
        else if (averageHouseValueFilter !== undefined)
            url_ += "AverageHouseValueFilter=" + encodeURIComponent("" + averageHouseValueFilter) + "&";
        if (blackPopulationFilter === null)
            throw new Error("The parameter 'blackPopulationFilter' cannot be null.");
        else if (blackPopulationFilter !== undefined)
            url_ += "BlackPopulationFilter=" + encodeURIComponent("" + blackPopulationFilter) + "&";
        if (cBSAFilter === null)
            throw new Error("The parameter 'cBSAFilter' cannot be null.");
        else if (cBSAFilter !== undefined)
            url_ += "CBSAFilter=" + encodeURIComponent("" + cBSAFilter) + "&";
        if (cBSA_DivFilter === null)
            throw new Error("The parameter 'cBSA_DivFilter' cannot be null.");
        else if (cBSA_DivFilter !== undefined)
            url_ += "CBSA_DivFilter=" + encodeURIComponent("" + cBSA_DivFilter) + "&";
        if (cBSA_Div_NameFilter === null)
            throw new Error("The parameter 'cBSA_Div_NameFilter' cannot be null.");
        else if (cBSA_Div_NameFilter !== undefined)
            url_ += "CBSA_Div_NameFilter=" + encodeURIComponent("" + cBSA_Div_NameFilter) + "&";
        if (cBSA_NameFilter === null)
            throw new Error("The parameter 'cBSA_NameFilter' cannot be null.");
        else if (cBSA_NameFilter !== undefined)
            url_ += "CBSA_NameFilter=" + encodeURIComponent("" + cBSA_NameFilter) + "&";
        if (cBSA_TypeFilter === null)
            throw new Error("The parameter 'cBSA_TypeFilter' cannot be null.");
        else if (cBSA_TypeFilter !== undefined)
            url_ += "CBSA_TypeFilter=" + encodeURIComponent("" + cBSA_TypeFilter) + "&";
        if (cSAFilter === null)
            throw new Error("The parameter 'cSAFilter' cannot be null.");
        else if (cSAFilter !== undefined)
            url_ += "CSAFilter=" + encodeURIComponent("" + cSAFilter) + "&";
        if (cSANameFilter === null)
            throw new Error("The parameter 'cSANameFilter' cannot be null.");
        else if (cSANameFilter !== undefined)
            url_ += "CSANameFilter=" + encodeURIComponent("" + cSANameFilter) + "&";
        if (carrierRouteRateSortationFilter === null)
            throw new Error("The parameter 'carrierRouteRateSortationFilter' cannot be null.");
        else if (carrierRouteRateSortationFilter !== undefined)
            url_ += "CarrierRouteRateSortationFilter=" + encodeURIComponent("" + carrierRouteRateSortationFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (cityAliasCodeFilter === null)
            throw new Error("The parameter 'cityAliasCodeFilter' cannot be null.");
        else if (cityAliasCodeFilter !== undefined)
            url_ += "CityAliasCodeFilter=" + encodeURIComponent("" + cityAliasCodeFilter) + "&";
        if (cityAliasMixedCaseFilter === null)
            throw new Error("The parameter 'cityAliasMixedCaseFilter' cannot be null.");
        else if (cityAliasMixedCaseFilter !== undefined)
            url_ += "CityAliasMixedCaseFilter=" + encodeURIComponent("" + cityAliasMixedCaseFilter) + "&";
        if (cityAliasNameFilter === null)
            throw new Error("The parameter 'cityAliasNameFilter' cannot be null.");
        else if (cityAliasNameFilter !== undefined)
            url_ += "CityAliasNameFilter=" + encodeURIComponent("" + cityAliasNameFilter) + "&";
        if (cityDeliveryIndicatorFilter === null)
            throw new Error("The parameter 'cityDeliveryIndicatorFilter' cannot be null.");
        else if (cityDeliveryIndicatorFilter !== undefined)
            url_ += "CityDeliveryIndicatorFilter=" + encodeURIComponent("" + cityDeliveryIndicatorFilter) + "&";
        if (cityMixedCaseFilter === null)
            throw new Error("The parameter 'cityMixedCaseFilter' cannot be null.");
        else if (cityMixedCaseFilter !== undefined)
            url_ += "CityMixedCaseFilter=" + encodeURIComponent("" + cityMixedCaseFilter) + "&";
        if (cityStateKeyFilter === null)
            throw new Error("The parameter 'cityStateKeyFilter' cannot be null.");
        else if (cityStateKeyFilter !== undefined)
            url_ += "CityStateKeyFilter=" + encodeURIComponent("" + cityStateKeyFilter) + "&";
        if (cityTypeFilter === null)
            throw new Error("The parameter 'cityTypeFilter' cannot be null.");
        else if (cityTypeFilter !== undefined)
            url_ += "CityTypeFilter=" + encodeURIComponent("" + cityTypeFilter) + "&";
        if (classificationCodeFilter === null)
            throw new Error("The parameter 'classificationCodeFilter' cannot be null.");
        else if (classificationCodeFilter !== undefined)
            url_ += "ClassificationCodeFilter=" + encodeURIComponent("" + classificationCodeFilter) + "&";
        if (countyFilter === null)
            throw new Error("The parameter 'countyFilter' cannot be null.");
        else if (countyFilter !== undefined)
            url_ += "CountyFilter=" + encodeURIComponent("" + countyFilter) + "&";
        if (countyANSIFilter === null)
            throw new Error("The parameter 'countyANSIFilter' cannot be null.");
        else if (countyANSIFilter !== undefined)
            url_ += "CountyANSIFilter=" + encodeURIComponent("" + countyANSIFilter) + "&";
        if (countyFIPSFilter === null)
            throw new Error("The parameter 'countyFIPSFilter' cannot be null.");
        else if (countyFIPSFilter !== undefined)
            url_ += "CountyFIPSFilter=" + encodeURIComponent("" + countyFIPSFilter) + "&";
        if (countyMixedCaseFilter === null)
            throw new Error("The parameter 'countyMixedCaseFilter' cannot be null.");
        else if (countyMixedCaseFilter !== undefined)
            url_ += "CountyMixedCaseFilter=" + encodeURIComponent("" + countyMixedCaseFilter) + "&";
        if (dayLightSavingFilter === null)
            throw new Error("The parameter 'dayLightSavingFilter' cannot be null.");
        else if (dayLightSavingFilter !== undefined)
            url_ += "DayLightSavingFilter=" + encodeURIComponent("" + dayLightSavingFilter) + "&";
        if (divisionFilter === null)
            throw new Error("The parameter 'divisionFilter' cannot be null.");
        else if (divisionFilter !== undefined)
            url_ += "DivisionFilter=" + encodeURIComponent("" + divisionFilter) + "&";
        if (elevationFilter === null)
            throw new Error("The parameter 'elevationFilter' cannot be null.");
        else if (elevationFilter !== undefined)
            url_ += "ElevationFilter=" + encodeURIComponent("" + elevationFilter) + "&";
        if (facilityCodeFilter === null)
            throw new Error("The parameter 'facilityCodeFilter' cannot be null.");
        else if (facilityCodeFilter !== undefined)
            url_ += "FacilityCodeFilter=" + encodeURIComponent("" + facilityCodeFilter) + "&";
        if (femalePopulationFilter === null)
            throw new Error("The parameter 'femalePopulationFilter' cannot be null.");
        else if (femalePopulationFilter !== undefined)
            url_ += "FemalePopulationFilter=" + encodeURIComponent("" + femalePopulationFilter) + "&";
        if (financeNumberFilter === null)
            throw new Error("The parameter 'financeNumberFilter' cannot be null.");
        else if (financeNumberFilter !== undefined)
            url_ += "FinanceNumberFilter=" + encodeURIComponent("" + financeNumberFilter) + "&";
        if (hawaiianPopulationFilter === null)
            throw new Error("The parameter 'hawaiianPopulationFilter' cannot be null.");
        else if (hawaiianPopulationFilter !== undefined)
            url_ += "HawaiianPopulationFilter=" + encodeURIComponent("" + hawaiianPopulationFilter) + "&";
        if (hispanicPopulationFilter === null)
            throw new Error("The parameter 'hispanicPopulationFilter' cannot be null.");
        else if (hispanicPopulationFilter !== undefined)
            url_ += "HispanicPopulationFilter=" + encodeURIComponent("" + hispanicPopulationFilter) + "&";
        if (householdsPerZipCodeFilter === null)
            throw new Error("The parameter 'householdsPerZipCodeFilter' cannot be null.");
        else if (householdsPerZipCodeFilter !== undefined)
            url_ += "HouseholdsPerZipCodeFilter=" + encodeURIComponent("" + householdsPerZipCodeFilter) + "&";
        if (incomePerHouseholdFilter === null)
            throw new Error("The parameter 'incomePerHouseholdFilter' cannot be null.");
        else if (incomePerHouseholdFilter !== undefined)
            url_ += "IncomePerHouseholdFilter=" + encodeURIComponent("" + incomePerHouseholdFilter) + "&";
        if (indianPopulationFilter === null)
            throw new Error("The parameter 'indianPopulationFilter' cannot be null.");
        else if (indianPopulationFilter !== undefined)
            url_ += "IndianPopulationFilter=" + encodeURIComponent("" + indianPopulationFilter) + "&";
        if (latitudeFilter === null)
            throw new Error("The parameter 'latitudeFilter' cannot be null.");
        else if (latitudeFilter !== undefined)
            url_ += "LatitudeFilter=" + encodeURIComponent("" + latitudeFilter) + "&";
        if (longitudeFilter === null)
            throw new Error("The parameter 'longitudeFilter' cannot be null.");
        else if (longitudeFilter !== undefined)
            url_ += "LongitudeFilter=" + encodeURIComponent("" + longitudeFilter) + "&";
        if (mSAFilter === null)
            throw new Error("The parameter 'mSAFilter' cannot be null.");
        else if (mSAFilter !== undefined)
            url_ += "MSAFilter=" + encodeURIComponent("" + mSAFilter) + "&";
        if (mSA_NameFilter === null)
            throw new Error("The parameter 'mSA_NameFilter' cannot be null.");
        else if (mSA_NameFilter !== undefined)
            url_ += "MSA_NameFilter=" + encodeURIComponent("" + mSA_NameFilter) + "&";
        if (mailingNameFilter === null)
            throw new Error("The parameter 'mailingNameFilter' cannot be null.");
        else if (mailingNameFilter !== undefined)
            url_ += "MailingNameFilter=" + encodeURIComponent("" + mailingNameFilter) + "&";
        if (malePopulationFilter === null)
            throw new Error("The parameter 'malePopulationFilter' cannot be null.");
        else if (malePopulationFilter !== undefined)
            url_ += "MalePopulationFilter=" + encodeURIComponent("" + malePopulationFilter) + "&";
        if (multiCountyFilter === null)
            throw new Error("The parameter 'multiCountyFilter' cannot be null.");
        else if (multiCountyFilter !== undefined)
            url_ += "MultiCountyFilter=" + encodeURIComponent("" + multiCountyFilter) + "&";
        if (otherPopulationFilter === null)
            throw new Error("The parameter 'otherPopulationFilter' cannot be null.");
        else if (otherPopulationFilter !== undefined)
            url_ += "OtherPopulationFilter=" + encodeURIComponent("" + otherPopulationFilter) + "&";
        if (pMSAFilter === null)
            throw new Error("The parameter 'pMSAFilter' cannot be null.");
        else if (pMSAFilter !== undefined)
            url_ += "PMSAFilter=" + encodeURIComponent("" + pMSAFilter) + "&";
        if (pMSA_NameFilter === null)
            throw new Error("The parameter 'pMSA_NameFilter' cannot be null.");
        else if (pMSA_NameFilter !== undefined)
            url_ += "PMSA_NameFilter=" + encodeURIComponent("" + pMSA_NameFilter) + "&";
        if (personsPerHouseholdFilter === null)
            throw new Error("The parameter 'personsPerHouseholdFilter' cannot be null.");
        else if (personsPerHouseholdFilter !== undefined)
            url_ += "PersonsPerHouseholdFilter=" + encodeURIComponent("" + personsPerHouseholdFilter) + "&";
        if (populationFilter === null)
            throw new Error("The parameter 'populationFilter' cannot be null.");
        else if (populationFilter !== undefined)
            url_ += "PopulationFilter=" + encodeURIComponent("" + populationFilter) + "&";
        if (preferredLastLineKeyFilter === null)
            throw new Error("The parameter 'preferredLastLineKeyFilter' cannot be null.");
        else if (preferredLastLineKeyFilter !== undefined)
            url_ += "PreferredLastLineKeyFilter=" + encodeURIComponent("" + preferredLastLineKeyFilter) + "&";
        if (primaryRecordFilter === null)
            throw new Error("The parameter 'primaryRecordFilter' cannot be null.");
        else if (primaryRecordFilter !== undefined)
            url_ += "PrimaryRecordFilter=" + encodeURIComponent("" + primaryRecordFilter) + "&";
        if (regionFilter === null)
            throw new Error("The parameter 'regionFilter' cannot be null.");
        else if (regionFilter !== undefined)
            url_ += "RegionFilter=" + encodeURIComponent("" + regionFilter) + "&";
        if (stateFilter === null)
            throw new Error("The parameter 'stateFilter' cannot be null.");
        else if (stateFilter !== undefined)
            url_ += "StateFilter=" + encodeURIComponent("" + stateFilter) + "&";
        if (stateANSIFilter === null)
            throw new Error("The parameter 'stateANSIFilter' cannot be null.");
        else if (stateANSIFilter !== undefined)
            url_ += "StateANSIFilter=" + encodeURIComponent("" + stateANSIFilter) + "&";
        if (stateFIPSFilter === null)
            throw new Error("The parameter 'stateFIPSFilter' cannot be null.");
        else if (stateFIPSFilter !== undefined)
            url_ += "StateFIPSFilter=" + encodeURIComponent("" + stateFIPSFilter) + "&";
        if (stateFullNameFilter === null)
            throw new Error("The parameter 'stateFullNameFilter' cannot be null.");
        else if (stateFullNameFilter !== undefined)
            url_ += "StateFullNameFilter=" + encodeURIComponent("" + stateFullNameFilter) + "&";
        if (timeZoneFilter === null)
            throw new Error("The parameter 'timeZoneFilter' cannot be null.");
        else if (timeZoneFilter !== undefined)
            url_ += "TimeZoneFilter=" + encodeURIComponent("" + timeZoneFilter) + "&";
        if (uniqueZIPNameFilter === null)
            throw new Error("The parameter 'uniqueZIPNameFilter' cannot be null.");
        else if (uniqueZIPNameFilter !== undefined)
            url_ += "UniqueZIPNameFilter=" + encodeURIComponent("" + uniqueZIPNameFilter) + "&";
        if (whitePopulationFilter === null)
            throw new Error("The parameter 'whitePopulationFilter' cannot be null.");
        else if (whitePopulationFilter !== undefined)
            url_ += "WhitePopulationFilter=" + encodeURIComponent("" + whitePopulationFilter) + "&";
        if (countryNameFilter === null)
            throw new Error("The parameter 'countryNameFilter' cannot be null.");
        else if (countryNameFilter !== undefined)
            url_ += "CountryNameFilter=" + encodeURIComponent("" + countryNameFilter) + "&";
        if (stateNameFilter === null)
            throw new Error("The parameter 'stateNameFilter' cannot be null.");
        else if (stateNameFilter !== undefined)
            url_ += "StateNameFilter=" + encodeURIComponent("" + stateNameFilter) + "&";
        if (cityNameFilter === null)
            throw new Error("The parameter 'cityNameFilter' cannot be null.");
        else if (cityNameFilter !== undefined)
            url_ += "CityNameFilter=" + encodeURIComponent("" + cityNameFilter) + "&";
        if (countyNameFilter === null)
            throw new Error("The parameter 'countyNameFilter' cannot be null.");
        else if (countyNameFilter !== undefined)
            url_ += "CountyNameFilter=" + encodeURIComponent("" + countyNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZipCodesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZipCodesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetZipCodesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountryForTableDropdown(): Observable<ZipCodeCountryLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ZipCodes/GetAllCountryForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZipCodeCountryLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZipCodeCountryLookupTableDto[]>;
        }));
    }

    protected processGetAllCountryForTableDropdown(response: HttpResponseBase): Observable<ZipCodeCountryLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ZipCodeCountryLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllStateForTableDropdown(): Observable<ZipCodeStateLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ZipCodes/GetAllStateForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStateForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStateForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZipCodeStateLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZipCodeStateLookupTableDto[]>;
        }));
    }

    protected processGetAllStateForTableDropdown(response: HttpResponseBase): Observable<ZipCodeStateLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ZipCodeStateLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCityForTableDropdown(): Observable<ZipCodeCityLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ZipCodes/GetAllCityForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCityForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCityForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZipCodeCityLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZipCodeCityLookupTableDto[]>;
        }));
    }

    protected processGetAllCityForTableDropdown(response: HttpResponseBase): Observable<ZipCodeCityLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ZipCodeCityLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllCountyForTableDropdown(): Observable<ZipCodeCountyLookupTableDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ZipCodes/GetAllCountyForTableDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountyForTableDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountyForTableDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ZipCodeCountyLookupTableDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ZipCodeCountyLookupTableDto[]>;
        }));
    }

    protected processGetAllCountyForTableDropdown(response: HttpResponseBase): Observable<ZipCodeCountyLookupTableDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ZipCodeCountyLookupTableDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export enum AbpLoginResultType {
    Success = 1,
    InvalidUserNameOrEmailAddress = 2,
    InvalidPassword = 3,
    UserIsNotActive = 4,
    InvalidTenancyName = 5,
    TenantIsNotActive = 6,
    UserEmailIsNotConfirmed = 7,
    UnknownExternalLogin = 8,
    LockedOut = 9,
    UserPhoneNumberIsNotConfirmed = 10,
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.confirmationCode = _data["confirmationCode"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data;
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ActivateWebhookSubscriptionInput implements IActivateWebhookSubscriptionInput {
    subscriptionId!: string;
    isActive!: boolean;

    constructor(data?: IActivateWebhookSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ActivateWebhookSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateWebhookSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IActivateWebhookSubscriptionInput {
    subscriptionId: string;
    isActive: boolean;
}

export class AddNewPageInput implements IAddNewPageInput {
    dashboardName!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IAddNewPageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddNewPageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["name"] = this.name;
        data["application"] = this.application;
        return data;
    }
}

export interface IAddNewPageInput {
    dashboardName: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageOutput implements IAddNewPageOutput {
    pageId!: string | undefined;

    constructor(data?: IAddNewPageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageId = _data["pageId"];
        }
    }

    static fromJS(data: any): AddNewPageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageId"] = this.pageId;
        return data;
    }
}

export interface IAddNewPageOutput {
    pageId: string | undefined;
}

export class AddWidgetInput implements IAddWidgetInput {
    widgetId!: string | undefined;
    pageId!: string | undefined;
    dashboardName!: string | undefined;
    width!: number;
    height!: number;
    application!: string | undefined;

    constructor(data?: IAddWidgetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.pageId = _data["pageId"];
            this.dashboardName = _data["dashboardName"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddWidgetInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddWidgetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["pageId"] = this.pageId;
        data["dashboardName"] = this.dashboardName;
        data["width"] = this.width;
        data["height"] = this.height;
        data["application"] = this.application;
        return data;
    }
}

export interface IAddWidgetInput {
    widgetId: string | undefined;
    pageId: string | undefined;
    dashboardName: string | undefined;
    width: number;
    height: number;
    application: string | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverSiteUrl = _data["serverSiteUrl"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: DateTime;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean;
    userDelegationIsEnabled!: boolean;
    twoFactorCodeExpireSeconds!: number;
    features!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? DateTime.fromISO(_data["releaseDate"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.currencySign = _data["currencySign"];
            this.allowTenantsToChangeEmailSettings = _data["allowTenantsToChangeEmailSettings"];
            this.userDelegationIsEnabled = _data["userDelegationIsEnabled"];
            this.twoFactorCodeExpireSeconds = _data["twoFactorCodeExpireSeconds"];
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)![key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        data["userDelegationIsEnabled"] = this.userDelegationIsEnabled;
        data["twoFactorCodeExpireSeconds"] = this.twoFactorCodeExpireSeconds;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: DateTime;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean;
    userDelegationIsEnabled: boolean;
    twoFactorCodeExpireSeconds: number;
    features: { [key: string]: boolean; } | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDisabled = _data["isDisabled"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: DateTime;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? DateTime.fromISO(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: DateTime;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    captchaResponse!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.twoFactorVerificationCode = _data["twoFactorVerificationCode"];
            this.rememberClient = _data["rememberClient"];
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.singleSignIn = _data["singleSignIn"];
            this.returnUrl = _data["returnUrl"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    captchaResponse: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    userId!: number;
    requiresTwoFactorVerification!: boolean;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;
    c!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.userId = _data["userId"];
            this.requiresTwoFactorVerification = _data["requiresTwoFactorVerification"];
            if (Array.isArray(_data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of _data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        data["c"] = this.c;
        return data;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
    c: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IBlockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class BusinessAccountTeamBusinessLookupTableDto implements IBusinessAccountTeamBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessAccountTeamBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessAccountTeamBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessAccountTeamBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessAccountTeamBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessAccountTeamDto implements IBusinessAccountTeamDto {
    primary!: boolean;
    businessId!: number;
    employeeId!: number;
    id!: number;

    constructor(data?: IBusinessAccountTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.primary = _data["primary"];
            this.businessId = _data["businessId"];
            this.employeeId = _data["employeeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessAccountTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessAccountTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primary"] = this.primary;
        data["businessId"] = this.businessId;
        data["employeeId"] = this.employeeId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessAccountTeamDto {
    primary: boolean;
    businessId: number;
    employeeId: number;
    id: number;
}

export class BusinessAccountTeamEmployeeLookupTableDto implements IBusinessAccountTeamEmployeeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessAccountTeamEmployeeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessAccountTeamEmployeeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessAccountTeamEmployeeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessAccountTeamEmployeeLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessCityLookupTableDto implements IBusinessCityLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessCityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessCityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessCityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessCityLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessContactMapBusinessLookupTableDto implements IBusinessContactMapBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessContactMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessContactMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessContactMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessContactMapBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessContactMapContactLookupTableDto implements IBusinessContactMapContactLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessContactMapContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessContactMapContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessContactMapContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessContactMapContactLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessContactMapDto implements IBusinessContactMapDto {
    businessId!: number;
    contactId!: number;
    id!: number;

    constructor(data?: IBusinessContactMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.contactId = _data["contactId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessContactMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessContactMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessContactMapDto {
    businessId: number;
    contactId: number;
    id: number;
}

export class BusinessCountryLookupTableDto implements IBusinessCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessDto implements IBusinessDto {
    name!: string | undefined;
    tradeName!: string | undefined;
    description!: string | undefined;
    customId!: string | undefined;
    yearOfEstablishment!: string | undefined;
    locationTitle!: string | undefined;
    fullAddress!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    city!: string | undefined;
    zipCode!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    website!: string | undefined;
    einTaxId!: string | undefined;
    industry!: string | undefined;
    internalRemarks!: string | undefined;
    verified!: boolean;
    facebook!: string | undefined;
    linkedIn!: string | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    cityId!: number | undefined;
    logoMediaLibraryId!: number | undefined;
    id!: number;

    constructor(data?: IBusinessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tradeName = _data["tradeName"];
            this.description = _data["description"];
            this.customId = _data["customId"];
            this.yearOfEstablishment = _data["yearOfEstablishment"];
            this.locationTitle = _data["locationTitle"];
            this.fullAddress = _data["fullAddress"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.einTaxId = _data["einTaxId"];
            this.industry = _data["industry"];
            this.internalRemarks = _data["internalRemarks"];
            this.verified = _data["verified"];
            this.facebook = _data["facebook"];
            this.linkedIn = _data["linkedIn"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.cityId = _data["cityId"];
            this.logoMediaLibraryId = _data["logoMediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tradeName"] = this.tradeName;
        data["description"] = this.description;
        data["customId"] = this.customId;
        data["yearOfEstablishment"] = this.yearOfEstablishment;
        data["locationTitle"] = this.locationTitle;
        data["fullAddress"] = this.fullAddress;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["website"] = this.website;
        data["einTaxId"] = this.einTaxId;
        data["industry"] = this.industry;
        data["internalRemarks"] = this.internalRemarks;
        data["verified"] = this.verified;
        data["facebook"] = this.facebook;
        data["linkedIn"] = this.linkedIn;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["cityId"] = this.cityId;
        data["logoMediaLibraryId"] = this.logoMediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessDto {
    name: string | undefined;
    tradeName: string | undefined;
    description: string | undefined;
    customId: string | undefined;
    yearOfEstablishment: string | undefined;
    locationTitle: string | undefined;
    fullAddress: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    city: string | undefined;
    zipCode: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    website: string | undefined;
    einTaxId: string | undefined;
    industry: string | undefined;
    internalRemarks: string | undefined;
    verified: boolean;
    facebook: string | undefined;
    linkedIn: string | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    cityId: number | undefined;
    logoMediaLibraryId: number | undefined;
    id: number;
}

export class BusinessJobMapBusinessLookupTableDto implements IBusinessJobMapBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessJobMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessJobMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessJobMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessJobMapBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessJobMapDto implements IBusinessJobMapDto {
    businessId!: number;
    jobId!: number;
    id!: number;

    constructor(data?: IBusinessJobMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.jobId = _data["jobId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessJobMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessJobMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["jobId"] = this.jobId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessJobMapDto {
    businessId: number;
    jobId: number;
    id: number;
}

export class BusinessJobMapJobLookupTableDto implements IBusinessJobMapJobLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessJobMapJobLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessJobMapJobLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessJobMapJobLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessJobMapJobLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessMediaLibraryLookupTableDto implements IBusinessMediaLibraryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessMediaLibraryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessNoteBusinessLookupTableDto implements IBusinessNoteBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessNoteBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessNoteBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessNoteBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessNoteBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessNoteDto implements IBusinessNoteDto {
    notes!: string | undefined;
    businessId!: number;
    id!: number;

    constructor(data?: IBusinessNoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notes = _data["notes"];
            this.businessId = _data["businessId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notes"] = this.notes;
        data["businessId"] = this.businessId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessNoteDto {
    notes: string | undefined;
    businessId: number;
    id: number;
}

export class BusinessProductMapBusinessLookupTableDto implements IBusinessProductMapBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessProductMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessProductMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProductMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessProductMapBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessProductMapDto implements IBusinessProductMapDto {
    businessId!: number;
    productId!: number;
    id!: number;

    constructor(data?: IBusinessProductMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.productId = _data["productId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessProductMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProductMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessProductMapDto {
    businessId: number;
    productId: number;
    id: number;
}

export class BusinessProductMapProductLookupTableDto implements IBusinessProductMapProductLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessProductMapProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessProductMapProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessProductMapProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessProductMapProductLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessStateLookupTableDto implements IBusinessStateLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessStateLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessStoreMapBusinessLookupTableDto implements IBusinessStoreMapBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessStoreMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessStoreMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessStoreMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessStoreMapBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessStoreMapDto implements IBusinessStoreMapDto {
    businessId!: number;
    storeId!: number;
    id!: number;

    constructor(data?: IBusinessStoreMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessStoreMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessStoreMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessStoreMapDto {
    businessId: number;
    storeId: number;
    id: number;
}

export class BusinessStoreMapStoreLookupTableDto implements IBusinessStoreMapStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessStoreMapStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessStoreMapStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessStoreMapStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessStoreMapStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessTagBusinessLookupTableDto implements IBusinessTagBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessTagBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessTagBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessTagBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessTagBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessTagDto implements IBusinessTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    businessId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number;

    constructor(data?: IBusinessTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.businessId = _data["businessId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["businessId"] = this.businessId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    businessId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number;
}

export class BusinessTagMasterTagCategoryLookupTableDto implements IBusinessTagMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessTagMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessTagMasterTagLookupTableDto implements IBusinessTagMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessTagMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessTaskMapBusinessLookupTableDto implements IBusinessTaskMapBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessTaskMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessTaskMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessTaskMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessTaskMapBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessTaskMapDto implements IBusinessTaskMapDto {
    businessId!: number;
    taskEventId!: number;
    id!: number;

    constructor(data?: IBusinessTaskMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.taskEventId = _data["taskEventId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessTaskMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessTaskMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["taskEventId"] = this.taskEventId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessTaskMapDto {
    businessId: number;
    taskEventId: number;
    id: number;
}

export class BusinessTaskMapTaskEventLookupTableDto implements IBusinessTaskMapTaskEventLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessTaskMapTaskEventLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessTaskMapTaskEventLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessTaskMapTaskEventLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessTaskMapTaskEventLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessUserBusinessLookupTableDto implements IBusinessUserBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessUserBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessUserBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUserBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessUserBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class BusinessUserDto implements IBusinessUserDto {
    businessId!: number;
    userId!: number;
    id!: number;

    constructor(data?: IBusinessUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BusinessUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data;
    }
}

export interface IBusinessUserDto {
    businessId: number;
    userId: number;
    id: number;
}

export class BusinessUserUserLookupTableDto implements IBusinessUserUserLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IBusinessUserUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): BusinessUserUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessUserUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IBusinessUserUserLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.gateway = _data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data;
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export enum ChartDateInterval {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number;
    tenantId!: number | undefined;
    targetUserId!: number;
    targetTenantId!: number | undefined;
    side!: ChatSide;
    readState!: ChatMessageReadState;
    receiverReadState!: ChatMessageReadState;
    message!: string | undefined;
    creationTime!: DateTime;
    sharedMessageId!: string | undefined;
    id!: number;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.targetUserId = _data["targetUserId"];
            this.targetTenantId = _data["targetTenantId"];
            this.side = _data["side"];
            this.readState = _data["readState"];
            this.receiverReadState = _data["receiverReadState"];
            this.message = _data["message"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = _data["sharedMessageId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data;
    }
}

export interface IChatMessageDto {
    userId: number;
    tenantId: number | undefined;
    targetUserId: number;
    targetTenantId: number | undefined;
    side: ChatSide;
    readState: ChatMessageReadState;
    receiverReadState: ChatMessageReadState;
    message: string | undefined;
    creationTime: DateTime;
    sharedMessageId: string | undefined;
    id: number;
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDatabaseExist = _data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data;
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean;
}

export class CityCountryLookupTableDto implements ICityCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ICityCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CityCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICityCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class CityCountyLookupTableDto implements ICityCountyLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ICityCountyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CityCountyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityCountyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICityCountyLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class CityDto implements ICityDto {
    name!: string | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    countyId!: number | undefined;
    id!: number;

    constructor(data?: ICityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.countyId = _data["countyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["countyId"] = this.countyId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICityDto {
    name: string | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    countyId: number | undefined;
    id: number;
}

export class CityStateLookupTableDto implements ICityStateLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ICityStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CityStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICityStateLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class CleanValuesInput implements ICleanValuesInput {
    dynamicEntityPropertyId!: number;
    entityId!: string | undefined;

    constructor(data?: ICleanValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): CleanValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CleanValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["entityId"] = this.entityId;
        return data;
    }
}

export interface ICleanValuesInput {
    dynamicEntityPropertyId: number;
    entityId: string | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class ConnectChannelDto implements IConnectChannelDto {
    name!: string | undefined;
    id!: number;

    constructor(data?: IConnectChannelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ConnectChannelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectChannelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IConnectChannelDto {
    name: string | undefined;
    id: number;
}

export class ContactCountryLookupTableDto implements IContactCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IContactCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ContactCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IContactCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ContactDto implements IContactDto {
    fullName!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    fullAddress!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    city!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    mobile!: string | undefined;
    officePhone!: string | undefined;
    countryCode!: string | undefined;
    personalEmail!: string | undefined;
    businessEmail!: string | undefined;
    jobTitle!: string | undefined;
    companyName!: string | undefined;
    aiDataTag!: string | undefined;
    facebook!: string | undefined;
    linkedIn!: string | undefined;
    referred!: boolean;
    verified!: boolean;
    score!: number | undefined;
    referredByUserId!: number | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    membershipTypeId!: number | undefined;
    isApplicant!: boolean | undefined;
    active!: boolean | undefined;
    pictureId!: string | undefined;
    id!: number;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullAddress = _data["fullAddress"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.city = _data["city"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : <any>undefined;
            this.mobile = _data["mobile"];
            this.officePhone = _data["officePhone"];
            this.countryCode = _data["countryCode"];
            this.personalEmail = _data["personalEmail"];
            this.businessEmail = _data["businessEmail"];
            this.jobTitle = _data["jobTitle"];
            this.companyName = _data["companyName"];
            this.aiDataTag = _data["aiDataTag"];
            this.facebook = _data["facebook"];
            this.linkedIn = _data["linkedIn"];
            this.referred = _data["referred"];
            this.verified = _data["verified"];
            this.score = _data["score"];
            this.referredByUserId = _data["referredByUserId"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.membershipTypeId = _data["membershipTypeId"];
            this.isApplicant = _data["isApplicant"];
            this.active = _data["active"];
            this.pictureId = _data["pictureId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullAddress"] = this.fullAddress;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["city"] = this.city;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : <any>undefined;
        data["mobile"] = this.mobile;
        data["officePhone"] = this.officePhone;
        data["countryCode"] = this.countryCode;
        data["personalEmail"] = this.personalEmail;
        data["businessEmail"] = this.businessEmail;
        data["jobTitle"] = this.jobTitle;
        data["companyName"] = this.companyName;
        data["aiDataTag"] = this.aiDataTag;
        data["facebook"] = this.facebook;
        data["linkedIn"] = this.linkedIn;
        data["referred"] = this.referred;
        data["verified"] = this.verified;
        data["score"] = this.score;
        data["referredByUserId"] = this.referredByUserId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["membershipTypeId"] = this.membershipTypeId;
        data["isApplicant"] = this.isApplicant;
        data["active"] = this.active;
        data["pictureId"] = this.pictureId;
        data["id"] = this.id;
        return data;
    }
}

export interface IContactDto {
    fullName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fullAddress: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    city: string | undefined;
    dateOfBirth: DateTime | undefined;
    mobile: string | undefined;
    officePhone: string | undefined;
    countryCode: string | undefined;
    personalEmail: string | undefined;
    businessEmail: string | undefined;
    jobTitle: string | undefined;
    companyName: string | undefined;
    aiDataTag: string | undefined;
    facebook: string | undefined;
    linkedIn: string | undefined;
    referred: boolean;
    verified: boolean;
    score: number | undefined;
    referredByUserId: number | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    membershipTypeId: number | undefined;
    isApplicant: boolean | undefined;
    active: boolean | undefined;
    pictureId: string | undefined;
    id: number;
}

export class ContactMembershipTypeLookupTableDto implements IContactMembershipTypeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IContactMembershipTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ContactMembershipTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactMembershipTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IContactMembershipTypeLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ContactStateLookupTableDto implements IContactStateLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IContactStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ContactStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IContactStateLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ContactTagContactLookupTableDto implements IContactTagContactLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IContactTagContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ContactTagContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IContactTagContactLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ContactTagDto implements IContactTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    contactId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number;

    constructor(data?: IContactTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.contactId = _data["contactId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContactTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["contactId"] = this.contactId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface IContactTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    contactId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number;
}

export class ContactTagMasterTagCategoryLookupTableDto implements IContactTagMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IContactTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ContactTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IContactTagMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ContactTagMasterTagLookupTableDto implements IContactTagMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IContactTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ContactTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IContactTagMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ContactUserLookupTableDto implements IContactUserLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IContactUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ContactUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IContactUserLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ContractTypeDto implements IContractTypeDto {
    name!: string | undefined;
    id!: number;

    constructor(data?: IContractTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ContractTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IContractTypeDto {
    name: string | undefined;
    id: number;
}

export class CountryDto implements ICountryDto {
    name!: string | undefined;
    ticker!: string | undefined;
    flagIcon!: string | undefined;
    phoneCode!: string | undefined;
    id!: number;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.ticker = _data["ticker"];
            this.flagIcon = _data["flagIcon"];
            this.phoneCode = _data["phoneCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["ticker"] = this.ticker;
        data["flagIcon"] = this.flagIcon;
        data["phoneCode"] = this.phoneCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ICountryDto {
    name: string | undefined;
    ticker: string | undefined;
    flagIcon: string | undefined;
    phoneCode: string | undefined;
    id: number;
}

export class CountyCountryLookupTableDto implements ICountyCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ICountyCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CountyCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountyCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICountyCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class CountyDto implements ICountyDto {
    name!: string | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    id!: number;

    constructor(data?: ICountyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CountyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICountyDto {
    name: string | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    id: number;
}

export class CountyStateLookupTableDto implements ICountyStateLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ICountyStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CountyStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountyStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICountyStateLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionCreateDto.fromJS(_data["edition"]) : new EditionCreateDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionPaymentId = _data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data;
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number;
}

export class CreateMassNotificationInput implements ICreateMassNotificationInput {
    message!: string | undefined;
    severity!: NotificationSeverity;
    userIds!: number[] | undefined;
    organizationUnitIds!: number[] | undefined;
    targetNotifiers!: string[] | undefined;

    constructor(data?: ICreateMassNotificationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.severity = _data["severity"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            if (Array.isArray(_data["organizationUnitIds"])) {
                this.organizationUnitIds = [] as any;
                for (let item of _data["organizationUnitIds"])
                    this.organizationUnitIds!.push(item);
            }
            if (Array.isArray(_data["targetNotifiers"])) {
                this.targetNotifiers = [] as any;
                for (let item of _data["targetNotifiers"])
                    this.targetNotifiers!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateMassNotificationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMassNotificationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["severity"] = this.severity;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        if (Array.isArray(this.organizationUnitIds)) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        if (Array.isArray(this.targetNotifiers)) {
            data["targetNotifiers"] = [];
            for (let item of this.targetNotifiers)
                data["targetNotifiers"].push(item);
        }
        return data;
    }
}

export interface ICreateMassNotificationInput {
    message: string | undefined;
    severity: NotificationSeverity;
    userIds: number[] | undefined;
    organizationUnitIds: number[] | undefined;
    targetNotifiers: string[] | undefined;
}

export class CreateOrEditBusinessAccountTeamDto implements ICreateOrEditBusinessAccountTeamDto {
    primary!: boolean;
    businessId!: number;
    employeeId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusinessAccountTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.primary = _data["primary"];
            this.businessId = _data["businessId"];
            this.employeeId = _data["employeeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusinessAccountTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusinessAccountTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primary"] = this.primary;
        data["businessId"] = this.businessId;
        data["employeeId"] = this.employeeId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBusinessAccountTeamDto {
    primary: boolean;
    businessId: number;
    employeeId: number;
    id: number | undefined;
}

export class CreateOrEditBusinessContactMapDto implements ICreateOrEditBusinessContactMapDto {
    businessId!: number;
    contactId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusinessContactMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.contactId = _data["contactId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusinessContactMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusinessContactMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBusinessContactMapDto {
    businessId: number;
    contactId: number;
    id: number | undefined;
}

export class CreateOrEditBusinessDto implements ICreateOrEditBusinessDto {
    name!: string;
    tradeName!: string | undefined;
    description!: string | undefined;
    customId!: string | undefined;
    yearOfEstablishment!: string | undefined;
    locationTitle!: string | undefined;
    fullAddress!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    city!: string | undefined;
    zipCode!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    website!: string | undefined;
    einTaxId!: string | undefined;
    industry!: string | undefined;
    internalRemarks!: string | undefined;
    verified!: boolean;
    facebook!: string | undefined;
    linkedIn!: string | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    cityId!: number | undefined;
    logoMediaLibraryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusinessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tradeName = _data["tradeName"];
            this.description = _data["description"];
            this.customId = _data["customId"];
            this.yearOfEstablishment = _data["yearOfEstablishment"];
            this.locationTitle = _data["locationTitle"];
            this.fullAddress = _data["fullAddress"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.email = _data["email"];
            this.website = _data["website"];
            this.einTaxId = _data["einTaxId"];
            this.industry = _data["industry"];
            this.internalRemarks = _data["internalRemarks"];
            this.verified = _data["verified"];
            this.facebook = _data["facebook"];
            this.linkedIn = _data["linkedIn"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.cityId = _data["cityId"];
            this.logoMediaLibraryId = _data["logoMediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusinessDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusinessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tradeName"] = this.tradeName;
        data["description"] = this.description;
        data["customId"] = this.customId;
        data["yearOfEstablishment"] = this.yearOfEstablishment;
        data["locationTitle"] = this.locationTitle;
        data["fullAddress"] = this.fullAddress;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["website"] = this.website;
        data["einTaxId"] = this.einTaxId;
        data["industry"] = this.industry;
        data["internalRemarks"] = this.internalRemarks;
        data["verified"] = this.verified;
        data["facebook"] = this.facebook;
        data["linkedIn"] = this.linkedIn;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["cityId"] = this.cityId;
        data["logoMediaLibraryId"] = this.logoMediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBusinessDto {
    name: string;
    tradeName: string | undefined;
    description: string | undefined;
    customId: string | undefined;
    yearOfEstablishment: string | undefined;
    locationTitle: string | undefined;
    fullAddress: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    city: string | undefined;
    zipCode: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    phone: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    website: string | undefined;
    einTaxId: string | undefined;
    industry: string | undefined;
    internalRemarks: string | undefined;
    verified: boolean;
    facebook: string | undefined;
    linkedIn: string | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    cityId: number | undefined;
    logoMediaLibraryId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditBusinessJobMapDto implements ICreateOrEditBusinessJobMapDto {
    businessId!: number;
    jobId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusinessJobMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.jobId = _data["jobId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusinessJobMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusinessJobMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["jobId"] = this.jobId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBusinessJobMapDto {
    businessId: number;
    jobId: number;
    id: number | undefined;
}

export class CreateOrEditBusinessNoteDto implements ICreateOrEditBusinessNoteDto {
    notes!: string | undefined;
    businessId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusinessNoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notes = _data["notes"];
            this.businessId = _data["businessId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusinessNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusinessNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notes"] = this.notes;
        data["businessId"] = this.businessId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBusinessNoteDto {
    notes: string | undefined;
    businessId: number;
    id: number | undefined;
}

export class CreateOrEditBusinessProductMapDto implements ICreateOrEditBusinessProductMapDto {
    businessId!: number;
    productId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusinessProductMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.productId = _data["productId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusinessProductMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusinessProductMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBusinessProductMapDto {
    businessId: number;
    productId: number;
    id: number | undefined;
}

export class CreateOrEditBusinessStoreMapDto implements ICreateOrEditBusinessStoreMapDto {
    businessId!: number;
    storeId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusinessStoreMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusinessStoreMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusinessStoreMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBusinessStoreMapDto {
    businessId: number;
    storeId: number;
    id: number | undefined;
}

export class CreateOrEditBusinessTagDto implements ICreateOrEditBusinessTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    businessId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusinessTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.businessId = _data["businessId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusinessTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusinessTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["businessId"] = this.businessId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBusinessTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    businessId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditBusinessTaskMapDto implements ICreateOrEditBusinessTaskMapDto {
    businessId!: number;
    taskEventId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusinessTaskMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.taskEventId = _data["taskEventId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusinessTaskMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusinessTaskMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["taskEventId"] = this.taskEventId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBusinessTaskMapDto {
    businessId: number;
    taskEventId: number;
    id: number | undefined;
}

export class CreateOrEditBusinessUserDto implements ICreateOrEditBusinessUserDto {
    businessId!: number;
    userId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusinessUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessId = _data["businessId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusinessUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusinessUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessId"] = this.businessId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBusinessUserDto {
    businessId: number;
    userId: number;
    id: number | undefined;
}

export class CreateOrEditCityDto implements ICreateOrEditCityDto {
    name!: string;
    countryId!: number | undefined;
    stateId!: number | undefined;
    countyId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.countyId = _data["countyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["countyId"] = this.countyId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditCityDto {
    name: string;
    countryId: number | undefined;
    stateId: number | undefined;
    countyId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditConnectChannelDto implements ICreateOrEditConnectChannelDto {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditConnectChannelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditConnectChannelDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditConnectChannelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditConnectChannelDto {
    name: string | undefined;
    id: number | undefined;
}

export class CreateOrEditContactDto implements ICreateOrEditContactDto {
    fullName!: string;
    firstName!: string;
    lastName!: string | undefined;
    fullAddress!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    city!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    mobile!: string | undefined;
    officePhone!: string | undefined;
    countryCode!: string | undefined;
    personalEmail!: string | undefined;
    businessEmail!: string | undefined;
    jobTitle!: string | undefined;
    companyName!: string | undefined;
    profile!: string | undefined;
    aiDataTag!: string | undefined;
    facebook!: string | undefined;
    linkedIn!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    referred!: boolean;
    fax!: string | undefined;
    verified!: boolean;
    score!: number | undefined;
    referredByUserId!: number | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    membershipTypeId!: number | undefined;
    isApplicant!: boolean | undefined;
    active!: boolean | undefined;
    pictureId!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullAddress = _data["fullAddress"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.city = _data["city"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : <any>undefined;
            this.mobile = _data["mobile"];
            this.officePhone = _data["officePhone"];
            this.countryCode = _data["countryCode"];
            this.personalEmail = _data["personalEmail"];
            this.businessEmail = _data["businessEmail"];
            this.jobTitle = _data["jobTitle"];
            this.companyName = _data["companyName"];
            this.profile = _data["profile"];
            this.aiDataTag = _data["aiDataTag"];
            this.facebook = _data["facebook"];
            this.linkedIn = _data["linkedIn"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.referred = _data["referred"];
            this.fax = _data["fax"];
            this.verified = _data["verified"];
            this.score = _data["score"];
            this.referredByUserId = _data["referredByUserId"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.membershipTypeId = _data["membershipTypeId"];
            this.isApplicant = _data["isApplicant"];
            this.active = _data["active"];
            this.pictureId = _data["pictureId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullAddress"] = this.fullAddress;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["city"] = this.city;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : <any>undefined;
        data["mobile"] = this.mobile;
        data["officePhone"] = this.officePhone;
        data["countryCode"] = this.countryCode;
        data["personalEmail"] = this.personalEmail;
        data["businessEmail"] = this.businessEmail;
        data["jobTitle"] = this.jobTitle;
        data["companyName"] = this.companyName;
        data["profile"] = this.profile;
        data["aiDataTag"] = this.aiDataTag;
        data["facebook"] = this.facebook;
        data["linkedIn"] = this.linkedIn;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["referred"] = this.referred;
        data["fax"] = this.fax;
        data["verified"] = this.verified;
        data["score"] = this.score;
        data["referredByUserId"] = this.referredByUserId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["membershipTypeId"] = this.membershipTypeId;
        data["isApplicant"] = this.isApplicant;
        data["active"] = this.active;
        data["pictureId"] = this.pictureId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditContactDto {
    fullName: string;
    firstName: string;
    lastName: string | undefined;
    fullAddress: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    city: string | undefined;
    dateOfBirth: DateTime | undefined;
    mobile: string | undefined;
    officePhone: string | undefined;
    countryCode: string | undefined;
    personalEmail: string | undefined;
    businessEmail: string | undefined;
    jobTitle: string | undefined;
    companyName: string | undefined;
    profile: string | undefined;
    aiDataTag: string | undefined;
    facebook: string | undefined;
    linkedIn: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    referred: boolean;
    fax: string | undefined;
    verified: boolean;
    score: number | undefined;
    referredByUserId: number | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    membershipTypeId: number | undefined;
    isApplicant: boolean | undefined;
    active: boolean | undefined;
    pictureId: string | undefined;
    id: number | undefined;
}

export class CreateOrEditContactTagDto implements ICreateOrEditContactTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    contactId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditContactTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.contactId = _data["contactId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditContactTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditContactTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["contactId"] = this.contactId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditContactTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    contactId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditContractTypeDto implements ICreateOrEditContractTypeDto {
    name!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditContractTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditContractTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditContractTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditContractTypeDto {
    name: string;
    id: number | undefined;
}

export class CreateOrEditCountryDto implements ICreateOrEditCountryDto {
    name!: string;
    ticker!: string | undefined;
    flagIcon!: string | undefined;
    phoneCode!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.ticker = _data["ticker"];
            this.flagIcon = _data["flagIcon"];
            this.phoneCode = _data["phoneCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["ticker"] = this.ticker;
        data["flagIcon"] = this.flagIcon;
        data["phoneCode"] = this.phoneCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditCountryDto {
    name: string;
    ticker: string | undefined;
    flagIcon: string | undefined;
    phoneCode: string | undefined;
    id: number | undefined;
}

export class CreateOrEditCountyDto implements ICreateOrEditCountyDto {
    name!: string;
    countryId!: number | undefined;
    stateId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCountyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCountyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCountyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditCountyDto {
    name: string;
    countryId: number | undefined;
    stateId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditCurrencyDto implements ICreateOrEditCurrencyDto {
    name!: string;
    ticker!: string | undefined;
    icon!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.ticker = _data["ticker"];
            this.icon = _data["icon"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["ticker"] = this.ticker;
        data["icon"] = this.icon;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditCurrencyDto {
    name: string;
    ticker: string | undefined;
    icon: string | undefined;
    id: number | undefined;
}

export class CreateOrEditDocumentTypeDto implements ICreateOrEditDocumentTypeDto {
    name!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditDocumentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDocumentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDocumentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditDocumentTypeDto {
    name: string;
    id: number | undefined;
}

export class CreateOrEditEmailTemplateDto implements ICreateOrEditEmailTemplateDto {
    subject!: string;
    content!: string;
    published!: boolean;
    id!: number | undefined;

    constructor(data?: ICreateOrEditEmailTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.content = _data["content"];
            this.published = _data["published"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEmailTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEmailTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["content"] = this.content;
        data["published"] = this.published;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditEmailTemplateDto {
    subject: string;
    content: string;
    published: boolean;
    id: number | undefined;
}

export class CreateOrEditEmployeeDto implements ICreateOrEditEmployeeDto {
    name!: string;
    firstName!: string;
    lastName!: string | undefined;
    fullAddress!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    city!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    mobile!: string | undefined;
    officePhone!: string | undefined;
    personalEmail!: string | undefined;
    businessEmail!: string | undefined;
    jobTitle!: string | undefined;
    companyName!: string | undefined;
    profile!: string | undefined;
    hireDate!: DateTime | undefined;
    facebook!: string | undefined;
    linkedIn!: string | undefined;
    fax!: string | undefined;
    profilePictureId!: string;
    currentEmployee!: boolean;
    stateId!: number | undefined;
    countryId!: number | undefined;
    contactId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullAddress = _data["fullAddress"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.city = _data["city"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : <any>undefined;
            this.mobile = _data["mobile"];
            this.officePhone = _data["officePhone"];
            this.personalEmail = _data["personalEmail"];
            this.businessEmail = _data["businessEmail"];
            this.jobTitle = _data["jobTitle"];
            this.companyName = _data["companyName"];
            this.profile = _data["profile"];
            this.hireDate = _data["hireDate"] ? DateTime.fromISO(_data["hireDate"].toString()) : <any>undefined;
            this.facebook = _data["facebook"];
            this.linkedIn = _data["linkedIn"];
            this.fax = _data["fax"];
            this.profilePictureId = _data["profilePictureId"];
            this.currentEmployee = _data["currentEmployee"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.contactId = _data["contactId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullAddress"] = this.fullAddress;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["city"] = this.city;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : <any>undefined;
        data["mobile"] = this.mobile;
        data["officePhone"] = this.officePhone;
        data["personalEmail"] = this.personalEmail;
        data["businessEmail"] = this.businessEmail;
        data["jobTitle"] = this.jobTitle;
        data["companyName"] = this.companyName;
        data["profile"] = this.profile;
        data["hireDate"] = this.hireDate ? this.hireDate.toString() : <any>undefined;
        data["facebook"] = this.facebook;
        data["linkedIn"] = this.linkedIn;
        data["fax"] = this.fax;
        data["profilePictureId"] = this.profilePictureId;
        data["currentEmployee"] = this.currentEmployee;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditEmployeeDto {
    name: string;
    firstName: string;
    lastName: string | undefined;
    fullAddress: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    city: string | undefined;
    dateOfBirth: DateTime | undefined;
    mobile: string | undefined;
    officePhone: string | undefined;
    personalEmail: string | undefined;
    businessEmail: string | undefined;
    jobTitle: string | undefined;
    companyName: string | undefined;
    profile: string | undefined;
    hireDate: DateTime | undefined;
    facebook: string | undefined;
    linkedIn: string | undefined;
    fax: string | undefined;
    profilePictureId: string;
    currentEmployee: boolean;
    stateId: number | undefined;
    countryId: number | undefined;
    contactId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditEmployeeTagDto implements ICreateOrEditEmployeeTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    employeeId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditEmployeeTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.employeeId = _data["employeeId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEmployeeTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEmployeeTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["employeeId"] = this.employeeId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditEmployeeTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    employeeId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditHubDto implements ICreateOrEditHubDto {
    name!: string;
    description!: string | undefined;
    estimatedPopulation!: number | undefined;
    hasParentHub!: boolean;
    parentHubId!: number | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    live!: boolean;
    url!: string | undefined;
    officeFullAddress!: string | undefined;
    partnerOrOwned!: boolean;
    phone!: string | undefined;
    yearlyRevenue!: string | undefined;
    displaySequence!: number | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    cityId!: number | undefined;
    countyId!: number | undefined;
    hubTypeId!: number;
    currencyId!: number | undefined;
    pictureMediaLibraryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditHubDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.estimatedPopulation = _data["estimatedPopulation"];
            this.hasParentHub = _data["hasParentHub"];
            this.parentHubId = _data["parentHubId"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.live = _data["live"];
            this.url = _data["url"];
            this.officeFullAddress = _data["officeFullAddress"];
            this.partnerOrOwned = _data["partnerOrOwned"];
            this.phone = _data["phone"];
            this.yearlyRevenue = _data["yearlyRevenue"];
            this.displaySequence = _data["displaySequence"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.cityId = _data["cityId"];
            this.countyId = _data["countyId"];
            this.hubTypeId = _data["hubTypeId"];
            this.currencyId = _data["currencyId"];
            this.pictureMediaLibraryId = _data["pictureMediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditHubDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditHubDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["estimatedPopulation"] = this.estimatedPopulation;
        data["hasParentHub"] = this.hasParentHub;
        data["parentHubId"] = this.parentHubId;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["live"] = this.live;
        data["url"] = this.url;
        data["officeFullAddress"] = this.officeFullAddress;
        data["partnerOrOwned"] = this.partnerOrOwned;
        data["phone"] = this.phone;
        data["yearlyRevenue"] = this.yearlyRevenue;
        data["displaySequence"] = this.displaySequence;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["cityId"] = this.cityId;
        data["countyId"] = this.countyId;
        data["hubTypeId"] = this.hubTypeId;
        data["currencyId"] = this.currencyId;
        data["pictureMediaLibraryId"] = this.pictureMediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditHubDto {
    name: string;
    description: string | undefined;
    estimatedPopulation: number | undefined;
    hasParentHub: boolean;
    parentHubId: number | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    live: boolean;
    url: string | undefined;
    officeFullAddress: string | undefined;
    partnerOrOwned: boolean;
    phone: string | undefined;
    yearlyRevenue: string | undefined;
    displaySequence: number | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    cityId: number | undefined;
    countyId: number | undefined;
    hubTypeId: number;
    currencyId: number | undefined;
    pictureMediaLibraryId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditHubTypeDto implements ICreateOrEditHubTypeDto {
    name!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditHubTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditHubTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditHubTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditHubTypeDto {
    name: string;
    id: number | undefined;
}

export class CreateOrEditJobDto implements ICreateOrEditJobDto {
    title!: string;
    fullTimeJobOrGigWorkProject!: boolean;
    remoteWorkOrOnSiteWork!: boolean;
    salaryBasedOrFixedPrice!: boolean;
    salaryOrStaffingRate!: string | undefined;
    referralPoints!: string | undefined;
    template!: boolean;
    numberOfJobs!: number | undefined;
    minimumExperience!: string | undefined;
    maximumExperience!: string | undefined;
    jobDescription!: string | undefined;
    jobLocationFullAddress!: string | undefined;
    zipCode!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    startDate!: DateTime | undefined;
    hireByDate!: DateTime | undefined;
    publishDate!: DateTime | undefined;
    expirationDate!: DateTime | undefined;
    internalJobDescription!: string | undefined;
    cityLocation!: string | undefined;
    published!: boolean;
    url!: string | undefined;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    productCategoryId!: number | undefined;
    currencyId!: number | undefined;
    businessId!: number | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    cityId!: number | undefined;
    jobStatusTypeId!: number | undefined;
    storeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.fullTimeJobOrGigWorkProject = _data["fullTimeJobOrGigWorkProject"];
            this.remoteWorkOrOnSiteWork = _data["remoteWorkOrOnSiteWork"];
            this.salaryBasedOrFixedPrice = _data["salaryBasedOrFixedPrice"];
            this.salaryOrStaffingRate = _data["salaryOrStaffingRate"];
            this.referralPoints = _data["referralPoints"];
            this.template = _data["template"];
            this.numberOfJobs = _data["numberOfJobs"];
            this.minimumExperience = _data["minimumExperience"];
            this.maximumExperience = _data["maximumExperience"];
            this.jobDescription = _data["jobDescription"];
            this.jobLocationFullAddress = _data["jobLocationFullAddress"];
            this.zipCode = _data["zipCode"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.hireByDate = _data["hireByDate"] ? DateTime.fromISO(_data["hireByDate"].toString()) : <any>undefined;
            this.publishDate = _data["publishDate"] ? DateTime.fromISO(_data["publishDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? DateTime.fromISO(_data["expirationDate"].toString()) : <any>undefined;
            this.internalJobDescription = _data["internalJobDescription"];
            this.cityLocation = _data["cityLocation"];
            this.published = _data["published"];
            this.url = _data["url"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.productCategoryId = _data["productCategoryId"];
            this.currencyId = _data["currencyId"];
            this.businessId = _data["businessId"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.cityId = _data["cityId"];
            this.jobStatusTypeId = _data["jobStatusTypeId"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditJobDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditJobDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["fullTimeJobOrGigWorkProject"] = this.fullTimeJobOrGigWorkProject;
        data["remoteWorkOrOnSiteWork"] = this.remoteWorkOrOnSiteWork;
        data["salaryBasedOrFixedPrice"] = this.salaryBasedOrFixedPrice;
        data["salaryOrStaffingRate"] = this.salaryOrStaffingRate;
        data["referralPoints"] = this.referralPoints;
        data["template"] = this.template;
        data["numberOfJobs"] = this.numberOfJobs;
        data["minimumExperience"] = this.minimumExperience;
        data["maximumExperience"] = this.maximumExperience;
        data["jobDescription"] = this.jobDescription;
        data["jobLocationFullAddress"] = this.jobLocationFullAddress;
        data["zipCode"] = this.zipCode;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["hireByDate"] = this.hireByDate ? this.hireByDate.toString() : <any>undefined;
        data["publishDate"] = this.publishDate ? this.publishDate.toString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toString() : <any>undefined;
        data["internalJobDescription"] = this.internalJobDescription;
        data["cityLocation"] = this.cityLocation;
        data["published"] = this.published;
        data["url"] = this.url;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["productCategoryId"] = this.productCategoryId;
        data["currencyId"] = this.currencyId;
        data["businessId"] = this.businessId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["cityId"] = this.cityId;
        data["jobStatusTypeId"] = this.jobStatusTypeId;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditJobDto {
    title: string;
    fullTimeJobOrGigWorkProject: boolean;
    remoteWorkOrOnSiteWork: boolean;
    salaryBasedOrFixedPrice: boolean;
    salaryOrStaffingRate: string | undefined;
    referralPoints: string | undefined;
    template: boolean;
    numberOfJobs: number | undefined;
    minimumExperience: string | undefined;
    maximumExperience: string | undefined;
    jobDescription: string | undefined;
    jobLocationFullAddress: string | undefined;
    zipCode: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    startDate: DateTime | undefined;
    hireByDate: DateTime | undefined;
    publishDate: DateTime | undefined;
    expirationDate: DateTime | undefined;
    internalJobDescription: string | undefined;
    cityLocation: string | undefined;
    published: boolean;
    url: string | undefined;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    productCategoryId: number | undefined;
    currencyId: number | undefined;
    businessId: number | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    cityId: number | undefined;
    jobStatusTypeId: number | undefined;
    storeId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditJobStatusTypeDto implements ICreateOrEditJobStatusTypeDto {
    name!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditJobStatusTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditJobStatusTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditJobStatusTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditJobStatusTypeDto {
    name: string;
    id: number | undefined;
}

export class CreateOrEditJobTagDto implements ICreateOrEditJobTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    jobId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditJobTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.jobId = _data["jobId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditJobTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditJobTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["jobId"] = this.jobId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditJobTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    jobId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditMarketplaceCommissionTypeDto implements ICreateOrEditMarketplaceCommissionTypeDto {
    name!: string | undefined;
    percentage!: number | undefined;
    fixedAmount!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMarketplaceCommissionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.percentage = _data["percentage"];
            this.fixedAmount = _data["fixedAmount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMarketplaceCommissionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMarketplaceCommissionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["percentage"] = this.percentage;
        data["fixedAmount"] = this.fixedAmount;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditMarketplaceCommissionTypeDto {
    name: string | undefined;
    percentage: number | undefined;
    fixedAmount: number | undefined;
    id: number | undefined;
}

export class CreateOrEditMasterTagCategoryDto implements ICreateOrEditMasterTagCategoryDto {
    name!: string;
    description!: string | undefined;
    pictureMediaLibraryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMasterTagCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.pictureMediaLibraryId = _data["pictureMediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMasterTagCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMasterTagCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["pictureMediaLibraryId"] = this.pictureMediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditMasterTagCategoryDto {
    name: string;
    description: string | undefined;
    pictureMediaLibraryId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditMasterTagDto implements ICreateOrEditMasterTagDto {
    name!: string;
    description!: string | undefined;
    synonyms!: string | undefined;
    displaySequence!: number | undefined;
    masterTagCategoryId!: number;
    pictureMediaLibraryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMasterTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.synonyms = _data["synonyms"];
            this.displaySequence = _data["displaySequence"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.pictureMediaLibraryId = _data["pictureMediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMasterTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMasterTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["synonyms"] = this.synonyms;
        data["displaySequence"] = this.displaySequence;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["pictureMediaLibraryId"] = this.pictureMediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditMasterTagDto {
    name: string;
    description: string | undefined;
    synonyms: string | undefined;
    displaySequence: number | undefined;
    masterTagCategoryId: number;
    pictureMediaLibraryId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditMeasurementUnitDto implements ICreateOrEditMeasurementUnitDto {
    name!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMeasurementUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMeasurementUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMeasurementUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditMeasurementUnitDto {
    name: string;
    id: number | undefined;
}

export class CreateOrEditMediaLibraryDto implements ICreateOrEditMediaLibraryDto {
    name!: string;
    size!: string | undefined;
    fileExtension!: string | undefined;
    dimension!: string | undefined;
    videoLink!: string | undefined;
    seoTag!: string | undefined;
    altTag!: string | undefined;
    virtualPath!: string | undefined;
    binaryObjectId!: string;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMediaLibraryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.size = _data["size"];
            this.fileExtension = _data["fileExtension"];
            this.dimension = _data["dimension"];
            this.videoLink = _data["videoLink"];
            this.seoTag = _data["seoTag"];
            this.altTag = _data["altTag"];
            this.virtualPath = _data["virtualPath"];
            this.binaryObjectId = _data["binaryObjectId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMediaLibraryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMediaLibraryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["size"] = this.size;
        data["fileExtension"] = this.fileExtension;
        data["dimension"] = this.dimension;
        data["videoLink"] = this.videoLink;
        data["seoTag"] = this.seoTag;
        data["altTag"] = this.altTag;
        data["virtualPath"] = this.virtualPath;
        data["binaryObjectId"] = this.binaryObjectId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditMediaLibraryDto {
    name: string;
    size: string | undefined;
    fileExtension: string | undefined;
    dimension: string | undefined;
    videoLink: string | undefined;
    seoTag: string | undefined;
    altTag: string | undefined;
    virtualPath: string | undefined;
    binaryObjectId: string;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditMembershipTypeDto implements ICreateOrEditMembershipTypeDto {
    name!: string;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMembershipTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMembershipTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMembershipTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditMembershipTypeDto {
    name: string;
    description: string | undefined;
    id: number | undefined;
}

export class CreateOrEditProductCategoryDto implements ICreateOrEditProductCategoryDto {
    name!: string;
    description!: string | undefined;
    hasParentCategory!: boolean;
    parentCategoryId!: number | undefined;
    url!: string | undefined;
    metaTitle!: string | undefined;
    metaKeywords!: string | undefined;
    displaySequence!: number | undefined;
    productOrService!: boolean;
    mediaLibraryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.hasParentCategory = _data["hasParentCategory"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.url = _data["url"];
            this.metaTitle = _data["metaTitle"];
            this.metaKeywords = _data["metaKeywords"];
            this.displaySequence = _data["displaySequence"];
            this.productOrService = _data["productOrService"];
            this.mediaLibraryId = _data["mediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["hasParentCategory"] = this.hasParentCategory;
        data["parentCategoryId"] = this.parentCategoryId;
        data["url"] = this.url;
        data["metaTitle"] = this.metaTitle;
        data["metaKeywords"] = this.metaKeywords;
        data["displaySequence"] = this.displaySequence;
        data["productOrService"] = this.productOrService;
        data["mediaLibraryId"] = this.mediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditProductCategoryDto {
    name: string;
    description: string | undefined;
    hasParentCategory: boolean;
    parentCategoryId: number | undefined;
    url: string | undefined;
    metaTitle: string | undefined;
    metaKeywords: string | undefined;
    displaySequence: number | undefined;
    productOrService: boolean;
    mediaLibraryId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditProductDto implements ICreateOrEditProductDto {
    name!: string;
    shortDescription!: string | undefined;
    description!: string | undefined;
    sku!: string | undefined;
    url!: string | undefined;
    seoTitle!: string | undefined;
    metaKeywords!: string | undefined;
    metaDescription!: string | undefined;
    regularPrice!: number | undefined;
    salePrice!: number | undefined;
    priceDiscountPercentage!: number | undefined;
    callForPrice!: boolean;
    unitPrice!: number | undefined;
    measurementAmount!: number | undefined;
    isTaxExempt!: boolean;
    stockQuantity!: number | undefined;
    isDisplayStockQuantity!: boolean;
    isPublished!: boolean;
    isPackageProduct!: boolean;
    internalNotes!: string | undefined;
    isTemplate!: boolean;
    priceDiscountAmount!: number | undefined;
    isService!: boolean;
    isWholeSaleProduct!: boolean;
    productManufacturerSku!: string | undefined;
    byOrderOnly!: boolean;
    score!: number | undefined;
    productCategoryId!: number;
    mediaLibraryId!: number | undefined;
    measurementUnitId!: number | undefined;
    currencyId!: number | undefined;
    ratingLikeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortDescription = _data["shortDescription"];
            this.description = _data["description"];
            this.sku = _data["sku"];
            this.url = _data["url"];
            this.seoTitle = _data["seoTitle"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.regularPrice = _data["regularPrice"];
            this.salePrice = _data["salePrice"];
            this.priceDiscountPercentage = _data["priceDiscountPercentage"];
            this.callForPrice = _data["callForPrice"];
            this.unitPrice = _data["unitPrice"];
            this.measurementAmount = _data["measurementAmount"];
            this.isTaxExempt = _data["isTaxExempt"];
            this.stockQuantity = _data["stockQuantity"];
            this.isDisplayStockQuantity = _data["isDisplayStockQuantity"];
            this.isPublished = _data["isPublished"];
            this.isPackageProduct = _data["isPackageProduct"];
            this.internalNotes = _data["internalNotes"];
            this.isTemplate = _data["isTemplate"];
            this.priceDiscountAmount = _data["priceDiscountAmount"];
            this.isService = _data["isService"];
            this.isWholeSaleProduct = _data["isWholeSaleProduct"];
            this.productManufacturerSku = _data["productManufacturerSku"];
            this.byOrderOnly = _data["byOrderOnly"];
            this.score = _data["score"];
            this.productCategoryId = _data["productCategoryId"];
            this.mediaLibraryId = _data["mediaLibraryId"];
            this.measurementUnitId = _data["measurementUnitId"];
            this.currencyId = _data["currencyId"];
            this.ratingLikeId = _data["ratingLikeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        data["sku"] = this.sku;
        data["url"] = this.url;
        data["seoTitle"] = this.seoTitle;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["regularPrice"] = this.regularPrice;
        data["salePrice"] = this.salePrice;
        data["priceDiscountPercentage"] = this.priceDiscountPercentage;
        data["callForPrice"] = this.callForPrice;
        data["unitPrice"] = this.unitPrice;
        data["measurementAmount"] = this.measurementAmount;
        data["isTaxExempt"] = this.isTaxExempt;
        data["stockQuantity"] = this.stockQuantity;
        data["isDisplayStockQuantity"] = this.isDisplayStockQuantity;
        data["isPublished"] = this.isPublished;
        data["isPackageProduct"] = this.isPackageProduct;
        data["internalNotes"] = this.internalNotes;
        data["isTemplate"] = this.isTemplate;
        data["priceDiscountAmount"] = this.priceDiscountAmount;
        data["isService"] = this.isService;
        data["isWholeSaleProduct"] = this.isWholeSaleProduct;
        data["productManufacturerSku"] = this.productManufacturerSku;
        data["byOrderOnly"] = this.byOrderOnly;
        data["score"] = this.score;
        data["productCategoryId"] = this.productCategoryId;
        data["mediaLibraryId"] = this.mediaLibraryId;
        data["measurementUnitId"] = this.measurementUnitId;
        data["currencyId"] = this.currencyId;
        data["ratingLikeId"] = this.ratingLikeId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditProductDto {
    name: string;
    shortDescription: string | undefined;
    description: string | undefined;
    sku: string | undefined;
    url: string | undefined;
    seoTitle: string | undefined;
    metaKeywords: string | undefined;
    metaDescription: string | undefined;
    regularPrice: number | undefined;
    salePrice: number | undefined;
    priceDiscountPercentage: number | undefined;
    callForPrice: boolean;
    unitPrice: number | undefined;
    measurementAmount: number | undefined;
    isTaxExempt: boolean;
    stockQuantity: number | undefined;
    isDisplayStockQuantity: boolean;
    isPublished: boolean;
    isPackageProduct: boolean;
    internalNotes: string | undefined;
    isTemplate: boolean;
    priceDiscountAmount: number | undefined;
    isService: boolean;
    isWholeSaleProduct: boolean;
    productManufacturerSku: string | undefined;
    byOrderOnly: boolean;
    score: number | undefined;
    productCategoryId: number;
    mediaLibraryId: number | undefined;
    measurementUnitId: number | undefined;
    currencyId: number | undefined;
    ratingLikeId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditProductTagDto implements ICreateOrEditProductTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    productId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditProductTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.productId = _data["productId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditProductTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditProductTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["productId"] = this.productId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditProductTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    productId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditRatingLikeDto implements ICreateOrEditRatingLikeDto {
    name!: string;
    score!: number | undefined;
    iconLink!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditRatingLikeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.score = _data["score"];
            this.iconLink = _data["iconLink"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRatingLikeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRatingLikeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["score"] = this.score;
        data["iconLink"] = this.iconLink;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditRatingLikeDto {
    name: string;
    score: number | undefined;
    iconLink: string | undefined;
    id: number | undefined;
}

export class CreateOrEditSmsTemplateDto implements ICreateOrEditSmsTemplateDto {
    title!: string;
    content!: string;
    published!: boolean;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSmsTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.content = _data["content"];
            this.published = _data["published"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSmsTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSmsTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["content"] = this.content;
        data["published"] = this.published;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSmsTemplateDto {
    title: string;
    content: string;
    published: boolean;
    id: number | undefined;
}

export class CreateOrEditStateDto implements ICreateOrEditStateDto {
    name!: string;
    ticker!: string | undefined;
    countryId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.ticker = _data["ticker"];
            this.countryId = _data["countryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["ticker"] = this.ticker;
        data["countryId"] = this.countryId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStateDto {
    name: string;
    ticker: string | undefined;
    countryId: number;
    id: number | undefined;
}

export class CreateOrEditStoreAccountTeamDto implements ICreateOrEditStoreAccountTeamDto {
    primary!: boolean;
    active!: boolean;
    orderEmailNotification!: boolean;
    orderSmsNotification!: boolean;
    storeId!: number;
    employeeId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreAccountTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.primary = _data["primary"];
            this.active = _data["active"];
            this.orderEmailNotification = _data["orderEmailNotification"];
            this.orderSmsNotification = _data["orderSmsNotification"];
            this.storeId = _data["storeId"];
            this.employeeId = _data["employeeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreAccountTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreAccountTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primary"] = this.primary;
        data["active"] = this.active;
        data["orderEmailNotification"] = this.orderEmailNotification;
        data["orderSmsNotification"] = this.orderSmsNotification;
        data["storeId"] = this.storeId;
        data["employeeId"] = this.employeeId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreAccountTeamDto {
    primary: boolean;
    active: boolean;
    orderEmailNotification: boolean;
    orderSmsNotification: boolean;
    storeId: number;
    employeeId: number;
    id: number | undefined;
}

export class CreateOrEditStoreBankAccountDto implements ICreateOrEditStoreBankAccountDto {
    accountName!: string | undefined;
    accountNo!: string | undefined;
    bankName!: string | undefined;
    routingNo!: string | undefined;
    bankAddress!: string | undefined;
    storeId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountName = _data["accountName"];
            this.accountNo = _data["accountNo"];
            this.bankName = _data["bankName"];
            this.routingNo = _data["routingNo"];
            this.bankAddress = _data["bankAddress"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreBankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreBankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["accountNo"] = this.accountNo;
        data["bankName"] = this.bankName;
        data["routingNo"] = this.routingNo;
        data["bankAddress"] = this.bankAddress;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreBankAccountDto {
    accountName: string | undefined;
    accountNo: string | undefined;
    bankName: string | undefined;
    routingNo: string | undefined;
    bankAddress: string | undefined;
    storeId: number;
    id: number | undefined;
}

export class CreateOrEditStoreBusinessCustomerMapDto implements ICreateOrEditStoreBusinessCustomerMapDto {
    paidCustomer!: boolean;
    lifeTimeSalesAmount!: number | undefined;
    storeId!: number;
    businessId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreBusinessCustomerMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paidCustomer = _data["paidCustomer"];
            this.lifeTimeSalesAmount = _data["lifeTimeSalesAmount"];
            this.storeId = _data["storeId"];
            this.businessId = _data["businessId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreBusinessCustomerMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreBusinessCustomerMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paidCustomer"] = this.paidCustomer;
        data["lifeTimeSalesAmount"] = this.lifeTimeSalesAmount;
        data["storeId"] = this.storeId;
        data["businessId"] = this.businessId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreBusinessCustomerMapDto {
    paidCustomer: boolean;
    lifeTimeSalesAmount: number | undefined;
    storeId: number;
    businessId: number;
    id: number | undefined;
}

export class CreateOrEditStoreBusinessHourDto implements ICreateOrEditStoreBusinessHourDto {
    nowOpenOrClosed!: boolean;
    isOpen24Hours!: boolean;
    mondayStartTime!: string | undefined;
    mondayEndTime!: string | undefined;
    tuesdayStartTime!: string | undefined;
    tuesdayEndTime!: string | undefined;
    wednesdayStartTime!: string | undefined;
    wednesdayEndTime!: string | undefined;
    thursdayStartTime!: string | undefined;
    thursdayEndTime!: string | undefined;
    fridayStartTime!: string | undefined;
    fridayEndTime!: string | undefined;
    saturdayStartTime!: string | undefined;
    saturdayEndTime!: string | undefined;
    sundayStartTime!: string | undefined;
    sundayEndTime!: string | undefined;
    isAcceptOnlyBusinessHour!: boolean;
    storeId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreBusinessHourDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nowOpenOrClosed = _data["nowOpenOrClosed"];
            this.isOpen24Hours = _data["isOpen24Hours"];
            this.mondayStartTime = _data["mondayStartTime"];
            this.mondayEndTime = _data["mondayEndTime"];
            this.tuesdayStartTime = _data["tuesdayStartTime"];
            this.tuesdayEndTime = _data["tuesdayEndTime"];
            this.wednesdayStartTime = _data["wednesdayStartTime"];
            this.wednesdayEndTime = _data["wednesdayEndTime"];
            this.thursdayStartTime = _data["thursdayStartTime"];
            this.thursdayEndTime = _data["thursdayEndTime"];
            this.fridayStartTime = _data["fridayStartTime"];
            this.fridayEndTime = _data["fridayEndTime"];
            this.saturdayStartTime = _data["saturdayStartTime"];
            this.saturdayEndTime = _data["saturdayEndTime"];
            this.sundayStartTime = _data["sundayStartTime"];
            this.sundayEndTime = _data["sundayEndTime"];
            this.isAcceptOnlyBusinessHour = _data["isAcceptOnlyBusinessHour"];
            this.storeId = _data["storeId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreBusinessHourDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreBusinessHourDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nowOpenOrClosed"] = this.nowOpenOrClosed;
        data["isOpen24Hours"] = this.isOpen24Hours;
        data["mondayStartTime"] = this.mondayStartTime;
        data["mondayEndTime"] = this.mondayEndTime;
        data["tuesdayStartTime"] = this.tuesdayStartTime;
        data["tuesdayEndTime"] = this.tuesdayEndTime;
        data["wednesdayStartTime"] = this.wednesdayStartTime;
        data["wednesdayEndTime"] = this.wednesdayEndTime;
        data["thursdayStartTime"] = this.thursdayStartTime;
        data["thursdayEndTime"] = this.thursdayEndTime;
        data["fridayStartTime"] = this.fridayStartTime;
        data["fridayEndTime"] = this.fridayEndTime;
        data["saturdayStartTime"] = this.saturdayStartTime;
        data["saturdayEndTime"] = this.saturdayEndTime;
        data["sundayStartTime"] = this.sundayStartTime;
        data["sundayEndTime"] = this.sundayEndTime;
        data["isAcceptOnlyBusinessHour"] = this.isAcceptOnlyBusinessHour;
        data["storeId"] = this.storeId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreBusinessHourDto {
    nowOpenOrClosed: boolean;
    isOpen24Hours: boolean;
    mondayStartTime: string | undefined;
    mondayEndTime: string | undefined;
    tuesdayStartTime: string | undefined;
    tuesdayEndTime: string | undefined;
    wednesdayStartTime: string | undefined;
    wednesdayEndTime: string | undefined;
    thursdayStartTime: string | undefined;
    thursdayEndTime: string | undefined;
    fridayStartTime: string | undefined;
    fridayEndTime: string | undefined;
    saturdayStartTime: string | undefined;
    saturdayEndTime: string | undefined;
    sundayStartTime: string | undefined;
    sundayEndTime: string | undefined;
    isAcceptOnlyBusinessHour: boolean;
    storeId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditStoreContactMapDto implements ICreateOrEditStoreContactMapDto {
    paidCustomer!: boolean;
    lifeTimeSalesAmount!: number | undefined;
    storeId!: number;
    contactId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreContactMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paidCustomer = _data["paidCustomer"];
            this.lifeTimeSalesAmount = _data["lifeTimeSalesAmount"];
            this.storeId = _data["storeId"];
            this.contactId = _data["contactId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreContactMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreContactMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paidCustomer"] = this.paidCustomer;
        data["lifeTimeSalesAmount"] = this.lifeTimeSalesAmount;
        data["storeId"] = this.storeId;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreContactMapDto {
    paidCustomer: boolean;
    lifeTimeSalesAmount: number | undefined;
    storeId: number;
    contactId: number;
    id: number | undefined;
}

export class CreateOrEditStoreDto implements ICreateOrEditStoreDto {
    name!: string;
    storeUrl!: string | undefined;
    description!: string | undefined;
    metaTag!: string | undefined;
    metaDescription!: string | undefined;
    fullAddress!: string | undefined;
    address!: string | undefined;
    city!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    phone!: string | undefined;
    mobile!: string | undefined;
    email!: string | undefined;
    isPublished!: boolean;
    facebook!: string | undefined;
    instagram!: string | undefined;
    linkedIn!: string | undefined;
    youtube!: string | undefined;
    fax!: string | undefined;
    zipCode!: string | undefined;
    website!: string | undefined;
    yearOfEstablishment!: string | undefined;
    displaySequence!: number | undefined;
    score!: number | undefined;
    legalName!: string | undefined;
    isLocalOrOnlineStore!: boolean;
    isVerified!: boolean;
    logoMediaLibraryId!: number | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    ratingLikeId!: number | undefined;
    storeCategoryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.storeUrl = _data["storeUrl"];
            this.description = _data["description"];
            this.metaTag = _data["metaTag"];
            this.metaDescription = _data["metaDescription"];
            this.fullAddress = _data["fullAddress"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.phone = _data["phone"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
            this.isPublished = _data["isPublished"];
            this.facebook = _data["facebook"];
            this.instagram = _data["instagram"];
            this.linkedIn = _data["linkedIn"];
            this.youtube = _data["youtube"];
            this.fax = _data["fax"];
            this.zipCode = _data["zipCode"];
            this.website = _data["website"];
            this.yearOfEstablishment = _data["yearOfEstablishment"];
            this.displaySequence = _data["displaySequence"];
            this.score = _data["score"];
            this.legalName = _data["legalName"];
            this.isLocalOrOnlineStore = _data["isLocalOrOnlineStore"];
            this.isVerified = _data["isVerified"];
            this.logoMediaLibraryId = _data["logoMediaLibraryId"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.ratingLikeId = _data["ratingLikeId"];
            this.storeCategoryId = _data["storeCategoryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["storeUrl"] = this.storeUrl;
        data["description"] = this.description;
        data["metaTag"] = this.metaTag;
        data["metaDescription"] = this.metaDescription;
        data["fullAddress"] = this.fullAddress;
        data["address"] = this.address;
        data["city"] = this.city;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["phone"] = this.phone;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["isPublished"] = this.isPublished;
        data["facebook"] = this.facebook;
        data["instagram"] = this.instagram;
        data["linkedIn"] = this.linkedIn;
        data["youtube"] = this.youtube;
        data["fax"] = this.fax;
        data["zipCode"] = this.zipCode;
        data["website"] = this.website;
        data["yearOfEstablishment"] = this.yearOfEstablishment;
        data["displaySequence"] = this.displaySequence;
        data["score"] = this.score;
        data["legalName"] = this.legalName;
        data["isLocalOrOnlineStore"] = this.isLocalOrOnlineStore;
        data["isVerified"] = this.isVerified;
        data["logoMediaLibraryId"] = this.logoMediaLibraryId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["ratingLikeId"] = this.ratingLikeId;
        data["storeCategoryId"] = this.storeCategoryId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreDto {
    name: string;
    storeUrl: string | undefined;
    description: string | undefined;
    metaTag: string | undefined;
    metaDescription: string | undefined;
    fullAddress: string | undefined;
    address: string | undefined;
    city: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    phone: string | undefined;
    mobile: string | undefined;
    email: string | undefined;
    isPublished: boolean;
    facebook: string | undefined;
    instagram: string | undefined;
    linkedIn: string | undefined;
    youtube: string | undefined;
    fax: string | undefined;
    zipCode: string | undefined;
    website: string | undefined;
    yearOfEstablishment: string | undefined;
    displaySequence: number | undefined;
    score: number | undefined;
    legalName: string | undefined;
    isLocalOrOnlineStore: boolean;
    isVerified: boolean;
    logoMediaLibraryId: number | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    ratingLikeId: number | undefined;
    storeCategoryId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditStoreLocationDto implements ICreateOrEditStoreLocationDto {
    locationName!: string;
    fullAddress!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    address!: string | undefined;
    mobile!: string | undefined;
    email!: string | undefined;
    zipCode!: string | undefined;
    cityId!: number | undefined;
    stateId!: number | undefined;
    countryId!: number | undefined;
    storeId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationName = _data["locationName"];
            this.fullAddress = _data["fullAddress"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.address = _data["address"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
            this.zipCode = _data["zipCode"];
            this.cityId = _data["cityId"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationName"] = this.locationName;
        data["fullAddress"] = this.fullAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["address"] = this.address;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["zipCode"] = this.zipCode;
        data["cityId"] = this.cityId;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreLocationDto {
    locationName: string;
    fullAddress: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    address: string | undefined;
    mobile: string | undefined;
    email: string | undefined;
    zipCode: string | undefined;
    cityId: number | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    storeId: number;
    id: number | undefined;
}

export class CreateOrEditStoreMarketplaceCommissionSettingDto implements ICreateOrEditStoreMarketplaceCommissionSettingDto {
    percentage!: number | undefined;
    fixedAmount!: number | undefined;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;
    storeId!: number;
    marketplaceCommissionTypeId!: number | undefined;
    productCategoryId!: number | undefined;
    productId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreMarketplaceCommissionSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.percentage = _data["percentage"];
            this.fixedAmount = _data["fixedAmount"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.storeId = _data["storeId"];
            this.marketplaceCommissionTypeId = _data["marketplaceCommissionTypeId"];
            this.productCategoryId = _data["productCategoryId"];
            this.productId = _data["productId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreMarketplaceCommissionSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreMarketplaceCommissionSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["percentage"] = this.percentage;
        data["fixedAmount"] = this.fixedAmount;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["storeId"] = this.storeId;
        data["marketplaceCommissionTypeId"] = this.marketplaceCommissionTypeId;
        data["productCategoryId"] = this.productCategoryId;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreMarketplaceCommissionSettingDto {
    percentage: number | undefined;
    fixedAmount: number | undefined;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
    storeId: number;
    marketplaceCommissionTypeId: number | undefined;
    productCategoryId: number | undefined;
    productId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditStoreMediaDto implements ICreateOrEditStoreMediaDto {
    displaySequence!: number | undefined;
    storeId!: number;
    mediaLibraryId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreMediaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displaySequence = _data["displaySequence"];
            this.storeId = _data["storeId"];
            this.mediaLibraryId = _data["mediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreMediaDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreMediaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displaySequence"] = this.displaySequence;
        data["storeId"] = this.storeId;
        data["mediaLibraryId"] = this.mediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreMediaDto {
    displaySequence: number | undefined;
    storeId: number;
    mediaLibraryId: number;
    id: number | undefined;
}

export class CreateOrEditStoreNoteDto implements ICreateOrEditStoreNoteDto {
    notes!: string | undefined;
    storeId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreNoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notes = _data["notes"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notes"] = this.notes;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreNoteDto {
    notes: string | undefined;
    storeId: number;
    id: number | undefined;
}

export class CreateOrEditStoreOwnerTeamDto implements ICreateOrEditStoreOwnerTeamDto {
    active!: boolean;
    primary!: boolean;
    orderEmailNotification!: boolean;
    orderSmsNotification!: boolean;
    storeId!: number;
    userId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreOwnerTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.primary = _data["primary"];
            this.orderEmailNotification = _data["orderEmailNotification"];
            this.orderSmsNotification = _data["orderSmsNotification"];
            this.storeId = _data["storeId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreOwnerTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreOwnerTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["primary"] = this.primary;
        data["orderEmailNotification"] = this.orderEmailNotification;
        data["orderSmsNotification"] = this.orderSmsNotification;
        data["storeId"] = this.storeId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreOwnerTeamDto {
    active: boolean;
    primary: boolean;
    orderEmailNotification: boolean;
    orderSmsNotification: boolean;
    storeId: number;
    userId: number;
    id: number | undefined;
}

export class CreateOrEditStoreProductCategoryMapDto implements ICreateOrEditStoreProductCategoryMapDto {
    published!: boolean;
    displaySequence!: number | undefined;
    storeId!: number;
    productCategoryId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreProductCategoryMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.published = _data["published"];
            this.displaySequence = _data["displaySequence"];
            this.storeId = _data["storeId"];
            this.productCategoryId = _data["productCategoryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreProductCategoryMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreProductCategoryMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        data["displaySequence"] = this.displaySequence;
        data["storeId"] = this.storeId;
        data["productCategoryId"] = this.productCategoryId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreProductCategoryMapDto {
    published: boolean;
    displaySequence: number | undefined;
    storeId: number;
    productCategoryId: number;
    id: number | undefined;
}

export class CreateOrEditStoreProductMapDto implements ICreateOrEditStoreProductMapDto {
    published!: boolean;
    displaySequence!: number | undefined;
    storeId!: number;
    productId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreProductMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.published = _data["published"];
            this.displaySequence = _data["displaySequence"];
            this.storeId = _data["storeId"];
            this.productId = _data["productId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreProductMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreProductMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        data["displaySequence"] = this.displaySequence;
        data["storeId"] = this.storeId;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreProductMapDto {
    published: boolean;
    displaySequence: number | undefined;
    storeId: number;
    productId: number;
    id: number | undefined;
}

export class CreateOrEditStoreSalesAlertDto implements ICreateOrEditStoreSalesAlertDto {
    message!: string | undefined;
    current!: boolean;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;
    storeId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreSalesAlertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.current = _data["current"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreSalesAlertDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreSalesAlertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["current"] = this.current;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreSalesAlertDto {
    message: string | undefined;
    current: boolean;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
    storeId: number;
    id: number | undefined;
}

export class CreateOrEditStoreTagDto implements ICreateOrEditStoreTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    storeId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.storeId = _data["storeId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["storeId"] = this.storeId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    storeId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditStoreTaxDto implements ICreateOrEditStoreTaxDto {
    taxName!: string | undefined;
    percentageOrAmount!: boolean;
    taxRatePercentage!: number | undefined;
    taxAmount!: number | undefined;
    storeId!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStoreTaxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taxName = _data["taxName"];
            this.percentageOrAmount = _data["percentageOrAmount"];
            this.taxRatePercentage = _data["taxRatePercentage"];
            this.taxAmount = _data["taxAmount"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStoreTaxDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStoreTaxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxName"] = this.taxName;
        data["percentageOrAmount"] = this.percentageOrAmount;
        data["taxRatePercentage"] = this.taxRatePercentage;
        data["taxAmount"] = this.taxAmount;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditStoreTaxDto {
    taxName: string | undefined;
    percentageOrAmount: boolean;
    taxRatePercentage: number | undefined;
    taxAmount: number | undefined;
    storeId: number;
    id: number | undefined;
}

export class CreateOrEditTaskEventDto implements ICreateOrEditTaskEventDto {
    name!: string;
    description!: string | undefined;
    status!: boolean;
    priority!: boolean;
    eventDate!: DateTime | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    template!: boolean;
    actualTime!: string | undefined;
    endDate!: DateTime | undefined;
    estimatedTime!: string | undefined;
    hourAndMinutes!: string | undefined;
    taskStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTaskEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.priority = _data["priority"];
            this.eventDate = _data["eventDate"] ? DateTime.fromISO(_data["eventDate"].toString()) : <any>undefined;
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.template = _data["template"];
            this.actualTime = _data["actualTime"];
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.estimatedTime = _data["estimatedTime"];
            this.hourAndMinutes = _data["hourAndMinutes"];
            this.taskStatusId = _data["taskStatusId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTaskEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTaskEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["status"] = this.status;
        data["priority"] = this.priority;
        data["eventDate"] = this.eventDate ? this.eventDate.toString() : <any>undefined;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["template"] = this.template;
        data["actualTime"] = this.actualTime;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["estimatedTime"] = this.estimatedTime;
        data["hourAndMinutes"] = this.hourAndMinutes;
        data["taskStatusId"] = this.taskStatusId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditTaskEventDto {
    name: string;
    description: string | undefined;
    status: boolean;
    priority: boolean;
    eventDate: DateTime | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    template: boolean;
    actualTime: string | undefined;
    endDate: DateTime | undefined;
    estimatedTime: string | undefined;
    hourAndMinutes: string | undefined;
    taskStatusId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditTaskStatusDto implements ICreateOrEditTaskStatusDto {
    name!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTaskStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTaskStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTaskStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditTaskStatusDto {
    name: string;
    id: number | undefined;
}

export class CreateOrEditTaskTagDto implements ICreateOrEditTaskTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verfied!: boolean;
    sequence!: number | undefined;
    taskEventId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTaskTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verfied = _data["verfied"];
            this.sequence = _data["sequence"];
            this.taskEventId = _data["taskEventId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTaskTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTaskTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verfied"] = this.verfied;
        data["sequence"] = this.sequence;
        data["taskEventId"] = this.taskEventId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditTaskTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verfied: boolean;
    sequence: number | undefined;
    taskEventId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number | undefined;
}

export class CreateOrEditZipCodeDto implements ICreateOrEditZipCodeDto {
    name!: string;
    areaCode!: string | undefined;
    asianPopulation!: string | undefined;
    averageHouseValue!: string | undefined;
    blackPopulation!: string | undefined;
    cbsa!: string | undefined;
    cbsA_Div!: string | undefined;
    cbsA_Div_Name!: string | undefined;
    cbsA_Name!: string | undefined;
    cbsA_Type!: string | undefined;
    csa!: string | undefined;
    csaName!: string | undefined;
    carrierRouteRateSortation!: string | undefined;
    city!: string | undefined;
    cityAliasCode!: string | undefined;
    cityAliasMixedCase!: string | undefined;
    cityAliasName!: string | undefined;
    cityDeliveryIndicator!: string | undefined;
    cityMixedCase!: string | undefined;
    cityStateKey!: string | undefined;
    cityType!: string | undefined;
    classificationCode!: string | undefined;
    county!: string | undefined;
    countyANSI!: string | undefined;
    countyFIPS!: string | undefined;
    countyMixedCase!: string | undefined;
    dayLightSaving!: string | undefined;
    division!: string | undefined;
    elevation!: string | undefined;
    facilityCode!: string | undefined;
    femalePopulation!: string | undefined;
    financeNumber!: string | undefined;
    hawaiianPopulation!: string | undefined;
    hispanicPopulation!: string | undefined;
    householdsPerZipCode!: string | undefined;
    incomePerHousehold!: string | undefined;
    indianPopulation!: string | undefined;
    latitude!: string | undefined;
    longitude!: string | undefined;
    msa!: string | undefined;
    msA_Name!: string | undefined;
    mailingName!: string | undefined;
    malePopulation!: string | undefined;
    multiCounty!: string | undefined;
    otherPopulation!: string | undefined;
    pmsa!: string | undefined;
    pmsA_Name!: string | undefined;
    personsPerHousehold!: string | undefined;
    population!: string | undefined;
    preferredLastLineKey!: string | undefined;
    primaryRecord!: string | undefined;
    region!: string | undefined;
    state!: string | undefined;
    stateANSI!: string | undefined;
    stateFIPS!: string | undefined;
    stateFullName!: string | undefined;
    timeZone!: string | undefined;
    uniqueZIPName!: string | undefined;
    whitePopulation!: string | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    cityId!: number | undefined;
    countyId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditZipCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.areaCode = _data["areaCode"];
            this.asianPopulation = _data["asianPopulation"];
            this.averageHouseValue = _data["averageHouseValue"];
            this.blackPopulation = _data["blackPopulation"];
            this.cbsa = _data["cbsa"];
            this.cbsA_Div = _data["cbsA_Div"];
            this.cbsA_Div_Name = _data["cbsA_Div_Name"];
            this.cbsA_Name = _data["cbsA_Name"];
            this.cbsA_Type = _data["cbsA_Type"];
            this.csa = _data["csa"];
            this.csaName = _data["csaName"];
            this.carrierRouteRateSortation = _data["carrierRouteRateSortation"];
            this.city = _data["city"];
            this.cityAliasCode = _data["cityAliasCode"];
            this.cityAliasMixedCase = _data["cityAliasMixedCase"];
            this.cityAliasName = _data["cityAliasName"];
            this.cityDeliveryIndicator = _data["cityDeliveryIndicator"];
            this.cityMixedCase = _data["cityMixedCase"];
            this.cityStateKey = _data["cityStateKey"];
            this.cityType = _data["cityType"];
            this.classificationCode = _data["classificationCode"];
            this.county = _data["county"];
            this.countyANSI = _data["countyANSI"];
            this.countyFIPS = _data["countyFIPS"];
            this.countyMixedCase = _data["countyMixedCase"];
            this.dayLightSaving = _data["dayLightSaving"];
            this.division = _data["division"];
            this.elevation = _data["elevation"];
            this.facilityCode = _data["facilityCode"];
            this.femalePopulation = _data["femalePopulation"];
            this.financeNumber = _data["financeNumber"];
            this.hawaiianPopulation = _data["hawaiianPopulation"];
            this.hispanicPopulation = _data["hispanicPopulation"];
            this.householdsPerZipCode = _data["householdsPerZipCode"];
            this.incomePerHousehold = _data["incomePerHousehold"];
            this.indianPopulation = _data["indianPopulation"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.msa = _data["msa"];
            this.msA_Name = _data["msA_Name"];
            this.mailingName = _data["mailingName"];
            this.malePopulation = _data["malePopulation"];
            this.multiCounty = _data["multiCounty"];
            this.otherPopulation = _data["otherPopulation"];
            this.pmsa = _data["pmsa"];
            this.pmsA_Name = _data["pmsA_Name"];
            this.personsPerHousehold = _data["personsPerHousehold"];
            this.population = _data["population"];
            this.preferredLastLineKey = _data["preferredLastLineKey"];
            this.primaryRecord = _data["primaryRecord"];
            this.region = _data["region"];
            this.state = _data["state"];
            this.stateANSI = _data["stateANSI"];
            this.stateFIPS = _data["stateFIPS"];
            this.stateFullName = _data["stateFullName"];
            this.timeZone = _data["timeZone"];
            this.uniqueZIPName = _data["uniqueZIPName"];
            this.whitePopulation = _data["whitePopulation"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.cityId = _data["cityId"];
            this.countyId = _data["countyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditZipCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditZipCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["areaCode"] = this.areaCode;
        data["asianPopulation"] = this.asianPopulation;
        data["averageHouseValue"] = this.averageHouseValue;
        data["blackPopulation"] = this.blackPopulation;
        data["cbsa"] = this.cbsa;
        data["cbsA_Div"] = this.cbsA_Div;
        data["cbsA_Div_Name"] = this.cbsA_Div_Name;
        data["cbsA_Name"] = this.cbsA_Name;
        data["cbsA_Type"] = this.cbsA_Type;
        data["csa"] = this.csa;
        data["csaName"] = this.csaName;
        data["carrierRouteRateSortation"] = this.carrierRouteRateSortation;
        data["city"] = this.city;
        data["cityAliasCode"] = this.cityAliasCode;
        data["cityAliasMixedCase"] = this.cityAliasMixedCase;
        data["cityAliasName"] = this.cityAliasName;
        data["cityDeliveryIndicator"] = this.cityDeliveryIndicator;
        data["cityMixedCase"] = this.cityMixedCase;
        data["cityStateKey"] = this.cityStateKey;
        data["cityType"] = this.cityType;
        data["classificationCode"] = this.classificationCode;
        data["county"] = this.county;
        data["countyANSI"] = this.countyANSI;
        data["countyFIPS"] = this.countyFIPS;
        data["countyMixedCase"] = this.countyMixedCase;
        data["dayLightSaving"] = this.dayLightSaving;
        data["division"] = this.division;
        data["elevation"] = this.elevation;
        data["facilityCode"] = this.facilityCode;
        data["femalePopulation"] = this.femalePopulation;
        data["financeNumber"] = this.financeNumber;
        data["hawaiianPopulation"] = this.hawaiianPopulation;
        data["hispanicPopulation"] = this.hispanicPopulation;
        data["householdsPerZipCode"] = this.householdsPerZipCode;
        data["incomePerHousehold"] = this.incomePerHousehold;
        data["indianPopulation"] = this.indianPopulation;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["msa"] = this.msa;
        data["msA_Name"] = this.msA_Name;
        data["mailingName"] = this.mailingName;
        data["malePopulation"] = this.malePopulation;
        data["multiCounty"] = this.multiCounty;
        data["otherPopulation"] = this.otherPopulation;
        data["pmsa"] = this.pmsa;
        data["pmsA_Name"] = this.pmsA_Name;
        data["personsPerHousehold"] = this.personsPerHousehold;
        data["population"] = this.population;
        data["preferredLastLineKey"] = this.preferredLastLineKey;
        data["primaryRecord"] = this.primaryRecord;
        data["region"] = this.region;
        data["state"] = this.state;
        data["stateANSI"] = this.stateANSI;
        data["stateFIPS"] = this.stateFIPS;
        data["stateFullName"] = this.stateFullName;
        data["timeZone"] = this.timeZone;
        data["uniqueZIPName"] = this.uniqueZIPName;
        data["whitePopulation"] = this.whitePopulation;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["cityId"] = this.cityId;
        data["countyId"] = this.countyId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditZipCodeDto {
    name: string;
    areaCode: string | undefined;
    asianPopulation: string | undefined;
    averageHouseValue: string | undefined;
    blackPopulation: string | undefined;
    cbsa: string | undefined;
    cbsA_Div: string | undefined;
    cbsA_Div_Name: string | undefined;
    cbsA_Name: string | undefined;
    cbsA_Type: string | undefined;
    csa: string | undefined;
    csaName: string | undefined;
    carrierRouteRateSortation: string | undefined;
    city: string | undefined;
    cityAliasCode: string | undefined;
    cityAliasMixedCase: string | undefined;
    cityAliasName: string | undefined;
    cityDeliveryIndicator: string | undefined;
    cityMixedCase: string | undefined;
    cityStateKey: string | undefined;
    cityType: string | undefined;
    classificationCode: string | undefined;
    county: string | undefined;
    countyANSI: string | undefined;
    countyFIPS: string | undefined;
    countyMixedCase: string | undefined;
    dayLightSaving: string | undefined;
    division: string | undefined;
    elevation: string | undefined;
    facilityCode: string | undefined;
    femalePopulation: string | undefined;
    financeNumber: string | undefined;
    hawaiianPopulation: string | undefined;
    hispanicPopulation: string | undefined;
    householdsPerZipCode: string | undefined;
    incomePerHousehold: string | undefined;
    indianPopulation: string | undefined;
    latitude: string | undefined;
    longitude: string | undefined;
    msa: string | undefined;
    msA_Name: string | undefined;
    mailingName: string | undefined;
    malePopulation: string | undefined;
    multiCounty: string | undefined;
    otherPopulation: string | undefined;
    pmsa: string | undefined;
    pmsA_Name: string | undefined;
    personsPerHousehold: string | undefined;
    population: string | undefined;
    preferredLastLineKey: string | undefined;
    primaryRecord: string | undefined;
    region: string | undefined;
    state: string | undefined;
    stateANSI: string | undefined;
    stateFIPS: string | undefined;
    stateFullName: string | undefined;
    timeZone: string | undefined;
    uniqueZIPName: string | undefined;
    whitePopulation: string | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    cityId: number | undefined;
    countyId: number | undefined;
    id: number | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : new RoleEditDto();
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean;
    setRandomPassword!: boolean;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : new UserEditDto();
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.setRandomPassword = _data["setRandomPassword"];
            if (Array.isArray(_data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of _data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[] | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number;
    editionPaymentType!: EditionPaymentType;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled!: boolean;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.editionId = _data["editionId"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = _data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = _data["recurringPaymentEnabled"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data;
    }
}

export interface ICreatePaymentDto {
    editionId: number;
    editionPaymentType: EditionPaymentType;
    paymentPeriodType: PaymentPeriodType;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled: boolean;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminName!: string | undefined;
    adminSurname!: string | undefined;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean;
    sendActivationEmail!: boolean;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminName = _data["adminName"];
            this.adminSurname = _data["adminSurname"];
            this.adminPassword = _data["adminPassword"];
            this.connectionString = _data["connectionString"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminName"] = this.adminName;
        data["adminSurname"] = this.adminSurname;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data;
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminName: string | undefined;
    adminSurname: string | undefined;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
}

export class CreateUserDelegationDto implements ICreateUserDelegationDto {
    targetUserId!: number;
    startTime!: DateTime;
    endTime!: DateTime;

    constructor(data?: ICreateUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        return data;
    }
}

export interface ICreateUserDelegationDto {
    targetUserId: number;
    startTime: DateTime;
    endTime: DateTime;
}

export class CurrencyDto implements ICurrencyDto {
    name!: string | undefined;
    ticker!: string | undefined;
    icon!: string | undefined;
    id!: number;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.ticker = _data["ticker"];
            this.icon = _data["icon"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["ticker"] = this.ticker;
        data["icon"] = this.icon;
        data["id"] = this.id;
        return data;
    }
}

export interface ICurrencyDto {
    name: string | undefined;
    ticker: string | undefined;
    icon: string | undefined;
    id: number;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.timezone = _data["timezone"];
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;
}

export class Dashboard implements IDashboard {
    dashboardName!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: IDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboard {
    dashboardName: string | undefined;
    pages: Page[] | undefined;
}

export class DashboardOutput implements IDashboardOutput {
    name!: string | undefined;
    widgets!: WidgetOutput[] | undefined;

    constructor(data?: IDashboardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(WidgetOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboardOutput {
    name: string | undefined;
    widgets: WidgetOutput[] | undefined;
}

export class DateFieldOutput implements IDateFieldOutput {
    date!: DateTime;

    constructor(data?: IDateFieldOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateFieldOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateFieldOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        return data;
    }
}

export interface IDateFieldOutput {
    date: DateTime;
}

export class DateRangeFieldOutput implements IDateRangeFieldOutput {
    startDate!: DateTime;
    endDate!: DateTime;

    constructor(data?: IDateRangeFieldOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRangeFieldOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeFieldOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        return data;
    }
}

export interface IDateRangeFieldOutput {
    startDate: DateTime;
    endDate: DateTime;
}

export class DateWithTextFieldOutput implements IDateWithTextFieldOutput {
    text!: string | undefined;
    date!: DateTime;

    constructor(data?: IDateWithTextFieldOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateWithTextFieldOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateWithTextFieldOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        return data;
    }
}

export interface IDateWithTextFieldOutput {
    text: string | undefined;
    date: DateTime;
}

export class DelegatedImpersonateInput implements IDelegatedImpersonateInput {
    userDelegationId!: number;

    constructor(data?: IDelegatedImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userDelegationId = _data["userDelegationId"];
        }
    }

    static fromJS(data: any): DelegatedImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new DelegatedImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDelegationId"] = this.userDelegationId;
        return data;
    }
}

export interface IDelegatedImpersonateInput {
    userDelegationId: number;
}

export class DocumentTypeDto implements IDocumentTypeDto {
    name!: string | undefined;
    id!: number;

    constructor(data?: IDocumentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DocumentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IDocumentTypeDto {
    name: string | undefined;
    id: number;
}

export class DynamicEntityPropertyDto implements IDynamicEntityPropertyDto {
    entityFullName!: string | undefined;
    dynamicPropertyName!: string | undefined;
    dynamicPropertyId!: number;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IDynamicEntityPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityFullName = _data["entityFullName"];
            this.dynamicPropertyName = _data["dynamicPropertyName"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicEntityPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicEntityPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityFullName"] = this.entityFullName;
        data["dynamicPropertyName"] = this.dynamicPropertyName;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicEntityPropertyDto {
    entityFullName: string | undefined;
    dynamicPropertyName: string | undefined;
    dynamicPropertyId: number;
    tenantId: number | undefined;
    id: number;
}

export class DynamicEntityPropertyValueDto implements IDynamicEntityPropertyValueDto {
    value!: string | undefined;
    entityId!: string | undefined;
    dynamicEntityPropertyId!: number;
    id!: number;

    constructor(data?: IDynamicEntityPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.entityId = _data["entityId"];
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicEntityPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicEntityPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["entityId"] = this.entityId;
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicEntityPropertyValueDto {
    value: string | undefined;
    entityId: string | undefined;
    dynamicEntityPropertyId: number;
    id: number;
}

export class DynamicPropertyDto implements IDynamicPropertyDto {
    propertyName!: string | undefined;
    displayName!: string | undefined;
    inputType!: string | undefined;
    permission!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IDynamicPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.displayName = _data["displayName"];
            this.inputType = _data["inputType"];
            this.permission = _data["permission"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["displayName"] = this.displayName;
        data["inputType"] = this.inputType;
        data["permission"] = this.permission;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicPropertyDto {
    propertyName: string | undefined;
    displayName: string | undefined;
    inputType: string | undefined;
    permission: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class DynamicPropertyValueDto implements IDynamicPropertyValueDto {
    value!: string | undefined;
    tenantId!: number | undefined;
    dynamicPropertyId!: number;
    id!: number;

    constructor(data?: IDynamicPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicPropertyValueDto {
    value: string | undefined;
    tenantId: number | undefined;
    dynamicPropertyId: number;
    id: number;
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean;
    isFree!: boolean;
    id!: number;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.trialDayCount = _data["trialDayCount"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.isHighestEdition = _data["isHighestEdition"];
            this.isFree = _data["isFree"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.trialDayCount = _data["trialDayCount"];
            this.expiringEditionDisplayName = _data["expiringEditionDisplayName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number;
}

export enum EditionPaymentType {
    NewRegistration = 0,
    BuyNow = 1,
    Upgrade = 2,
    Extend = 3,
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.isFree = _data["isFree"];
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        return data;
    }
}

export interface IEditionSelectDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[] | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allFeatures"])) {
                this.allFeatures = [] as any;
                for (let item of _data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (Array.isArray(_data["editionsWithFeatures"])) {
                this.editionsWithFeatures = [] as any;
                for (let item of _data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allFeatures)) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.editionsWithFeatures)) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class EmailTemplateDto implements IEmailTemplateDto {
    subject!: string | undefined;
    content!: string | undefined;
    published!: boolean;
    id!: number;

    constructor(data?: IEmailTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.content = _data["content"];
            this.published = _data["published"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EmailTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["content"] = this.content;
        data["published"] = this.published;
        data["id"] = this.id;
        return data;
    }
}

export interface IEmailTemplateDto {
    subject: string | undefined;
    content: string | undefined;
    published: boolean;
    id: number;
}

export class EmployeeContactLookupTableDto implements IEmployeeContactLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IEmployeeContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EmployeeContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IEmployeeContactLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class EmployeeCountryLookupTableDto implements IEmployeeCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IEmployeeCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EmployeeCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IEmployeeCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class EmployeeDto implements IEmployeeDto {
    name!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    fullAddress!: string | undefined;
    address!: string | undefined;
    zipCode!: string | undefined;
    city!: string | undefined;
    dateOfBirth!: DateTime | undefined;
    mobile!: string | undefined;
    officePhone!: string | undefined;
    personalEmail!: string | undefined;
    businessEmail!: string | undefined;
    jobTitle!: string | undefined;
    companyName!: string | undefined;
    profile!: string | undefined;
    hireDate!: DateTime | undefined;
    facebook!: string | undefined;
    linkedIn!: string | undefined;
    fax!: string | undefined;
    profilePictureId!: string;
    currentEmployee!: boolean;
    stateId!: number | undefined;
    countryId!: number | undefined;
    contactId!: number | undefined;
    id!: number;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullAddress = _data["fullAddress"];
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.city = _data["city"];
            this.dateOfBirth = _data["dateOfBirth"] ? DateTime.fromISO(_data["dateOfBirth"].toString()) : <any>undefined;
            this.mobile = _data["mobile"];
            this.officePhone = _data["officePhone"];
            this.personalEmail = _data["personalEmail"];
            this.businessEmail = _data["businessEmail"];
            this.jobTitle = _data["jobTitle"];
            this.companyName = _data["companyName"];
            this.profile = _data["profile"];
            this.hireDate = _data["hireDate"] ? DateTime.fromISO(_data["hireDate"].toString()) : <any>undefined;
            this.facebook = _data["facebook"];
            this.linkedIn = _data["linkedIn"];
            this.fax = _data["fax"];
            this.profilePictureId = _data["profilePictureId"];
            this.currentEmployee = _data["currentEmployee"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.contactId = _data["contactId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullAddress"] = this.fullAddress;
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["city"] = this.city;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toString() : <any>undefined;
        data["mobile"] = this.mobile;
        data["officePhone"] = this.officePhone;
        data["personalEmail"] = this.personalEmail;
        data["businessEmail"] = this.businessEmail;
        data["jobTitle"] = this.jobTitle;
        data["companyName"] = this.companyName;
        data["profile"] = this.profile;
        data["hireDate"] = this.hireDate ? this.hireDate.toString() : <any>undefined;
        data["facebook"] = this.facebook;
        data["linkedIn"] = this.linkedIn;
        data["fax"] = this.fax;
        data["profilePictureId"] = this.profilePictureId;
        data["currentEmployee"] = this.currentEmployee;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEmployeeDto {
    name: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fullAddress: string | undefined;
    address: string | undefined;
    zipCode: string | undefined;
    city: string | undefined;
    dateOfBirth: DateTime | undefined;
    mobile: string | undefined;
    officePhone: string | undefined;
    personalEmail: string | undefined;
    businessEmail: string | undefined;
    jobTitle: string | undefined;
    companyName: string | undefined;
    profile: string | undefined;
    hireDate: DateTime | undefined;
    facebook: string | undefined;
    linkedIn: string | undefined;
    fax: string | undefined;
    profilePictureId: string;
    currentEmployee: boolean;
    stateId: number | undefined;
    countryId: number | undefined;
    contactId: number | undefined;
    id: number;
}

export class EmployeeStateLookupTableDto implements IEmployeeStateLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IEmployeeStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EmployeeStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IEmployeeStateLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class EmployeeTagDto implements IEmployeeTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    employeeId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number;

    constructor(data?: IEmployeeTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.employeeId = _data["employeeId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EmployeeTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["employeeId"] = this.employeeId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEmployeeTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    employeeId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number;
}

export class EmployeeTagEmployeeLookupTableDto implements IEmployeeTagEmployeeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IEmployeeTagEmployeeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EmployeeTagEmployeeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTagEmployeeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IEmployeeTagEmployeeLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class EmployeeTagMasterTagCategoryLookupTableDto implements IEmployeeTagMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IEmployeeTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EmployeeTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IEmployeeTagMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class EmployeeTagMasterTagLookupTableDto implements IEmployeeTagMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IEmployeeTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): EmployeeTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IEmployeeTagMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: DateTime;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number;
    id!: number;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.changeTime = _data["changeTime"] ? DateTime.fromISO(_data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = _data["entityTypeFullName"];
            this.changeType = _data["changeType"];
            (<any>this).changeTypeName = _data["changeTypeName"];
            this.entityChangeSetId = _data["entityChangeSetId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: DateTime;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityDto implements IEntityDto {
    id!: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDto {
    id: number;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfGuid {
    id: string;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityChangeId = _data["entityChangeId"];
            this.newValue = _data["newValue"];
            this.originalValue = _data["originalValue"];
            this.propertyName = _data["propertyName"];
            this.propertyTypeFullName = _data["propertyTypeFullName"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
            this.remainingDayCount = _data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data;
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
            if (_data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in _data["additionalParams"]) {
                    if (_data["additionalParams"].hasOwnProperty(key))
                        (<any>this.additionalParams)![key] = _data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    (<any>data["additionalParams"])[key] = (<any>this.additionalParams)[key];
            }
        }
        return data;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;
}

export class ExternalLoginProviderSettingsEditDto implements IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated!: boolean;
    facebook!: FacebookExternalLoginProviderSettings;
    google_IsDeactivated!: boolean;
    google!: GoogleExternalLoginProviderSettings;
    twitter_IsDeactivated!: boolean;
    twitter!: TwitterExternalLoginProviderSettings;
    microsoft_IsDeactivated!: boolean;
    microsoft!: MicrosoftExternalLoginProviderSettings;
    openIdConnect_IsDeactivated!: boolean;
    openIdConnect!: OpenIdConnectExternalLoginProviderSettings;
    openIdConnectClaimsMapping!: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated!: boolean;
    wsFederation!: WsFederationExternalLoginProviderSettings;
    wsFederationClaimsMapping!: JsonClaimMapDto[] | undefined;

    constructor(data?: IExternalLoginProviderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facebook_IsDeactivated = _data["facebook_IsDeactivated"];
            this.facebook = _data["facebook"] ? FacebookExternalLoginProviderSettings.fromJS(_data["facebook"]) : <any>undefined;
            this.google_IsDeactivated = _data["google_IsDeactivated"];
            this.google = _data["google"] ? GoogleExternalLoginProviderSettings.fromJS(_data["google"]) : <any>undefined;
            this.twitter_IsDeactivated = _data["twitter_IsDeactivated"];
            this.twitter = _data["twitter"] ? TwitterExternalLoginProviderSettings.fromJS(_data["twitter"]) : <any>undefined;
            this.microsoft_IsDeactivated = _data["microsoft_IsDeactivated"];
            this.microsoft = _data["microsoft"] ? MicrosoftExternalLoginProviderSettings.fromJS(_data["microsoft"]) : <any>undefined;
            this.openIdConnect_IsDeactivated = _data["openIdConnect_IsDeactivated"];
            this.openIdConnect = _data["openIdConnect"] ? OpenIdConnectExternalLoginProviderSettings.fromJS(_data["openIdConnect"]) : <any>undefined;
            if (Array.isArray(_data["openIdConnectClaimsMapping"])) {
                this.openIdConnectClaimsMapping = [] as any;
                for (let item of _data["openIdConnectClaimsMapping"])
                    this.openIdConnectClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
            this.wsFederation_IsDeactivated = _data["wsFederation_IsDeactivated"];
            this.wsFederation = _data["wsFederation"] ? WsFederationExternalLoginProviderSettings.fromJS(_data["wsFederation"]) : <any>undefined;
            if (Array.isArray(_data["wsFederationClaimsMapping"])) {
                this.wsFederationClaimsMapping = [] as any;
                for (let item of _data["wsFederationClaimsMapping"])
                    this.wsFederationClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facebook_IsDeactivated"] = this.facebook_IsDeactivated;
        data["facebook"] = this.facebook ? this.facebook.toJSON() : <any>undefined;
        data["google_IsDeactivated"] = this.google_IsDeactivated;
        data["google"] = this.google ? this.google.toJSON() : <any>undefined;
        data["twitter_IsDeactivated"] = this.twitter_IsDeactivated;
        data["twitter"] = this.twitter ? this.twitter.toJSON() : <any>undefined;
        data["microsoft_IsDeactivated"] = this.microsoft_IsDeactivated;
        data["microsoft"] = this.microsoft ? this.microsoft.toJSON() : <any>undefined;
        data["openIdConnect_IsDeactivated"] = this.openIdConnect_IsDeactivated;
        data["openIdConnect"] = this.openIdConnect ? this.openIdConnect.toJSON() : <any>undefined;
        if (Array.isArray(this.openIdConnectClaimsMapping)) {
            data["openIdConnectClaimsMapping"] = [];
            for (let item of this.openIdConnectClaimsMapping)
                data["openIdConnectClaimsMapping"].push(item.toJSON());
        }
        data["wsFederation_IsDeactivated"] = this.wsFederation_IsDeactivated;
        data["wsFederation"] = this.wsFederation ? this.wsFederation.toJSON() : <any>undefined;
        if (Array.isArray(this.wsFederationClaimsMapping)) {
            data["wsFederationClaimsMapping"] = [];
            for (let item of this.wsFederationClaimsMapping)
                data["wsFederationClaimsMapping"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated: boolean;
    facebook: FacebookExternalLoginProviderSettings;
    google_IsDeactivated: boolean;
    google: GoogleExternalLoginProviderSettings;
    twitter_IsDeactivated: boolean;
    twitter: TwitterExternalLoginProviderSettings;
    microsoft_IsDeactivated: boolean;
    microsoft: MicrosoftExternalLoginProviderSettings;
    openIdConnect_IsDeactivated: boolean;
    openIdConnect: OpenIdConnectExternalLoginProviderSettings;
    openIdConnectClaimsMapping: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated: boolean;
    wsFederation: WsFederationExternalLoginProviderSettings;
    wsFederationClaimsMapping: JsonClaimMapDto[] | undefined;
}

export class ExternalLoginSettingsDto implements IExternalLoginSettingsDto {
    enabledSocialLoginSettings!: string[] | undefined;

    constructor(data?: IExternalLoginSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledSocialLoginSettings"])) {
                this.enabledSocialLoginSettings = [] as any;
                for (let item of _data["enabledSocialLoginSettings"])
                    this.enabledSocialLoginSettings!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalLoginSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledSocialLoginSettings)) {
            data["enabledSocialLoginSettings"] = [];
            for (let item of this.enabledSocialLoginSettings)
                data["enabledSocialLoginSettings"].push(item);
        }
        return data;
    }
}

export interface IExternalLoginSettingsDto {
    enabledSocialLoginSettings: string[] | undefined;
}

export class FacebookExternalLoginProviderSettings implements IFacebookExternalLoginProviderSettings {
    appId!: string | undefined;
    appSecret!: string | undefined;

    constructor(data?: IFacebookExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"];
            this.appSecret = _data["appSecret"];
        }
    }

    static fromJS(data: any): FacebookExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["appSecret"] = this.appSecret;
        return data;
    }
}

export interface IFacebookExternalLoginProviderSettings {
    appId: string | undefined;
    appSecret: string | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;
    itemSource!: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
            this.itemSource = _data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(_data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    excludeCurrentUser!: boolean;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.excludeCurrentUser = _data["excludeCurrentUser"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["excludeCurrentUser"] = this.excludeCurrentUser;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    excludeCurrentUser: boolean;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? FeatureInputTypeDto.fromJS(_data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            this.textHtmlColor = _data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data;
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType;
    textHtmlColor: string | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class FriendDto implements IFriendDto {
    friendUserId!: number;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number;
    isOnline!: boolean;
    state!: FriendshipState;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendUserId = _data["friendUserId"];
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserName = _data["friendUserName"];
            this.friendTenancyName = _data["friendTenancyName"];
            this.friendProfilePictureId = _data["friendProfilePictureId"];
            this.unreadMessageCount = _data["unreadMessageCount"];
            this.isOnline = _data["isOnline"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data;
    }
}

export interface IFriendDto {
    friendUserId: number;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;
}

export enum FriendshipState {
    Accepted = 1,
    Blocked = 2,
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timezone = _data["timezone"];
            this.timezoneForComparison = _data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class GenerateGoogleAuthenticatorKeyOutput implements IGenerateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;
    googleAuthenticatorKey!: string | undefined;

    constructor(data?: IGenerateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
            this.googleAuthenticatorKey = _data["googleAuthenticatorKey"];
        }
    }

    static fromJS(data: any): GenerateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        return data;
    }
}

export interface IGenerateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
    googleAuthenticatorKey: string | undefined;
}

export class GetAllAvailableWebhooksOutput implements IGetAllAvailableWebhooksOutput {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

export interface IGetAllAvailableWebhooksOutput {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetAllDynamicEntityPropertyValuesOutput implements IGetAllDynamicEntityPropertyValuesOutput {
    items!: GetAllDynamicEntityPropertyValuesOutputItem[] | undefined;

    constructor(data?: IGetAllDynamicEntityPropertyValuesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllDynamicEntityPropertyValuesOutputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllDynamicEntityPropertyValuesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDynamicEntityPropertyValuesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAllDynamicEntityPropertyValuesOutput {
    items: GetAllDynamicEntityPropertyValuesOutputItem[] | undefined;
}

export class GetAllDynamicEntityPropertyValuesOutputItem implements IGetAllDynamicEntityPropertyValuesOutputItem {
    dynamicEntityPropertyId!: number;
    propertyName!: string | undefined;
    inputType!: IInputType;
    selectedValues!: string[] | undefined;
    allValuesInputTypeHas!: string[] | undefined;

    constructor(data?: IGetAllDynamicEntityPropertyValuesOutputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.propertyName = _data["propertyName"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            if (Array.isArray(_data["selectedValues"])) {
                this.selectedValues = [] as any;
                for (let item of _data["selectedValues"])
                    this.selectedValues!.push(item);
            }
            if (Array.isArray(_data["allValuesInputTypeHas"])) {
                this.allValuesInputTypeHas = [] as any;
                for (let item of _data["allValuesInputTypeHas"])
                    this.allValuesInputTypeHas!.push(item);
            }
        }
    }

    static fromJS(data: any): GetAllDynamicEntityPropertyValuesOutputItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDynamicEntityPropertyValuesOutputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["propertyName"] = this.propertyName;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        if (Array.isArray(this.selectedValues)) {
            data["selectedValues"] = [];
            for (let item of this.selectedValues)
                data["selectedValues"].push(item);
        }
        if (Array.isArray(this.allValuesInputTypeHas)) {
            data["allValuesInputTypeHas"] = [];
            for (let item of this.allValuesInputTypeHas)
                data["allValuesInputTypeHas"].push(item);
        }
        return data;
    }
}

export interface IGetAllDynamicEntityPropertyValuesOutputItem {
    dynamicEntityPropertyId: number;
    propertyName: string | undefined;
    inputType: IInputType;
    selectedValues: string[] | undefined;
    allValuesInputTypeHas: string[] | undefined;
}

export class GetAllEntitiesHasDynamicPropertyOutput implements IGetAllEntitiesHasDynamicPropertyOutput {
    entityFullName!: string | undefined;

    constructor(data?: IGetAllEntitiesHasDynamicPropertyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityFullName = _data["entityFullName"];
        }
    }

    static fromJS(data: any): GetAllEntitiesHasDynamicPropertyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllEntitiesHasDynamicPropertyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityFullName"] = this.entityFullName;
        return data;
    }
}

export interface IGetAllEntitiesHasDynamicPropertyOutput {
    entityFullName: string | undefined;
}

export class GetAllSendAttemptsOfWebhookEventOutput implements IGetAllSendAttemptsOfWebhookEventOutput {
    id!: string;
    webhookUri!: string | undefined;
    webhookSubscriptionId!: string;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: DateTime;
    lastModificationTime!: DateTime | undefined;

    constructor(data?: IGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookUri = _data["webhookUri"];
            this.webhookSubscriptionId = _data["webhookSubscriptionId"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookUri"] = this.webhookUri;
        data["webhookSubscriptionId"] = this.webhookSubscriptionId;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetAllSendAttemptsOfWebhookEventOutput {
    id: string;
    webhookUri: string | undefined;
    webhookSubscriptionId: string;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: DateTime;
    lastModificationTime: DateTime | undefined;
}

export class GetAllSendAttemptsOutput implements IGetAllSendAttemptsOutput {
    id!: string;
    webhookEventId!: string;
    webhookName!: string | undefined;
    data!: string | undefined;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: DateTime;

    constructor(data?: IGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookEventId = _data["webhookEventId"];
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookEventId"] = this.webhookEventId;
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetAllSendAttemptsOutput {
    id: string;
    webhookEventId: string;
    webhookName: string | undefined;
    data: string | undefined;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: DateTime;
}

export class GetAllSubscriptionsOutput implements IGetAllSubscriptionsOutput {
    webhookUri!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    id!: string;

    constructor(data?: IGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webhookUri = _data["webhookUri"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webhookUri"] = this.webhookUri;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllSubscriptionsOutput {
    webhookUri: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    id: string;
}

export class GetBusinessAccountTeamForEditOutput implements IGetBusinessAccountTeamForEditOutput {
    businessAccountTeam!: CreateOrEditBusinessAccountTeamDto;
    businessName!: string | undefined;
    employeeName!: string | undefined;

    constructor(data?: IGetBusinessAccountTeamForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessAccountTeam = _data["businessAccountTeam"] ? CreateOrEditBusinessAccountTeamDto.fromJS(_data["businessAccountTeam"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.employeeName = _data["employeeName"];
        }
    }

    static fromJS(data: any): GetBusinessAccountTeamForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessAccountTeamForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessAccountTeam"] = this.businessAccountTeam ? this.businessAccountTeam.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["employeeName"] = this.employeeName;
        return data;
    }
}

export interface IGetBusinessAccountTeamForEditOutput {
    businessAccountTeam: CreateOrEditBusinessAccountTeamDto;
    businessName: string | undefined;
    employeeName: string | undefined;
}

export class GetBusinessAccountTeamForViewDto implements IGetBusinessAccountTeamForViewDto {
    businessAccountTeam!: BusinessAccountTeamDto;
    businessName!: string | undefined;
    employeeName!: string | undefined;

    constructor(data?: IGetBusinessAccountTeamForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessAccountTeam = _data["businessAccountTeam"] ? BusinessAccountTeamDto.fromJS(_data["businessAccountTeam"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.employeeName = _data["employeeName"];
        }
    }

    static fromJS(data: any): GetBusinessAccountTeamForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessAccountTeamForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessAccountTeam"] = this.businessAccountTeam ? this.businessAccountTeam.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["employeeName"] = this.employeeName;
        return data;
    }
}

export interface IGetBusinessAccountTeamForViewDto {
    businessAccountTeam: BusinessAccountTeamDto;
    businessName: string | undefined;
    employeeName: string | undefined;
}

export class GetBusinessContactMapForEditOutput implements IGetBusinessContactMapForEditOutput {
    businessContactMap!: CreateOrEditBusinessContactMapDto;
    businessName!: string | undefined;
    contactFullName!: string | undefined;

    constructor(data?: IGetBusinessContactMapForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessContactMap = _data["businessContactMap"] ? CreateOrEditBusinessContactMapDto.fromJS(_data["businessContactMap"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.contactFullName = _data["contactFullName"];
        }
    }

    static fromJS(data: any): GetBusinessContactMapForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessContactMapForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessContactMap"] = this.businessContactMap ? this.businessContactMap.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["contactFullName"] = this.contactFullName;
        return data;
    }
}

export interface IGetBusinessContactMapForEditOutput {
    businessContactMap: CreateOrEditBusinessContactMapDto;
    businessName: string | undefined;
    contactFullName: string | undefined;
}

export class GetBusinessContactMapForViewDto implements IGetBusinessContactMapForViewDto {
    businessContactMap!: BusinessContactMapDto;
    businessName!: string | undefined;
    contactFullName!: string | undefined;

    constructor(data?: IGetBusinessContactMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessContactMap = _data["businessContactMap"] ? BusinessContactMapDto.fromJS(_data["businessContactMap"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.contactFullName = _data["contactFullName"];
        }
    }

    static fromJS(data: any): GetBusinessContactMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessContactMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessContactMap"] = this.businessContactMap ? this.businessContactMap.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["contactFullName"] = this.contactFullName;
        return data;
    }
}

export interface IGetBusinessContactMapForViewDto {
    businessContactMap: BusinessContactMapDto;
    businessName: string | undefined;
    contactFullName: string | undefined;
}

export class GetBusinessForEditOutput implements IGetBusinessForEditOutput {
    business!: CreateOrEditBusinessDto;
    countryName!: string | undefined;
    stateName!: string | undefined;
    cityName!: string | undefined;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetBusinessForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.business = _data["business"] ? CreateOrEditBusinessDto.fromJS(_data["business"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.cityName = _data["cityName"];
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetBusinessForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["business"] = this.business ? this.business.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["cityName"] = this.cityName;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetBusinessForEditOutput {
    business: CreateOrEditBusinessDto;
    countryName: string | undefined;
    stateName: string | undefined;
    cityName: string | undefined;
    mediaLibraryName: string | undefined;
}

export class GetBusinessForViewDto implements IGetBusinessForViewDto {
    business!: BusinessDto;
    countryName!: string | undefined;
    stateName!: string | undefined;
    cityName!: string | undefined;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetBusinessForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.business = _data["business"] ? BusinessDto.fromJS(_data["business"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.cityName = _data["cityName"];
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetBusinessForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["business"] = this.business ? this.business.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["cityName"] = this.cityName;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetBusinessForViewDto {
    business: BusinessDto;
    countryName: string | undefined;
    stateName: string | undefined;
    cityName: string | undefined;
    mediaLibraryName: string | undefined;
}

export class GetBusinessJobMapForEditOutput implements IGetBusinessJobMapForEditOutput {
    businessJobMap!: CreateOrEditBusinessJobMapDto;
    businessName!: string | undefined;
    jobTitle!: string | undefined;

    constructor(data?: IGetBusinessJobMapForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessJobMap = _data["businessJobMap"] ? CreateOrEditBusinessJobMapDto.fromJS(_data["businessJobMap"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.jobTitle = _data["jobTitle"];
        }
    }

    static fromJS(data: any): GetBusinessJobMapForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessJobMapForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessJobMap"] = this.businessJobMap ? this.businessJobMap.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["jobTitle"] = this.jobTitle;
        return data;
    }
}

export interface IGetBusinessJobMapForEditOutput {
    businessJobMap: CreateOrEditBusinessJobMapDto;
    businessName: string | undefined;
    jobTitle: string | undefined;
}

export class GetBusinessJobMapForViewDto implements IGetBusinessJobMapForViewDto {
    businessJobMap!: BusinessJobMapDto;
    businessName!: string | undefined;
    jobTitle!: string | undefined;

    constructor(data?: IGetBusinessJobMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessJobMap = _data["businessJobMap"] ? BusinessJobMapDto.fromJS(_data["businessJobMap"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.jobTitle = _data["jobTitle"];
        }
    }

    static fromJS(data: any): GetBusinessJobMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessJobMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessJobMap"] = this.businessJobMap ? this.businessJobMap.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["jobTitle"] = this.jobTitle;
        return data;
    }
}

export interface IGetBusinessJobMapForViewDto {
    businessJobMap: BusinessJobMapDto;
    businessName: string | undefined;
    jobTitle: string | undefined;
}

export class GetBusinessNoteForEditOutput implements IGetBusinessNoteForEditOutput {
    businessNote!: CreateOrEditBusinessNoteDto;
    businessName!: string | undefined;

    constructor(data?: IGetBusinessNoteForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessNote = _data["businessNote"] ? CreateOrEditBusinessNoteDto.fromJS(_data["businessNote"]) : <any>undefined;
            this.businessName = _data["businessName"];
        }
    }

    static fromJS(data: any): GetBusinessNoteForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessNoteForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessNote"] = this.businessNote ? this.businessNote.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        return data;
    }
}

export interface IGetBusinessNoteForEditOutput {
    businessNote: CreateOrEditBusinessNoteDto;
    businessName: string | undefined;
}

export class GetBusinessNoteForViewDto implements IGetBusinessNoteForViewDto {
    businessNote!: BusinessNoteDto;
    businessName!: string | undefined;

    constructor(data?: IGetBusinessNoteForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessNote = _data["businessNote"] ? BusinessNoteDto.fromJS(_data["businessNote"]) : <any>undefined;
            this.businessName = _data["businessName"];
        }
    }

    static fromJS(data: any): GetBusinessNoteForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessNoteForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessNote"] = this.businessNote ? this.businessNote.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        return data;
    }
}

export interface IGetBusinessNoteForViewDto {
    businessNote: BusinessNoteDto;
    businessName: string | undefined;
}

export class GetBusinessProductMapForEditOutput implements IGetBusinessProductMapForEditOutput {
    businessProductMap!: CreateOrEditBusinessProductMapDto;
    businessName!: string | undefined;
    productName!: string | undefined;

    constructor(data?: IGetBusinessProductMapForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessProductMap = _data["businessProductMap"] ? CreateOrEditBusinessProductMapDto.fromJS(_data["businessProductMap"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): GetBusinessProductMapForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessProductMapForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProductMap"] = this.businessProductMap ? this.businessProductMap.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IGetBusinessProductMapForEditOutput {
    businessProductMap: CreateOrEditBusinessProductMapDto;
    businessName: string | undefined;
    productName: string | undefined;
}

export class GetBusinessProductMapForViewDto implements IGetBusinessProductMapForViewDto {
    businessProductMap!: BusinessProductMapDto;
    businessName!: string | undefined;
    productName!: string | undefined;

    constructor(data?: IGetBusinessProductMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessProductMap = _data["businessProductMap"] ? BusinessProductMapDto.fromJS(_data["businessProductMap"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): GetBusinessProductMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessProductMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessProductMap"] = this.businessProductMap ? this.businessProductMap.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IGetBusinessProductMapForViewDto {
    businessProductMap: BusinessProductMapDto;
    businessName: string | undefined;
    productName: string | undefined;
}

export class GetBusinessStoreMapForEditOutput implements IGetBusinessStoreMapForEditOutput {
    businessStoreMap!: CreateOrEditBusinessStoreMapDto;
    businessName!: string | undefined;
    storeName!: string | undefined;

    constructor(data?: IGetBusinessStoreMapForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessStoreMap = _data["businessStoreMap"] ? CreateOrEditBusinessStoreMapDto.fromJS(_data["businessStoreMap"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetBusinessStoreMapForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessStoreMapForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessStoreMap"] = this.businessStoreMap ? this.businessStoreMap.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetBusinessStoreMapForEditOutput {
    businessStoreMap: CreateOrEditBusinessStoreMapDto;
    businessName: string | undefined;
    storeName: string | undefined;
}

export class GetBusinessStoreMapForViewDto implements IGetBusinessStoreMapForViewDto {
    businessStoreMap!: BusinessStoreMapDto;
    businessName!: string | undefined;
    storeName!: string | undefined;

    constructor(data?: IGetBusinessStoreMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessStoreMap = _data["businessStoreMap"] ? BusinessStoreMapDto.fromJS(_data["businessStoreMap"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetBusinessStoreMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessStoreMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessStoreMap"] = this.businessStoreMap ? this.businessStoreMap.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetBusinessStoreMapForViewDto {
    businessStoreMap: BusinessStoreMapDto;
    businessName: string | undefined;
    storeName: string | undefined;
}

export class GetBusinessTagForEditOutput implements IGetBusinessTagForEditOutput {
    businessTag!: CreateOrEditBusinessTagDto;
    businessName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetBusinessTagForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessTag = _data["businessTag"] ? CreateOrEditBusinessTagDto.fromJS(_data["businessTag"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetBusinessTagForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessTagForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessTag"] = this.businessTag ? this.businessTag.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetBusinessTagForEditOutput {
    businessTag: CreateOrEditBusinessTagDto;
    businessName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetBusinessTagForViewDto implements IGetBusinessTagForViewDto {
    businessTag!: BusinessTagDto;
    businessName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetBusinessTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessTag = _data["businessTag"] ? BusinessTagDto.fromJS(_data["businessTag"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetBusinessTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessTag"] = this.businessTag ? this.businessTag.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetBusinessTagForViewDto {
    businessTag: BusinessTagDto;
    businessName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetBusinessTaskMapForEditOutput implements IGetBusinessTaskMapForEditOutput {
    businessTaskMap!: CreateOrEditBusinessTaskMapDto;
    businessName!: string | undefined;
    taskEventName!: string | undefined;

    constructor(data?: IGetBusinessTaskMapForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessTaskMap = _data["businessTaskMap"] ? CreateOrEditBusinessTaskMapDto.fromJS(_data["businessTaskMap"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.taskEventName = _data["taskEventName"];
        }
    }

    static fromJS(data: any): GetBusinessTaskMapForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessTaskMapForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessTaskMap"] = this.businessTaskMap ? this.businessTaskMap.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["taskEventName"] = this.taskEventName;
        return data;
    }
}

export interface IGetBusinessTaskMapForEditOutput {
    businessTaskMap: CreateOrEditBusinessTaskMapDto;
    businessName: string | undefined;
    taskEventName: string | undefined;
}

export class GetBusinessTaskMapForViewDto implements IGetBusinessTaskMapForViewDto {
    businessTaskMap!: BusinessTaskMapDto;
    businessName!: string | undefined;
    taskEventName!: string | undefined;

    constructor(data?: IGetBusinessTaskMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessTaskMap = _data["businessTaskMap"] ? BusinessTaskMapDto.fromJS(_data["businessTaskMap"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.taskEventName = _data["taskEventName"];
        }
    }

    static fromJS(data: any): GetBusinessTaskMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessTaskMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessTaskMap"] = this.businessTaskMap ? this.businessTaskMap.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["taskEventName"] = this.taskEventName;
        return data;
    }
}

export interface IGetBusinessTaskMapForViewDto {
    businessTaskMap: BusinessTaskMapDto;
    businessName: string | undefined;
    taskEventName: string | undefined;
}

export class GetBusinessUserForEditOutput implements IGetBusinessUserForEditOutput {
    businessUser!: CreateOrEditBusinessUserDto;
    businessName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetBusinessUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessUser = _data["businessUser"] ? CreateOrEditBusinessUserDto.fromJS(_data["businessUser"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): GetBusinessUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessUser"] = this.businessUser ? this.businessUser.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IGetBusinessUserForEditOutput {
    businessUser: CreateOrEditBusinessUserDto;
    businessName: string | undefined;
    userName: string | undefined;
}

export class GetBusinessUserForViewDto implements IGetBusinessUserForViewDto {
    businessUser!: BusinessUserDto;
    businessName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetBusinessUserForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.businessUser = _data["businessUser"] ? BusinessUserDto.fromJS(_data["businessUser"]) : <any>undefined;
            this.businessName = _data["businessName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): GetBusinessUserForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusinessUserForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["businessUser"] = this.businessUser ? this.businessUser.toJSON() : <any>undefined;
        data["businessName"] = this.businessName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IGetBusinessUserForViewDto {
    businessUser: BusinessUserDto;
    businessName: string | undefined;
    userName: string | undefined;
}

export class GetCityForEditOutput implements IGetCityForEditOutput {
    city!: CreateOrEditCityDto;
    countryName!: string | undefined;
    stateName!: string | undefined;
    countyName!: string | undefined;

    constructor(data?: IGetCityForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.city = _data["city"] ? CreateOrEditCityDto.fromJS(_data["city"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.countyName = _data["countyName"];
        }
    }

    static fromJS(data: any): GetCityForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCityForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["countyName"] = this.countyName;
        return data;
    }
}

export interface IGetCityForEditOutput {
    city: CreateOrEditCityDto;
    countryName: string | undefined;
    stateName: string | undefined;
    countyName: string | undefined;
}

export class GetCityForViewDto implements IGetCityForViewDto {
    city!: CityDto;
    countryName!: string | undefined;
    stateName!: string | undefined;
    countyName!: string | undefined;

    constructor(data?: IGetCityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.city = _data["city"] ? CityDto.fromJS(_data["city"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.countyName = _data["countyName"];
        }
    }

    static fromJS(data: any): GetCityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["countyName"] = this.countyName;
        return data;
    }
}

export interface IGetCityForViewDto {
    city: CityDto;
    countryName: string | undefined;
    stateName: string | undefined;
    countyName: string | undefined;
}

export class GetConnectChannelForEditOutput implements IGetConnectChannelForEditOutput {
    connectChannel!: CreateOrEditConnectChannelDto;

    constructor(data?: IGetConnectChannelForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectChannel = _data["connectChannel"] ? CreateOrEditConnectChannelDto.fromJS(_data["connectChannel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetConnectChannelForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetConnectChannelForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectChannel"] = this.connectChannel ? this.connectChannel.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetConnectChannelForEditOutput {
    connectChannel: CreateOrEditConnectChannelDto;
}

export class GetConnectChannelForViewDto implements IGetConnectChannelForViewDto {
    connectChannel!: ConnectChannelDto;

    constructor(data?: IGetConnectChannelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectChannel = _data["connectChannel"] ? ConnectChannelDto.fromJS(_data["connectChannel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetConnectChannelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetConnectChannelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectChannel"] = this.connectChannel ? this.connectChannel.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetConnectChannelForViewDto {
    connectChannel: ConnectChannelDto;
}

export class GetContactForEditOutput implements IGetContactForEditOutput {
    contact!: CreateOrEditContactDto;
    userName!: string | undefined;
    countryName!: string | undefined;
    stateName!: string | undefined;
    membershipTypeName!: string | undefined;

    constructor(data?: IGetContactForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contact = _data["contact"] ? CreateOrEditContactDto.fromJS(_data["contact"]) : <any>undefined;
            this.userName = _data["userName"];
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.membershipTypeName = _data["membershipTypeName"];
        }
    }

    static fromJS(data: any): GetContactForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["membershipTypeName"] = this.membershipTypeName;
        return data;
    }
}

export interface IGetContactForEditOutput {
    contact: CreateOrEditContactDto;
    userName: string | undefined;
    countryName: string | undefined;
    stateName: string | undefined;
    membershipTypeName: string | undefined;
}

export class GetContactForViewDto implements IGetContactForViewDto {
    contact!: ContactDto;
    userName!: string | undefined;
    countryName!: string | undefined;
    stateName!: string | undefined;
    membershipTypeName!: string | undefined;

    constructor(data?: IGetContactForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contact = _data["contact"] ? ContactDto.fromJS(_data["contact"]) : <any>undefined;
            this.userName = _data["userName"];
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.membershipTypeName = _data["membershipTypeName"];
        }
    }

    static fromJS(data: any): GetContactForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["membershipTypeName"] = this.membershipTypeName;
        return data;
    }
}

export interface IGetContactForViewDto {
    contact: ContactDto;
    userName: string | undefined;
    countryName: string | undefined;
    stateName: string | undefined;
    membershipTypeName: string | undefined;
}

export class GetContactTagForEditOutput implements IGetContactTagForEditOutput {
    contactTag!: CreateOrEditContactTagDto;
    contactFullName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetContactTagForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactTag = _data["contactTag"] ? CreateOrEditContactTagDto.fromJS(_data["contactTag"]) : <any>undefined;
            this.contactFullName = _data["contactFullName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetContactTagForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactTagForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactTag"] = this.contactTag ? this.contactTag.toJSON() : <any>undefined;
        data["contactFullName"] = this.contactFullName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetContactTagForEditOutput {
    contactTag: CreateOrEditContactTagDto;
    contactFullName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetContactTagForViewDto implements IGetContactTagForViewDto {
    contactTag!: ContactTagDto;
    contactFullName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetContactTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactTag = _data["contactTag"] ? ContactTagDto.fromJS(_data["contactTag"]) : <any>undefined;
            this.contactFullName = _data["contactFullName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetContactTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactTag"] = this.contactTag ? this.contactTag.toJSON() : <any>undefined;
        data["contactFullName"] = this.contactFullName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetContactTagForViewDto {
    contactTag: ContactTagDto;
    contactFullName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetContractTypeForEditOutput implements IGetContractTypeForEditOutput {
    contractType!: CreateOrEditContractTypeDto;

    constructor(data?: IGetContractTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractType = _data["contractType"] ? CreateOrEditContractTypeDto.fromJS(_data["contractType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetContractTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContractTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractType"] = this.contractType ? this.contractType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetContractTypeForEditOutput {
    contractType: CreateOrEditContractTypeDto;
}

export class GetContractTypeForViewDto implements IGetContractTypeForViewDto {
    contractType!: ContractTypeDto;

    constructor(data?: IGetContractTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractType = _data["contractType"] ? ContractTypeDto.fromJS(_data["contractType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetContractTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetContractTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractType"] = this.contractType ? this.contractType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetContractTypeForViewDto {
    contractType: ContractTypeDto;
}

export class GetCountryForEditOutput implements IGetCountryForEditOutput {
    country!: CreateOrEditCountryDto;

    constructor(data?: IGetCountryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.country = _data["country"] ? CreateOrEditCountryDto.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCountryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCountryForEditOutput {
    country: CreateOrEditCountryDto;
}

export class GetCountryForViewDto implements IGetCountryForViewDto {
    country!: CountryDto;

    constructor(data?: IGetCountryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.country = _data["country"] ? CountryDto.fromJS(_data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCountryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCountryForViewDto {
    country: CountryDto;
}

export class GetCountyForEditOutput implements IGetCountyForEditOutput {
    county!: CreateOrEditCountyDto;
    countryName!: string | undefined;
    stateName!: string | undefined;

    constructor(data?: IGetCountyForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.county = _data["county"] ? CreateOrEditCountyDto.fromJS(_data["county"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
        }
    }

    static fromJS(data: any): GetCountyForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountyForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["county"] = this.county ? this.county.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        return data;
    }
}

export interface IGetCountyForEditOutput {
    county: CreateOrEditCountyDto;
    countryName: string | undefined;
    stateName: string | undefined;
}

export class GetCountyForViewDto implements IGetCountyForViewDto {
    county!: CountyDto;
    countryName!: string | undefined;
    stateName!: string | undefined;

    constructor(data?: IGetCountyForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.county = _data["county"] ? CountyDto.fromJS(_data["county"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
        }
    }

    static fromJS(data: any): GetCountyForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountyForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["county"] = this.county ? this.county.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        return data;
    }
}

export interface IGetCountyForViewDto {
    county: CountyDto;
    countryName: string | undefined;
    stateName: string | undefined;
}

export class GetCurrencyForEditOutput implements IGetCurrencyForEditOutput {
    currency!: CreateOrEditCurrencyDto;

    constructor(data?: IGetCurrencyForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"] ? CreateOrEditCurrencyDto.fromJS(_data["currency"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrencyForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrencyForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCurrencyForEditOutput {
    currency: CreateOrEditCurrencyDto;
}

export class GetCurrencyForViewDto implements IGetCurrencyForViewDto {
    currency!: CurrencyDto;

    constructor(data?: IGetCurrencyForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrencyForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrencyForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCurrencyForViewDto {
    currency: CurrencyDto;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto;
    impersonatorUser!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    impersonatorTenant!: TenantLoginInfoDto;
    application!: ApplicationInfoDto;
    theme!: UiCustomizationSettingsDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.impersonatorUser = _data["impersonatorUser"] ? UserLoginInfoDto.fromJS(_data["impersonatorUser"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.impersonatorTenant = _data["impersonatorTenant"] ? TenantLoginInfoDto.fromJS(_data["impersonatorTenant"]) : <any>undefined;
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.theme = _data["theme"] ? UiCustomizationSettingsDto.fromJS(_data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["impersonatorUser"] = this.impersonatorUser ? this.impersonatorUser.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["impersonatorTenant"] = this.impersonatorTenant ? this.impersonatorTenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    impersonatorUser: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    impersonatorTenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
    theme: UiCustomizationSettingsDto;
}

export class GetDailySalesOutput implements IGetDailySalesOutput {
    dailySales!: number[] | undefined;

    constructor(data?: IGetDailySalesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDailySalesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailySalesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        return data;
    }
}

export interface IGetDailySalesOutput {
    dailySales: number[] | undefined;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class GetDocumentTypeForEditOutput implements IGetDocumentTypeForEditOutput {
    documentType!: CreateOrEditDocumentTypeDto;

    constructor(data?: IGetDocumentTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"] ? CreateOrEditDocumentTypeDto.fromJS(_data["documentType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDocumentTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetDocumentTypeForEditOutput {
    documentType: CreateOrEditDocumentTypeDto;
}

export class GetDocumentTypeForViewDto implements IGetDocumentTypeForViewDto {
    documentType!: DocumentTypeDto;

    constructor(data?: IGetDocumentTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"] ? DocumentTypeDto.fromJS(_data["documentType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDocumentTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetDocumentTypeForViewDto {
    documentType: DocumentTypeDto;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of _data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class GetEmailTemplateForEditOutput implements IGetEmailTemplateForEditOutput {
    emailTemplate!: CreateOrEditEmailTemplateDto;

    constructor(data?: IGetEmailTemplateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailTemplate = _data["emailTemplate"] ? CreateOrEditEmailTemplateDto.fromJS(_data["emailTemplate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEmailTemplateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmailTemplateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTemplate"] = this.emailTemplate ? this.emailTemplate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetEmailTemplateForEditOutput {
    emailTemplate: CreateOrEditEmailTemplateDto;
}

export class GetEmailTemplateForViewDto implements IGetEmailTemplateForViewDto {
    emailTemplate!: EmailTemplateDto;

    constructor(data?: IGetEmailTemplateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailTemplate = _data["emailTemplate"] ? EmailTemplateDto.fromJS(_data["emailTemplate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEmailTemplateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmailTemplateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTemplate"] = this.emailTemplate ? this.emailTemplate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetEmailTemplateForViewDto {
    emailTemplate: EmailTemplateDto;
}

export class GetEmployeeForEditOutput implements IGetEmployeeForEditOutput {
    employee!: CreateOrEditEmployeeDto;
    stateName!: string | undefined;
    countryName!: string | undefined;
    contactFullName!: string | undefined;

    constructor(data?: IGetEmployeeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employee = _data["employee"] ? CreateOrEditEmployeeDto.fromJS(_data["employee"]) : <any>undefined;
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.contactFullName = _data["contactFullName"];
        }
    }

    static fromJS(data: any): GetEmployeeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["contactFullName"] = this.contactFullName;
        return data;
    }
}

export interface IGetEmployeeForEditOutput {
    employee: CreateOrEditEmployeeDto;
    stateName: string | undefined;
    countryName: string | undefined;
    contactFullName: string | undefined;
}

export class GetEmployeeForViewDto implements IGetEmployeeForViewDto {
    employee!: EmployeeDto;
    stateName!: string | undefined;
    countryName!: string | undefined;
    contactFullName!: string | undefined;

    constructor(data?: IGetEmployeeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employee = _data["employee"] ? EmployeeDto.fromJS(_data["employee"]) : <any>undefined;
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.contactFullName = _data["contactFullName"];
        }
    }

    static fromJS(data: any): GetEmployeeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["contactFullName"] = this.contactFullName;
        return data;
    }
}

export interface IGetEmployeeForViewDto {
    employee: EmployeeDto;
    stateName: string | undefined;
    countryName: string | undefined;
    contactFullName: string | undefined;
}

export class GetEmployeeTagForEditOutput implements IGetEmployeeTagForEditOutput {
    employeeTag!: CreateOrEditEmployeeTagDto;
    employeeName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetEmployeeTagForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeTag = _data["employeeTag"] ? CreateOrEditEmployeeTagDto.fromJS(_data["employeeTag"]) : <any>undefined;
            this.employeeName = _data["employeeName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetEmployeeTagForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeTagForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeTag"] = this.employeeTag ? this.employeeTag.toJSON() : <any>undefined;
        data["employeeName"] = this.employeeName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetEmployeeTagForEditOutput {
    employeeTag: CreateOrEditEmployeeTagDto;
    employeeName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetEmployeeTagForViewDto implements IGetEmployeeTagForViewDto {
    employeeTag!: EmployeeTagDto;
    employeeName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetEmployeeTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeTag = _data["employeeTag"] ? EmployeeTagDto.fromJS(_data["employeeTag"]) : <any>undefined;
            this.employeeName = _data["employeeName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetEmployeeTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeTag"] = this.employeeTag ? this.employeeTag.toJSON() : <any>undefined;
        data["employeeName"] = this.employeeName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetEmployeeTagForViewDto {
    employeeTag: EmployeeTagDto;
    employeeName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetExpiringTenantsOutput implements IGetExpiringTenantsOutput {
    expiringTenants!: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount!: number;
    maxExpiringTenantsShownCount!: number;
    subscriptionEndDateStart!: DateTime;
    subscriptionEndDateEnd!: DateTime;

    constructor(data?: IGetExpiringTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["expiringTenants"])) {
                this.expiringTenants = [] as any;
                for (let item of _data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            this.subscriptionEndAlertDayCount = _data["subscriptionEndAlertDayCount"];
            this.maxExpiringTenantsShownCount = _data["maxExpiringTenantsShownCount"];
            this.subscriptionEndDateStart = _data["subscriptionEndDateStart"] ? DateTime.fromISO(_data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = _data["subscriptionEndDateEnd"] ? DateTime.fromISO(_data["subscriptionEndDateEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetExpiringTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpiringTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.expiringTenants)) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toString() : <any>undefined;
        return data;
    }
}

export interface IGetExpiringTenantsOutput {
    expiringTenants: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount: number;
    maxExpiringTenantsShownCount: number;
    subscriptionEndDateStart: DateTime;
    subscriptionEndDateEnd: DateTime;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data;
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
}

export class GetHubForEditOutput implements IGetHubForEditOutput {
    hub!: CreateOrEditHubDto;
    countryName!: string | undefined;
    stateName!: string | undefined;
    cityName!: string | undefined;
    countyName!: string | undefined;
    hubTypeName!: string | undefined;
    currencyName!: string | undefined;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetHubForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hub = _data["hub"] ? CreateOrEditHubDto.fromJS(_data["hub"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.cityName = _data["cityName"];
            this.countyName = _data["countyName"];
            this.hubTypeName = _data["hubTypeName"];
            this.currencyName = _data["currencyName"];
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetHubForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetHubForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hub"] = this.hub ? this.hub.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["cityName"] = this.cityName;
        data["countyName"] = this.countyName;
        data["hubTypeName"] = this.hubTypeName;
        data["currencyName"] = this.currencyName;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetHubForEditOutput {
    hub: CreateOrEditHubDto;
    countryName: string | undefined;
    stateName: string | undefined;
    cityName: string | undefined;
    countyName: string | undefined;
    hubTypeName: string | undefined;
    currencyName: string | undefined;
    mediaLibraryName: string | undefined;
}

export class GetHubForViewDto implements IGetHubForViewDto {
    hub!: HubDto;
    countryName!: string | undefined;
    stateName!: string | undefined;
    cityName!: string | undefined;
    countyName!: string | undefined;
    hubTypeName!: string | undefined;
    currencyName!: string | undefined;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetHubForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hub = _data["hub"] ? HubDto.fromJS(_data["hub"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.cityName = _data["cityName"];
            this.countyName = _data["countyName"];
            this.hubTypeName = _data["hubTypeName"];
            this.currencyName = _data["currencyName"];
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetHubForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetHubForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hub"] = this.hub ? this.hub.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["cityName"] = this.cityName;
        data["countyName"] = this.countyName;
        data["hubTypeName"] = this.hubTypeName;
        data["currencyName"] = this.currencyName;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetHubForViewDto {
    hub: HubDto;
    countryName: string | undefined;
    stateName: string | undefined;
    cityName: string | undefined;
    countyName: string | undefined;
    hubTypeName: string | undefined;
    currencyName: string | undefined;
    mediaLibraryName: string | undefined;
}

export class GetHubTypeForEditOutput implements IGetHubTypeForEditOutput {
    hubType!: CreateOrEditHubTypeDto;

    constructor(data?: IGetHubTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hubType = _data["hubType"] ? CreateOrEditHubTypeDto.fromJS(_data["hubType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetHubTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetHubTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hubType"] = this.hubType ? this.hubType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetHubTypeForEditOutput {
    hubType: CreateOrEditHubTypeDto;
}

export class GetHubTypeForViewDto implements IGetHubTypeForViewDto {
    hubType!: HubTypeDto;

    constructor(data?: IGetHubTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hubType = _data["hubType"] ? HubTypeDto.fromJS(_data["hubType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetHubTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetHubTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hubType"] = this.hubType ? this.hubType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetHubTypeForViewDto {
    hubType: HubTypeDto;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of _data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetJobForEditOutput implements IGetJobForEditOutput {
    job!: CreateOrEditJobDto;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;
    productCategoryName!: string | undefined;
    currencyName!: string | undefined;
    businessName!: string | undefined;
    countryName!: string | undefined;
    stateName!: string | undefined;
    cityName!: string | undefined;
    jobStatusTypeName!: string | undefined;
    storeName!: string | undefined;

    constructor(data?: IGetJobForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.job = _data["job"] ? CreateOrEditJobDto.fromJS(_data["job"]) : <any>undefined;
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
            this.productCategoryName = _data["productCategoryName"];
            this.currencyName = _data["currencyName"];
            this.businessName = _data["businessName"];
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.cityName = _data["cityName"];
            this.jobStatusTypeName = _data["jobStatusTypeName"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetJobForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        data["productCategoryName"] = this.productCategoryName;
        data["currencyName"] = this.currencyName;
        data["businessName"] = this.businessName;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["cityName"] = this.cityName;
        data["jobStatusTypeName"] = this.jobStatusTypeName;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetJobForEditOutput {
    job: CreateOrEditJobDto;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
    productCategoryName: string | undefined;
    currencyName: string | undefined;
    businessName: string | undefined;
    countryName: string | undefined;
    stateName: string | undefined;
    cityName: string | undefined;
    jobStatusTypeName: string | undefined;
    storeName: string | undefined;
}

export class GetJobForViewDto implements IGetJobForViewDto {
    job!: JobDto;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;
    productCategoryName!: string | undefined;
    currencyName!: string | undefined;
    businessName!: string | undefined;
    countryName!: string | undefined;
    stateName!: string | undefined;
    cityName!: string | undefined;
    jobStatusTypeName!: string | undefined;
    storeName!: string | undefined;

    constructor(data?: IGetJobForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.job = _data["job"] ? JobDto.fromJS(_data["job"]) : <any>undefined;
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
            this.productCategoryName = _data["productCategoryName"];
            this.currencyName = _data["currencyName"];
            this.businessName = _data["businessName"];
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.cityName = _data["cityName"];
            this.jobStatusTypeName = _data["jobStatusTypeName"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetJobForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        data["productCategoryName"] = this.productCategoryName;
        data["currencyName"] = this.currencyName;
        data["businessName"] = this.businessName;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["cityName"] = this.cityName;
        data["jobStatusTypeName"] = this.jobStatusTypeName;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetJobForViewDto {
    job: JobDto;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
    productCategoryName: string | undefined;
    currencyName: string | undefined;
    businessName: string | undefined;
    countryName: string | undefined;
    stateName: string | undefined;
    cityName: string | undefined;
    jobStatusTypeName: string | undefined;
    storeName: string | undefined;
}

export class GetJobStatusTypeForEditOutput implements IGetJobStatusTypeForEditOutput {
    jobStatusType!: CreateOrEditJobStatusTypeDto;

    constructor(data?: IGetJobStatusTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobStatusType = _data["jobStatusType"] ? CreateOrEditJobStatusTypeDto.fromJS(_data["jobStatusType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJobStatusTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobStatusTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobStatusType"] = this.jobStatusType ? this.jobStatusType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetJobStatusTypeForEditOutput {
    jobStatusType: CreateOrEditJobStatusTypeDto;
}

export class GetJobStatusTypeForViewDto implements IGetJobStatusTypeForViewDto {
    jobStatusType!: JobStatusTypeDto;

    constructor(data?: IGetJobStatusTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobStatusType = _data["jobStatusType"] ? JobStatusTypeDto.fromJS(_data["jobStatusType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJobStatusTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobStatusTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobStatusType"] = this.jobStatusType ? this.jobStatusType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetJobStatusTypeForViewDto {
    jobStatusType: JobStatusTypeDto;
}

export class GetJobTagForEditOutput implements IGetJobTagForEditOutput {
    jobTag!: CreateOrEditJobTagDto;
    jobTitle!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetJobTagForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobTag = _data["jobTag"] ? CreateOrEditJobTagDto.fromJS(_data["jobTag"]) : <any>undefined;
            this.jobTitle = _data["jobTitle"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetJobTagForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobTagForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobTag"] = this.jobTag ? this.jobTag.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetJobTagForEditOutput {
    jobTag: CreateOrEditJobTagDto;
    jobTitle: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetJobTagForViewDto implements IGetJobTagForViewDto {
    jobTag!: JobTagDto;
    jobTitle!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetJobTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobTag = _data["jobTag"] ? JobTagDto.fromJS(_data["jobTag"]) : <any>undefined;
            this.jobTitle = _data["jobTitle"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetJobTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobTag"] = this.jobTag ? this.jobTag.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetJobTagForViewDto {
    jobTag: JobTagDto;
    jobTitle: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : <any>undefined;
            if (Array.isArray(_data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of _data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["flags"])) {
                this.flags = [] as any;
                for (let item of _data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultLanguageName = _data["defaultLanguageName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of _data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class GetMarketplaceCommissionTypeForEditOutput implements IGetMarketplaceCommissionTypeForEditOutput {
    marketplaceCommissionType!: CreateOrEditMarketplaceCommissionTypeDto;

    constructor(data?: IGetMarketplaceCommissionTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.marketplaceCommissionType = _data["marketplaceCommissionType"] ? CreateOrEditMarketplaceCommissionTypeDto.fromJS(_data["marketplaceCommissionType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMarketplaceCommissionTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMarketplaceCommissionTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["marketplaceCommissionType"] = this.marketplaceCommissionType ? this.marketplaceCommissionType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMarketplaceCommissionTypeForEditOutput {
    marketplaceCommissionType: CreateOrEditMarketplaceCommissionTypeDto;
}

export class GetMarketplaceCommissionTypeForViewDto implements IGetMarketplaceCommissionTypeForViewDto {
    marketplaceCommissionType!: MarketplaceCommissionTypeDto;

    constructor(data?: IGetMarketplaceCommissionTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.marketplaceCommissionType = _data["marketplaceCommissionType"] ? MarketplaceCommissionTypeDto.fromJS(_data["marketplaceCommissionType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMarketplaceCommissionTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMarketplaceCommissionTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["marketplaceCommissionType"] = this.marketplaceCommissionType ? this.marketplaceCommissionType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMarketplaceCommissionTypeForViewDto {
    marketplaceCommissionType: MarketplaceCommissionTypeDto;
}

export class GetMasterTagCategoryForEditOutput implements IGetMasterTagCategoryForEditOutput {
    masterTagCategory!: CreateOrEditMasterTagCategoryDto;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetMasterTagCategoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.masterTagCategory = _data["masterTagCategory"] ? CreateOrEditMasterTagCategoryDto.fromJS(_data["masterTagCategory"]) : <any>undefined;
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetMasterTagCategoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMasterTagCategoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterTagCategory"] = this.masterTagCategory ? this.masterTagCategory.toJSON() : <any>undefined;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetMasterTagCategoryForEditOutput {
    masterTagCategory: CreateOrEditMasterTagCategoryDto;
    mediaLibraryName: string | undefined;
}

export class GetMasterTagCategoryForViewDto implements IGetMasterTagCategoryForViewDto {
    masterTagCategory!: MasterTagCategoryDto;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetMasterTagCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.masterTagCategory = _data["masterTagCategory"] ? MasterTagCategoryDto.fromJS(_data["masterTagCategory"]) : <any>undefined;
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetMasterTagCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMasterTagCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterTagCategory"] = this.masterTagCategory ? this.masterTagCategory.toJSON() : <any>undefined;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetMasterTagCategoryForViewDto {
    masterTagCategory: MasterTagCategoryDto;
    mediaLibraryName: string | undefined;
}

export class GetMasterTagForEditOutput implements IGetMasterTagForEditOutput {
    masterTag!: CreateOrEditMasterTagDto;
    masterTagCategoryName!: string | undefined;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetMasterTagForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.masterTag = _data["masterTag"] ? CreateOrEditMasterTagDto.fromJS(_data["masterTag"]) : <any>undefined;
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetMasterTagForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMasterTagForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterTag"] = this.masterTag ? this.masterTag.toJSON() : <any>undefined;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetMasterTagForEditOutput {
    masterTag: CreateOrEditMasterTagDto;
    masterTagCategoryName: string | undefined;
    mediaLibraryName: string | undefined;
}

export class GetMasterTagForViewDto implements IGetMasterTagForViewDto {
    masterTag!: MasterTagDto;
    masterTagCategoryName!: string | undefined;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetMasterTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.masterTag = _data["masterTag"] ? MasterTagDto.fromJS(_data["masterTag"]) : <any>undefined;
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetMasterTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMasterTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["masterTag"] = this.masterTag ? this.masterTag.toJSON() : <any>undefined;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetMasterTagForViewDto {
    masterTag: MasterTagDto;
    masterTagCategoryName: string | undefined;
    mediaLibraryName: string | undefined;
}

export class GetMeasurementUnitForEditOutput implements IGetMeasurementUnitForEditOutput {
    measurementUnit!: CreateOrEditMeasurementUnitDto;

    constructor(data?: IGetMeasurementUnitForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.measurementUnit = _data["measurementUnit"] ? CreateOrEditMeasurementUnitDto.fromJS(_data["measurementUnit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMeasurementUnitForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMeasurementUnitForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["measurementUnit"] = this.measurementUnit ? this.measurementUnit.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMeasurementUnitForEditOutput {
    measurementUnit: CreateOrEditMeasurementUnitDto;
}

export class GetMeasurementUnitForViewDto implements IGetMeasurementUnitForViewDto {
    measurementUnit!: MeasurementUnitDto;

    constructor(data?: IGetMeasurementUnitForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.measurementUnit = _data["measurementUnit"] ? MeasurementUnitDto.fromJS(_data["measurementUnit"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMeasurementUnitForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMeasurementUnitForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["measurementUnit"] = this.measurementUnit ? this.measurementUnit.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMeasurementUnitForViewDto {
    measurementUnit: MeasurementUnitDto;
}

export class GetMediaLibraryForEditOutput implements IGetMediaLibraryForEditOutput {
    mediaLibrary!: CreateOrEditMediaLibraryDto;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetMediaLibraryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mediaLibrary = _data["mediaLibrary"] ? CreateOrEditMediaLibraryDto.fromJS(_data["mediaLibrary"]) : <any>undefined;
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetMediaLibraryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMediaLibraryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mediaLibrary"] = this.mediaLibrary ? this.mediaLibrary.toJSON() : <any>undefined;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetMediaLibraryForEditOutput {
    mediaLibrary: CreateOrEditMediaLibraryDto;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetMediaLibraryForViewDto implements IGetMediaLibraryForViewDto {
    mediaLibrary!: MediaLibraryDto;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetMediaLibraryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mediaLibrary = _data["mediaLibrary"] ? MediaLibraryDto.fromJS(_data["mediaLibrary"]) : <any>undefined;
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetMediaLibraryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMediaLibraryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mediaLibrary"] = this.mediaLibrary ? this.mediaLibrary.toJSON() : <any>undefined;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetMediaLibraryForViewDto {
    mediaLibrary: MediaLibraryDto;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["memberActivities"])) {
                this.memberActivities = [] as any;
                for (let item of _data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberActivities)) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class GetMembershipTypeForEditOutput implements IGetMembershipTypeForEditOutput {
    membershipType!: CreateOrEditMembershipTypeDto;

    constructor(data?: IGetMembershipTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.membershipType = _data["membershipType"] ? CreateOrEditMembershipTypeDto.fromJS(_data["membershipType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMembershipTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMembershipTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["membershipType"] = this.membershipType ? this.membershipType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMembershipTypeForEditOutput {
    membershipType: CreateOrEditMembershipTypeDto;
}

export class GetMembershipTypeForViewDto implements IGetMembershipTypeForViewDto {
    membershipType!: MembershipTypeDto;

    constructor(data?: IGetMembershipTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.membershipType = _data["membershipType"] ? MembershipTypeDto.fromJS(_data["membershipType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMembershipTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMembershipTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["membershipType"] = this.membershipType ? this.membershipType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMembershipTypeForViewDto {
    membershipType: MembershipTypeDto;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class GetNotificationsCreatedByUserOutput implements IGetNotificationsCreatedByUserOutput {
    notificationName!: string | undefined;
    data!: string | undefined;
    dataTypeName!: string | undefined;
    severity!: NotificationSeverity;
    isPublished!: boolean;
    creationTime!: DateTime;

    constructor(data?: IGetNotificationsCreatedByUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationName = _data["notificationName"];
            this.data = _data["data"];
            this.dataTypeName = _data["dataTypeName"];
            this.severity = _data["severity"];
            this.isPublished = _data["isPublished"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetNotificationsCreatedByUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsCreatedByUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationName"] = this.notificationName;
        data["data"] = this.data;
        data["dataTypeName"] = this.dataTypeName;
        data["severity"] = this.severity;
        data["isPublished"] = this.isPublished;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetNotificationsCreatedByUserOutput {
    notificationName: string | undefined;
    data: string | undefined;
    dataTypeName: string | undefined;
    severity: NotificationSeverity;
    isPublished: boolean;
    creationTime: DateTime;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number;
    totalCount!: number;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unreadCount = _data["unreadCount"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting = _data["setting"] ? PasswordComplexitySetting.fromJS(_data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;
}

export class GetProductCategoryForEditOutput implements IGetProductCategoryForEditOutput {
    productCategory!: CreateOrEditProductCategoryDto;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetProductCategoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCategory = _data["productCategory"] ? CreateOrEditProductCategoryDto.fromJS(_data["productCategory"]) : <any>undefined;
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetProductCategoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductCategoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCategory"] = this.productCategory ? this.productCategory.toJSON() : <any>undefined;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetProductCategoryForEditOutput {
    productCategory: CreateOrEditProductCategoryDto;
    mediaLibraryName: string | undefined;
}

export class GetProductCategoryForViewDto implements IGetProductCategoryForViewDto {
    productCategory!: ProductCategoryDto;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetProductCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCategory = _data["productCategory"] ? ProductCategoryDto.fromJS(_data["productCategory"]) : <any>undefined;
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetProductCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCategory"] = this.productCategory ? this.productCategory.toJSON() : <any>undefined;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetProductCategoryForViewDto {
    productCategory: ProductCategoryDto;
    mediaLibraryName: string | undefined;
}

export class GetProductForEditOutput implements IGetProductForEditOutput {
    product!: CreateOrEditProductDto;
    productCategoryName!: string | undefined;
    mediaLibraryName!: string | undefined;
    measurementUnitName!: string | undefined;
    currencyName!: string | undefined;
    ratingLikeName!: string | undefined;

    constructor(data?: IGetProductForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? CreateOrEditProductDto.fromJS(_data["product"]) : <any>undefined;
            this.productCategoryName = _data["productCategoryName"];
            this.mediaLibraryName = _data["mediaLibraryName"];
            this.measurementUnitName = _data["measurementUnitName"];
            this.currencyName = _data["currencyName"];
            this.ratingLikeName = _data["ratingLikeName"];
        }
    }

    static fromJS(data: any): GetProductForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["productCategoryName"] = this.productCategoryName;
        data["mediaLibraryName"] = this.mediaLibraryName;
        data["measurementUnitName"] = this.measurementUnitName;
        data["currencyName"] = this.currencyName;
        data["ratingLikeName"] = this.ratingLikeName;
        return data;
    }
}

export interface IGetProductForEditOutput {
    product: CreateOrEditProductDto;
    productCategoryName: string | undefined;
    mediaLibraryName: string | undefined;
    measurementUnitName: string | undefined;
    currencyName: string | undefined;
    ratingLikeName: string | undefined;
}

export class GetProductForViewDto implements IGetProductForViewDto {
    product!: ProductDto;
    productCategoryName!: string | undefined;
    mediaLibraryName!: string | undefined;
    measurementUnitName!: string | undefined;
    currencyName!: string | undefined;
    ratingLikeName!: string | undefined;

    constructor(data?: IGetProductForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
            this.productCategoryName = _data["productCategoryName"];
            this.mediaLibraryName = _data["mediaLibraryName"];
            this.measurementUnitName = _data["measurementUnitName"];
            this.currencyName = _data["currencyName"];
            this.ratingLikeName = _data["ratingLikeName"];
        }
    }

    static fromJS(data: any): GetProductForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["productCategoryName"] = this.productCategoryName;
        data["mediaLibraryName"] = this.mediaLibraryName;
        data["measurementUnitName"] = this.measurementUnitName;
        data["currencyName"] = this.currencyName;
        data["ratingLikeName"] = this.ratingLikeName;
        return data;
    }
}

export interface IGetProductForViewDto {
    product: ProductDto;
    productCategoryName: string | undefined;
    mediaLibraryName: string | undefined;
    measurementUnitName: string | undefined;
    currencyName: string | undefined;
    ratingLikeName: string | undefined;
}

export class GetProductTagForEditOutput implements IGetProductTagForEditOutput {
    productTag!: CreateOrEditProductTagDto;
    productName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetProductTagForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productTag = _data["productTag"] ? CreateOrEditProductTagDto.fromJS(_data["productTag"]) : <any>undefined;
            this.productName = _data["productName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetProductTagForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductTagForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productTag"] = this.productTag ? this.productTag.toJSON() : <any>undefined;
        data["productName"] = this.productName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetProductTagForEditOutput {
    productTag: CreateOrEditProductTagDto;
    productName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetProductTagForViewDto implements IGetProductTagForViewDto {
    productTag!: ProductTagDto;
    productName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetProductTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productTag = _data["productTag"] ? ProductTagDto.fromJS(_data["productTag"]) : <any>undefined;
            this.productName = _data["productName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetProductTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productTag"] = this.productTag ? this.productTag.toJSON() : <any>undefined;
        data["productName"] = this.productName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetProductTagForViewDto {
    productTag: ProductTagDto;
    productName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data;
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class GetProfitShareOutput implements IGetProfitShareOutput {
    profitShares!: number[] | undefined;

    constructor(data?: IGetProfitShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetProfitShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfitShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetProfitShareOutput {
    profitShares: number[] | undefined;
}

export class GetPublishedNotificationsOutput implements IGetPublishedNotificationsOutput {
    totalCount!: number;
    items!: GetNotificationsCreatedByUserOutput[] | undefined;

    constructor(data?: IGetPublishedNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetNotificationsCreatedByUserOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPublishedNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPublishedNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPublishedNotificationsOutput {
    totalCount: number;
    items: GetNotificationsCreatedByUserOutput[] | undefined;
}

export class GetRatingLikeForEditOutput implements IGetRatingLikeForEditOutput {
    ratingLike!: CreateOrEditRatingLikeDto;

    constructor(data?: IGetRatingLikeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ratingLike = _data["ratingLike"] ? CreateOrEditRatingLikeDto.fromJS(_data["ratingLike"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRatingLikeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRatingLikeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ratingLike"] = this.ratingLike ? this.ratingLike.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetRatingLikeForEditOutput {
    ratingLike: CreateOrEditRatingLikeDto;
}

export class GetRatingLikeForViewDto implements IGetRatingLikeForViewDto {
    ratingLike!: RatingLikeDto;

    constructor(data?: IGetRatingLikeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ratingLike = _data["ratingLike"] ? RatingLikeDto.fromJS(_data["ratingLike"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRatingLikeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRatingLikeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ratingLike"] = this.ratingLike ? this.ratingLike.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetRatingLikeForViewDto {
    ratingLike: RatingLikeDto;
}

export class GetRecentTenantsOutput implements IGetRecentTenantsOutput {
    recentTenantsDayCount!: number;
    maxRecentTenantsShownCount!: number;
    tenantCreationStartDate!: DateTime;
    recentTenants!: RecentTenant[] | undefined;

    constructor(data?: IGetRecentTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recentTenantsDayCount = _data["recentTenantsDayCount"];
            this.maxRecentTenantsShownCount = _data["maxRecentTenantsShownCount"];
            this.tenantCreationStartDate = _data["tenantCreationStartDate"] ? DateTime.fromISO(_data["tenantCreationStartDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["recentTenants"])) {
                this.recentTenants = [] as any;
                for (let item of _data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRecentTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toString() : <any>undefined;
        if (Array.isArray(this.recentTenants)) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRecentTenantsOutput {
    recentTenantsDayCount: number;
    maxRecentTenantsShownCount: number;
    tenantCreationStartDate: DateTime;
    recentTenants: RecentTenant[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stats"])) {
                this.stats = [] as any;
                for (let item of _data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stats)) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetRolesInput implements IGetRolesInput {
    permissions!: string[] | undefined;

    constructor(data?: IGetRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IGetRolesInput {
    permissions: string[] | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetSalesSummaryOutput {
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetSmsTemplateForEditOutput implements IGetSmsTemplateForEditOutput {
    smsTemplate!: CreateOrEditSmsTemplateDto;

    constructor(data?: IGetSmsTemplateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smsTemplate = _data["smsTemplate"] ? CreateOrEditSmsTemplateDto.fromJS(_data["smsTemplate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSmsTemplateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSmsTemplateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smsTemplate"] = this.smsTemplate ? this.smsTemplate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSmsTemplateForEditOutput {
    smsTemplate: CreateOrEditSmsTemplateDto;
}

export class GetSmsTemplateForViewDto implements IGetSmsTemplateForViewDto {
    smsTemplate!: SmsTemplateDto;

    constructor(data?: IGetSmsTemplateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.smsTemplate = _data["smsTemplate"] ? SmsTemplateDto.fromJS(_data["smsTemplate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSmsTemplateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSmsTemplateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["smsTemplate"] = this.smsTemplate ? this.smsTemplate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSmsTemplateForViewDto {
    smsTemplate: SmsTemplateDto;
}

export class GetStateForEditOutput implements IGetStateForEditOutput {
    state!: CreateOrEditStateDto;
    countryName!: string | undefined;

    constructor(data?: IGetStateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"] ? CreateOrEditStateDto.fromJS(_data["state"]) : <any>undefined;
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): GetStateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IGetStateForEditOutput {
    state: CreateOrEditStateDto;
    countryName: string | undefined;
}

export class GetStateForViewDto implements IGetStateForViewDto {
    state!: StateDto;
    countryName!: string | undefined;

    constructor(data?: IGetStateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"] ? StateDto.fromJS(_data["state"]) : <any>undefined;
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): GetStateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IGetStateForViewDto {
    state: StateDto;
    countryName: string | undefined;
}

export class GetStoreAccountTeamForEditOutput implements IGetStoreAccountTeamForEditOutput {
    storeAccountTeam!: CreateOrEditStoreAccountTeamDto;
    storeName!: string | undefined;
    employeeName!: string | undefined;

    constructor(data?: IGetStoreAccountTeamForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeAccountTeam = _data["storeAccountTeam"] ? CreateOrEditStoreAccountTeamDto.fromJS(_data["storeAccountTeam"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.employeeName = _data["employeeName"];
        }
    }

    static fromJS(data: any): GetStoreAccountTeamForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreAccountTeamForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeAccountTeam"] = this.storeAccountTeam ? this.storeAccountTeam.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["employeeName"] = this.employeeName;
        return data;
    }
}

export interface IGetStoreAccountTeamForEditOutput {
    storeAccountTeam: CreateOrEditStoreAccountTeamDto;
    storeName: string | undefined;
    employeeName: string | undefined;
}

export class GetStoreAccountTeamForViewDto implements IGetStoreAccountTeamForViewDto {
    storeAccountTeam!: StoreAccountTeamDto;
    storeName!: string | undefined;
    employeeName!: string | undefined;

    constructor(data?: IGetStoreAccountTeamForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeAccountTeam = _data["storeAccountTeam"] ? StoreAccountTeamDto.fromJS(_data["storeAccountTeam"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.employeeName = _data["employeeName"];
        }
    }

    static fromJS(data: any): GetStoreAccountTeamForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreAccountTeamForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeAccountTeam"] = this.storeAccountTeam ? this.storeAccountTeam.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["employeeName"] = this.employeeName;
        return data;
    }
}

export interface IGetStoreAccountTeamForViewDto {
    storeAccountTeam: StoreAccountTeamDto;
    storeName: string | undefined;
    employeeName: string | undefined;
}

export class GetStoreBankAccountForEditOutput implements IGetStoreBankAccountForEditOutput {
    storeBankAccount!: CreateOrEditStoreBankAccountDto;
    storeName!: string | undefined;

    constructor(data?: IGetStoreBankAccountForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeBankAccount = _data["storeBankAccount"] ? CreateOrEditStoreBankAccountDto.fromJS(_data["storeBankAccount"]) : <any>undefined;
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetStoreBankAccountForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreBankAccountForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeBankAccount"] = this.storeBankAccount ? this.storeBankAccount.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetStoreBankAccountForEditOutput {
    storeBankAccount: CreateOrEditStoreBankAccountDto;
    storeName: string | undefined;
}

export class GetStoreBankAccountForViewDto implements IGetStoreBankAccountForViewDto {
    storeBankAccount!: StoreBankAccountDto;
    storeName!: string | undefined;

    constructor(data?: IGetStoreBankAccountForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeBankAccount = _data["storeBankAccount"] ? StoreBankAccountDto.fromJS(_data["storeBankAccount"]) : <any>undefined;
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetStoreBankAccountForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreBankAccountForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeBankAccount"] = this.storeBankAccount ? this.storeBankAccount.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetStoreBankAccountForViewDto {
    storeBankAccount: StoreBankAccountDto;
    storeName: string | undefined;
}

export class GetStoreBusinessCustomerMapForEditOutput implements IGetStoreBusinessCustomerMapForEditOutput {
    storeBusinessCustomerMap!: CreateOrEditStoreBusinessCustomerMapDto;
    storeName!: string | undefined;
    businessName!: string | undefined;

    constructor(data?: IGetStoreBusinessCustomerMapForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeBusinessCustomerMap = _data["storeBusinessCustomerMap"] ? CreateOrEditStoreBusinessCustomerMapDto.fromJS(_data["storeBusinessCustomerMap"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.businessName = _data["businessName"];
        }
    }

    static fromJS(data: any): GetStoreBusinessCustomerMapForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreBusinessCustomerMapForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeBusinessCustomerMap"] = this.storeBusinessCustomerMap ? this.storeBusinessCustomerMap.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["businessName"] = this.businessName;
        return data;
    }
}

export interface IGetStoreBusinessCustomerMapForEditOutput {
    storeBusinessCustomerMap: CreateOrEditStoreBusinessCustomerMapDto;
    storeName: string | undefined;
    businessName: string | undefined;
}

export class GetStoreBusinessCustomerMapForViewDto implements IGetStoreBusinessCustomerMapForViewDto {
    storeBusinessCustomerMap!: StoreBusinessCustomerMapDto;
    storeName!: string | undefined;
    businessName!: string | undefined;

    constructor(data?: IGetStoreBusinessCustomerMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeBusinessCustomerMap = _data["storeBusinessCustomerMap"] ? StoreBusinessCustomerMapDto.fromJS(_data["storeBusinessCustomerMap"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.businessName = _data["businessName"];
        }
    }

    static fromJS(data: any): GetStoreBusinessCustomerMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreBusinessCustomerMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeBusinessCustomerMap"] = this.storeBusinessCustomerMap ? this.storeBusinessCustomerMap.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["businessName"] = this.businessName;
        return data;
    }
}

export interface IGetStoreBusinessCustomerMapForViewDto {
    storeBusinessCustomerMap: StoreBusinessCustomerMapDto;
    storeName: string | undefined;
    businessName: string | undefined;
}

export class GetStoreBusinessHourForEditOutput implements IGetStoreBusinessHourForEditOutput {
    storeBusinessHour!: CreateOrEditStoreBusinessHourDto;
    storeName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetStoreBusinessHourForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeBusinessHour = _data["storeBusinessHour"] ? CreateOrEditStoreBusinessHourDto.fromJS(_data["storeBusinessHour"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetStoreBusinessHourForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreBusinessHourForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeBusinessHour"] = this.storeBusinessHour ? this.storeBusinessHour.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetStoreBusinessHourForEditOutput {
    storeBusinessHour: CreateOrEditStoreBusinessHourDto;
    storeName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetStoreBusinessHourForViewDto implements IGetStoreBusinessHourForViewDto {
    storeBusinessHour!: StoreBusinessHourDto;
    storeName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetStoreBusinessHourForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeBusinessHour = _data["storeBusinessHour"] ? StoreBusinessHourDto.fromJS(_data["storeBusinessHour"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetStoreBusinessHourForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreBusinessHourForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeBusinessHour"] = this.storeBusinessHour ? this.storeBusinessHour.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetStoreBusinessHourForViewDto {
    storeBusinessHour: StoreBusinessHourDto;
    storeName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetStoreContactMapForEditOutput implements IGetStoreContactMapForEditOutput {
    storeContactMap!: CreateOrEditStoreContactMapDto;
    storeName!: string | undefined;
    contactFullName!: string | undefined;

    constructor(data?: IGetStoreContactMapForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeContactMap = _data["storeContactMap"] ? CreateOrEditStoreContactMapDto.fromJS(_data["storeContactMap"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.contactFullName = _data["contactFullName"];
        }
    }

    static fromJS(data: any): GetStoreContactMapForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreContactMapForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeContactMap"] = this.storeContactMap ? this.storeContactMap.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["contactFullName"] = this.contactFullName;
        return data;
    }
}

export interface IGetStoreContactMapForEditOutput {
    storeContactMap: CreateOrEditStoreContactMapDto;
    storeName: string | undefined;
    contactFullName: string | undefined;
}

export class GetStoreContactMapForViewDto implements IGetStoreContactMapForViewDto {
    storeContactMap!: StoreContactMapDto;
    storeName!: string | undefined;
    contactFullName!: string | undefined;

    constructor(data?: IGetStoreContactMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeContactMap = _data["storeContactMap"] ? StoreContactMapDto.fromJS(_data["storeContactMap"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.contactFullName = _data["contactFullName"];
        }
    }

    static fromJS(data: any): GetStoreContactMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreContactMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeContactMap"] = this.storeContactMap ? this.storeContactMap.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["contactFullName"] = this.contactFullName;
        return data;
    }
}

export interface IGetStoreContactMapForViewDto {
    storeContactMap: StoreContactMapDto;
    storeName: string | undefined;
    contactFullName: string | undefined;
}

export class GetStoreForEditOutput implements IGetStoreForEditOutput {
    store!: CreateOrEditStoreDto;
    mediaLibraryName!: string | undefined;
    countryName!: string | undefined;
    stateName!: string | undefined;
    ratingLikeName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetStoreForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.store = _data["store"] ? CreateOrEditStoreDto.fromJS(_data["store"]) : <any>undefined;
            this.mediaLibraryName = _data["mediaLibraryName"];
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.ratingLikeName = _data["ratingLikeName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetStoreForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["mediaLibraryName"] = this.mediaLibraryName;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["ratingLikeName"] = this.ratingLikeName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetStoreForEditOutput {
    store: CreateOrEditStoreDto;
    mediaLibraryName: string | undefined;
    countryName: string | undefined;
    stateName: string | undefined;
    ratingLikeName: string | undefined;
    masterTagName: string | undefined;
}

export class GetStoreForViewDto implements IGetStoreForViewDto {
    store!: StoreDto;
    mediaLibraryName!: string | undefined;
    countryName!: string | undefined;
    stateName!: string | undefined;
    ratingLikeName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetStoreForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.store = _data["store"] ? StoreDto.fromJS(_data["store"]) : <any>undefined;
            this.mediaLibraryName = _data["mediaLibraryName"];
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.ratingLikeName = _data["ratingLikeName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetStoreForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["mediaLibraryName"] = this.mediaLibraryName;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["ratingLikeName"] = this.ratingLikeName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetStoreForViewDto {
    store: StoreDto;
    mediaLibraryName: string | undefined;
    countryName: string | undefined;
    stateName: string | undefined;
    ratingLikeName: string | undefined;
    masterTagName: string | undefined;
}

export class GetStoreLocationForEditOutput implements IGetStoreLocationForEditOutput {
    storeLocation!: CreateOrEditStoreLocationDto;
    cityName!: string | undefined;
    stateName!: string | undefined;
    countryName!: string | undefined;
    storeName!: string | undefined;

    constructor(data?: IGetStoreLocationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeLocation = _data["storeLocation"] ? CreateOrEditStoreLocationDto.fromJS(_data["storeLocation"]) : <any>undefined;
            this.cityName = _data["cityName"];
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetStoreLocationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreLocationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeLocation"] = this.storeLocation ? this.storeLocation.toJSON() : <any>undefined;
        data["cityName"] = this.cityName;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetStoreLocationForEditOutput {
    storeLocation: CreateOrEditStoreLocationDto;
    cityName: string | undefined;
    stateName: string | undefined;
    countryName: string | undefined;
    storeName: string | undefined;
}

export class GetStoreLocationForViewDto implements IGetStoreLocationForViewDto {
    storeLocation!: StoreLocationDto;
    cityName!: string | undefined;
    stateName!: string | undefined;
    countryName!: string | undefined;
    storeName!: string | undefined;

    constructor(data?: IGetStoreLocationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeLocation = _data["storeLocation"] ? StoreLocationDto.fromJS(_data["storeLocation"]) : <any>undefined;
            this.cityName = _data["cityName"];
            this.stateName = _data["stateName"];
            this.countryName = _data["countryName"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetStoreLocationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreLocationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeLocation"] = this.storeLocation ? this.storeLocation.toJSON() : <any>undefined;
        data["cityName"] = this.cityName;
        data["stateName"] = this.stateName;
        data["countryName"] = this.countryName;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetStoreLocationForViewDto {
    storeLocation: StoreLocationDto;
    cityName: string | undefined;
    stateName: string | undefined;
    countryName: string | undefined;
    storeName: string | undefined;
}

export class GetStoreMarketplaceCommissionSettingForEditOutput implements IGetStoreMarketplaceCommissionSettingForEditOutput {
    storeMarketplaceCommissionSetting!: CreateOrEditStoreMarketplaceCommissionSettingDto;
    storeName!: string | undefined;
    marketplaceCommissionTypeName!: string | undefined;
    productCategoryName!: string | undefined;
    productName!: string | undefined;

    constructor(data?: IGetStoreMarketplaceCommissionSettingForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeMarketplaceCommissionSetting = _data["storeMarketplaceCommissionSetting"] ? CreateOrEditStoreMarketplaceCommissionSettingDto.fromJS(_data["storeMarketplaceCommissionSetting"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.marketplaceCommissionTypeName = _data["marketplaceCommissionTypeName"];
            this.productCategoryName = _data["productCategoryName"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): GetStoreMarketplaceCommissionSettingForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreMarketplaceCommissionSettingForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeMarketplaceCommissionSetting"] = this.storeMarketplaceCommissionSetting ? this.storeMarketplaceCommissionSetting.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["marketplaceCommissionTypeName"] = this.marketplaceCommissionTypeName;
        data["productCategoryName"] = this.productCategoryName;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IGetStoreMarketplaceCommissionSettingForEditOutput {
    storeMarketplaceCommissionSetting: CreateOrEditStoreMarketplaceCommissionSettingDto;
    storeName: string | undefined;
    marketplaceCommissionTypeName: string | undefined;
    productCategoryName: string | undefined;
    productName: string | undefined;
}

export class GetStoreMarketplaceCommissionSettingForViewDto implements IGetStoreMarketplaceCommissionSettingForViewDto {
    storeMarketplaceCommissionSetting!: StoreMarketplaceCommissionSettingDto;
    storeName!: string | undefined;
    marketplaceCommissionTypeName!: string | undefined;
    productCategoryName!: string | undefined;
    productName!: string | undefined;

    constructor(data?: IGetStoreMarketplaceCommissionSettingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeMarketplaceCommissionSetting = _data["storeMarketplaceCommissionSetting"] ? StoreMarketplaceCommissionSettingDto.fromJS(_data["storeMarketplaceCommissionSetting"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.marketplaceCommissionTypeName = _data["marketplaceCommissionTypeName"];
            this.productCategoryName = _data["productCategoryName"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): GetStoreMarketplaceCommissionSettingForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreMarketplaceCommissionSettingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeMarketplaceCommissionSetting"] = this.storeMarketplaceCommissionSetting ? this.storeMarketplaceCommissionSetting.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["marketplaceCommissionTypeName"] = this.marketplaceCommissionTypeName;
        data["productCategoryName"] = this.productCategoryName;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IGetStoreMarketplaceCommissionSettingForViewDto {
    storeMarketplaceCommissionSetting: StoreMarketplaceCommissionSettingDto;
    storeName: string | undefined;
    marketplaceCommissionTypeName: string | undefined;
    productCategoryName: string | undefined;
    productName: string | undefined;
}

export class GetStoreMediaForEditOutput implements IGetStoreMediaForEditOutput {
    storeMedia!: CreateOrEditStoreMediaDto;
    storeName!: string | undefined;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetStoreMediaForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeMedia = _data["storeMedia"] ? CreateOrEditStoreMediaDto.fromJS(_data["storeMedia"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetStoreMediaForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreMediaForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeMedia"] = this.storeMedia ? this.storeMedia.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetStoreMediaForEditOutput {
    storeMedia: CreateOrEditStoreMediaDto;
    storeName: string | undefined;
    mediaLibraryName: string | undefined;
}

export class GetStoreMediaForViewDto implements IGetStoreMediaForViewDto {
    storeMedia!: StoreMediaDto;
    storeName!: string | undefined;
    mediaLibraryName!: string | undefined;

    constructor(data?: IGetStoreMediaForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeMedia = _data["storeMedia"] ? StoreMediaDto.fromJS(_data["storeMedia"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.mediaLibraryName = _data["mediaLibraryName"];
        }
    }

    static fromJS(data: any): GetStoreMediaForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreMediaForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeMedia"] = this.storeMedia ? this.storeMedia.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["mediaLibraryName"] = this.mediaLibraryName;
        return data;
    }
}

export interface IGetStoreMediaForViewDto {
    storeMedia: StoreMediaDto;
    storeName: string | undefined;
    mediaLibraryName: string | undefined;
}

export class GetStoreNoteForEditOutput implements IGetStoreNoteForEditOutput {
    storeNote!: CreateOrEditStoreNoteDto;
    storeName!: string | undefined;

    constructor(data?: IGetStoreNoteForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeNote = _data["storeNote"] ? CreateOrEditStoreNoteDto.fromJS(_data["storeNote"]) : <any>undefined;
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetStoreNoteForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreNoteForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeNote"] = this.storeNote ? this.storeNote.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetStoreNoteForEditOutput {
    storeNote: CreateOrEditStoreNoteDto;
    storeName: string | undefined;
}

export class GetStoreNoteForViewDto implements IGetStoreNoteForViewDto {
    storeNote!: StoreNoteDto;
    storeName!: string | undefined;

    constructor(data?: IGetStoreNoteForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeNote = _data["storeNote"] ? StoreNoteDto.fromJS(_data["storeNote"]) : <any>undefined;
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetStoreNoteForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreNoteForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeNote"] = this.storeNote ? this.storeNote.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetStoreNoteForViewDto {
    storeNote: StoreNoteDto;
    storeName: string | undefined;
}

export class GetStoreOwnerTeamForEditOutput implements IGetStoreOwnerTeamForEditOutput {
    storeOwnerTeam!: CreateOrEditStoreOwnerTeamDto;
    storeName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetStoreOwnerTeamForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeOwnerTeam = _data["storeOwnerTeam"] ? CreateOrEditStoreOwnerTeamDto.fromJS(_data["storeOwnerTeam"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): GetStoreOwnerTeamForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreOwnerTeamForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeOwnerTeam"] = this.storeOwnerTeam ? this.storeOwnerTeam.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IGetStoreOwnerTeamForEditOutput {
    storeOwnerTeam: CreateOrEditStoreOwnerTeamDto;
    storeName: string | undefined;
    userName: string | undefined;
}

export class GetStoreOwnerTeamForViewDto implements IGetStoreOwnerTeamForViewDto {
    storeOwnerTeam!: StoreOwnerTeamDto;
    storeName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetStoreOwnerTeamForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeOwnerTeam = _data["storeOwnerTeam"] ? StoreOwnerTeamDto.fromJS(_data["storeOwnerTeam"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): GetStoreOwnerTeamForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreOwnerTeamForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeOwnerTeam"] = this.storeOwnerTeam ? this.storeOwnerTeam.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IGetStoreOwnerTeamForViewDto {
    storeOwnerTeam: StoreOwnerTeamDto;
    storeName: string | undefined;
    userName: string | undefined;
}

export class GetStoreProductCategoryMapForEditOutput implements IGetStoreProductCategoryMapForEditOutput {
    storeProductCategoryMap!: CreateOrEditStoreProductCategoryMapDto;
    storeName!: string | undefined;
    productCategoryName!: string | undefined;

    constructor(data?: IGetStoreProductCategoryMapForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeProductCategoryMap = _data["storeProductCategoryMap"] ? CreateOrEditStoreProductCategoryMapDto.fromJS(_data["storeProductCategoryMap"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.productCategoryName = _data["productCategoryName"];
        }
    }

    static fromJS(data: any): GetStoreProductCategoryMapForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreProductCategoryMapForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeProductCategoryMap"] = this.storeProductCategoryMap ? this.storeProductCategoryMap.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["productCategoryName"] = this.productCategoryName;
        return data;
    }
}

export interface IGetStoreProductCategoryMapForEditOutput {
    storeProductCategoryMap: CreateOrEditStoreProductCategoryMapDto;
    storeName: string | undefined;
    productCategoryName: string | undefined;
}

export class GetStoreProductCategoryMapForViewDto implements IGetStoreProductCategoryMapForViewDto {
    storeProductCategoryMap!: StoreProductCategoryMapDto;
    storeName!: string | undefined;
    productCategoryName!: string | undefined;

    constructor(data?: IGetStoreProductCategoryMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeProductCategoryMap = _data["storeProductCategoryMap"] ? StoreProductCategoryMapDto.fromJS(_data["storeProductCategoryMap"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.productCategoryName = _data["productCategoryName"];
        }
    }

    static fromJS(data: any): GetStoreProductCategoryMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreProductCategoryMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeProductCategoryMap"] = this.storeProductCategoryMap ? this.storeProductCategoryMap.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["productCategoryName"] = this.productCategoryName;
        return data;
    }
}

export interface IGetStoreProductCategoryMapForViewDto {
    storeProductCategoryMap: StoreProductCategoryMapDto;
    storeName: string | undefined;
    productCategoryName: string | undefined;
}

export class GetStoreProductMapForEditOutput implements IGetStoreProductMapForEditOutput {
    storeProductMap!: CreateOrEditStoreProductMapDto;
    storeName!: string | undefined;
    productName!: string | undefined;

    constructor(data?: IGetStoreProductMapForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeProductMap = _data["storeProductMap"] ? CreateOrEditStoreProductMapDto.fromJS(_data["storeProductMap"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): GetStoreProductMapForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreProductMapForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeProductMap"] = this.storeProductMap ? this.storeProductMap.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IGetStoreProductMapForEditOutput {
    storeProductMap: CreateOrEditStoreProductMapDto;
    storeName: string | undefined;
    productName: string | undefined;
}

export class GetStoreProductMapForViewDto implements IGetStoreProductMapForViewDto {
    storeProductMap!: StoreProductMapDto;
    storeName!: string | undefined;
    productName!: string | undefined;

    constructor(data?: IGetStoreProductMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeProductMap = _data["storeProductMap"] ? StoreProductMapDto.fromJS(_data["storeProductMap"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): GetStoreProductMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreProductMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeProductMap"] = this.storeProductMap ? this.storeProductMap.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IGetStoreProductMapForViewDto {
    storeProductMap: StoreProductMapDto;
    storeName: string | undefined;
    productName: string | undefined;
}

export class GetStoreSalesAlertForEditOutput implements IGetStoreSalesAlertForEditOutput {
    storeSalesAlert!: CreateOrEditStoreSalesAlertDto;
    storeName!: string | undefined;

    constructor(data?: IGetStoreSalesAlertForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeSalesAlert = _data["storeSalesAlert"] ? CreateOrEditStoreSalesAlertDto.fromJS(_data["storeSalesAlert"]) : <any>undefined;
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetStoreSalesAlertForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreSalesAlertForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeSalesAlert"] = this.storeSalesAlert ? this.storeSalesAlert.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetStoreSalesAlertForEditOutput {
    storeSalesAlert: CreateOrEditStoreSalesAlertDto;
    storeName: string | undefined;
}

export class GetStoreSalesAlertForViewDto implements IGetStoreSalesAlertForViewDto {
    storeSalesAlert!: StoreSalesAlertDto;
    storeName!: string | undefined;

    constructor(data?: IGetStoreSalesAlertForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeSalesAlert = _data["storeSalesAlert"] ? StoreSalesAlertDto.fromJS(_data["storeSalesAlert"]) : <any>undefined;
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetStoreSalesAlertForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreSalesAlertForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeSalesAlert"] = this.storeSalesAlert ? this.storeSalesAlert.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetStoreSalesAlertForViewDto {
    storeSalesAlert: StoreSalesAlertDto;
    storeName: string | undefined;
}

export class GetStoreTagForEditOutput implements IGetStoreTagForEditOutput {
    storeTag!: CreateOrEditStoreTagDto;
    storeName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetStoreTagForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeTag = _data["storeTag"] ? CreateOrEditStoreTagDto.fromJS(_data["storeTag"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetStoreTagForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreTagForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeTag"] = this.storeTag ? this.storeTag.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetStoreTagForEditOutput {
    storeTag: CreateOrEditStoreTagDto;
    storeName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetStoreTagForViewDto implements IGetStoreTagForViewDto {
    storeTag!: StoreTagDto;
    storeName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetStoreTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeTag = _data["storeTag"] ? StoreTagDto.fromJS(_data["storeTag"]) : <any>undefined;
            this.storeName = _data["storeName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetStoreTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeTag"] = this.storeTag ? this.storeTag.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetStoreTagForViewDto {
    storeTag: StoreTagDto;
    storeName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetStoreTaxForEditOutput implements IGetStoreTaxForEditOutput {
    storeTax!: CreateOrEditStoreTaxDto;
    storeName!: string | undefined;

    constructor(data?: IGetStoreTaxForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeTax = _data["storeTax"] ? CreateOrEditStoreTaxDto.fromJS(_data["storeTax"]) : <any>undefined;
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetStoreTaxForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreTaxForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeTax"] = this.storeTax ? this.storeTax.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetStoreTaxForEditOutput {
    storeTax: CreateOrEditStoreTaxDto;
    storeName: string | undefined;
}

export class GetStoreTaxForViewDto implements IGetStoreTaxForViewDto {
    storeTax!: StoreTaxDto;
    storeName!: string | undefined;

    constructor(data?: IGetStoreTaxForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeTax = _data["storeTax"] ? StoreTaxDto.fromJS(_data["storeTax"]) : <any>undefined;
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): GetStoreTaxForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStoreTaxForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeTax"] = this.storeTax ? this.storeTax.toJSON() : <any>undefined;
        data["storeName"] = this.storeName;
        return data;
    }
}

export interface IGetStoreTaxForViewDto {
    storeTax: StoreTaxDto;
    storeName: string | undefined;
}

export class GetTaskEventForEditOutput implements IGetTaskEventForEditOutput {
    taskEvent!: CreateOrEditTaskEventDto;
    taskStatusName!: string | undefined;

    constructor(data?: IGetTaskEventForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskEvent = _data["taskEvent"] ? CreateOrEditTaskEventDto.fromJS(_data["taskEvent"]) : <any>undefined;
            this.taskStatusName = _data["taskStatusName"];
        }
    }

    static fromJS(data: any): GetTaskEventForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskEventForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskEvent"] = this.taskEvent ? this.taskEvent.toJSON() : <any>undefined;
        data["taskStatusName"] = this.taskStatusName;
        return data;
    }
}

export interface IGetTaskEventForEditOutput {
    taskEvent: CreateOrEditTaskEventDto;
    taskStatusName: string | undefined;
}

export class GetTaskEventForViewDto implements IGetTaskEventForViewDto {
    taskEvent!: TaskEventDto;
    taskStatusName!: string | undefined;

    constructor(data?: IGetTaskEventForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskEvent = _data["taskEvent"] ? TaskEventDto.fromJS(_data["taskEvent"]) : <any>undefined;
            this.taskStatusName = _data["taskStatusName"];
        }
    }

    static fromJS(data: any): GetTaskEventForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskEventForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskEvent"] = this.taskEvent ? this.taskEvent.toJSON() : <any>undefined;
        data["taskStatusName"] = this.taskStatusName;
        return data;
    }
}

export interface IGetTaskEventForViewDto {
    taskEvent: TaskEventDto;
    taskStatusName: string | undefined;
}

export class GetTaskStatusForEditOutput implements IGetTaskStatusForEditOutput {
    taskStatus!: CreateOrEditTaskStatusDto;

    constructor(data?: IGetTaskStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskStatus = _data["taskStatus"] ? CreateOrEditTaskStatusDto.fromJS(_data["taskStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTaskStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskStatus"] = this.taskStatus ? this.taskStatus.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetTaskStatusForEditOutput {
    taskStatus: CreateOrEditTaskStatusDto;
}

export class GetTaskStatusForViewDto implements IGetTaskStatusForViewDto {
    taskStatus!: TaskStatusDto;

    constructor(data?: IGetTaskStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskStatus = _data["taskStatus"] ? TaskStatusDto.fromJS(_data["taskStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTaskStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskStatus"] = this.taskStatus ? this.taskStatus.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetTaskStatusForViewDto {
    taskStatus: TaskStatusDto;
}

export class GetTaskTagForEditOutput implements IGetTaskTagForEditOutput {
    taskTag!: CreateOrEditTaskTagDto;
    taskEventName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetTaskTagForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskTag = _data["taskTag"] ? CreateOrEditTaskTagDto.fromJS(_data["taskTag"]) : <any>undefined;
            this.taskEventName = _data["taskEventName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetTaskTagForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskTagForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskTag"] = this.taskTag ? this.taskTag.toJSON() : <any>undefined;
        data["taskEventName"] = this.taskEventName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetTaskTagForEditOutput {
    taskTag: CreateOrEditTaskTagDto;
    taskEventName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetTaskTagForViewDto implements IGetTaskTagForViewDto {
    taskTag!: TaskTagDto;
    taskEventName!: string | undefined;
    masterTagCategoryName!: string | undefined;
    masterTagName!: string | undefined;

    constructor(data?: IGetTaskTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskTag = _data["taskTag"] ? TaskTagDto.fromJS(_data["taskTag"]) : <any>undefined;
            this.taskEventName = _data["taskEventName"];
            this.masterTagCategoryName = _data["masterTagCategoryName"];
            this.masterTagName = _data["masterTagName"];
        }
    }

    static fromJS(data: any): GetTaskTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaskTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskTag"] = this.taskTag ? this.taskTag.toJSON() : <any>undefined;
        data["taskEventName"] = this.taskEventName;
        data["masterTagCategoryName"] = this.masterTagCategoryName;
        data["masterTagName"] = this.masterTagName;
        return data;
    }
}

export interface IGetTaskTagForViewDto {
    taskTag: TaskTagDto;
    taskEventName: string | undefined;
    masterTagCategoryName: string | undefined;
    masterTagName: string | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class GetTopStatsOutput implements IGetTopStatsOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;

    constructor(data?: IGetTopStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
        }
    }

    static fromJS(data: any): GetTopStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTopStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        return data;
    }
}

export interface IGetTopStatsOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: DateTime;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverTime = _data["serverTime"] ? DateTime.fromISO(_data["serverTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["friends"])) {
                this.friends = [] as any;
                for (let item of _data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toString() : <any>undefined;
        if (Array.isArray(this.friends)) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: DateTime;
    friends: FriendDto[] | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;
    allowedUserNameCharacters!: string | undefined;
    isSMTPSettingsProvided!: boolean;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePictureId = _data["profilePictureId"];
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["allOrganizationUnits"])) {
                this.allOrganizationUnits = [] as any;
                for (let item of _data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["memberedOrganizationUnits"])) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of _data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
            this.allowedUserNameCharacters = _data["allowedUserNameCharacters"];
            this.isSMTPSettingsProvided = _data["isSMTPSettingsProvided"];
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.allOrganizationUnits)) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.memberedOrganizationUnits)) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        data["allowedUserNameCharacters"] = this.allowedUserNameCharacters;
        data["isSMTPSettingsProvided"] = this.isSMTPSettingsProvided;
        return data;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
    allowedUserNameCharacters: string | undefined;
    isSMTPSettingsProvided: boolean;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetUsersInput implements IGetUsersInput {
    filter!: string | undefined;
    permissions!: string[] | undefined;
    role!: number | undefined;
    onlyLockedUsers!: boolean;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.role = _data["role"];
            this.onlyLockedUsers = _data["onlyLockedUsers"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["role"] = this.role;
        data["onlyLockedUsers"] = this.onlyLockedUsers;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IGetUsersInput {
    filter: string | undefined;
    permissions: string[] | undefined;
    role: number | undefined;
    onlyLockedUsers: boolean;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetZipCodeForEditOutput implements IGetZipCodeForEditOutput {
    zipCode!: CreateOrEditZipCodeDto;
    countryName!: string | undefined;
    stateName!: string | undefined;
    cityName!: string | undefined;
    countyName!: string | undefined;

    constructor(data?: IGetZipCodeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zipCode = _data["zipCode"] ? CreateOrEditZipCodeDto.fromJS(_data["zipCode"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.cityName = _data["cityName"];
            this.countyName = _data["countyName"];
        }
    }

    static fromJS(data: any): GetZipCodeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetZipCodeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zipCode"] = this.zipCode ? this.zipCode.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["cityName"] = this.cityName;
        data["countyName"] = this.countyName;
        return data;
    }
}

export interface IGetZipCodeForEditOutput {
    zipCode: CreateOrEditZipCodeDto;
    countryName: string | undefined;
    stateName: string | undefined;
    cityName: string | undefined;
    countyName: string | undefined;
}

export class GetZipCodeForViewDto implements IGetZipCodeForViewDto {
    zipCode!: ZipCodeDto;
    countryName!: string | undefined;
    stateName!: string | undefined;
    cityName!: string | undefined;
    countyName!: string | undefined;

    constructor(data?: IGetZipCodeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zipCode = _data["zipCode"] ? ZipCodeDto.fromJS(_data["zipCode"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.stateName = _data["stateName"];
            this.cityName = _data["cityName"];
            this.countyName = _data["countyName"];
        }
    }

    static fromJS(data: any): GetZipCodeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetZipCodeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zipCode"] = this.zipCode ? this.zipCode.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["stateName"] = this.stateName;
        data["cityName"] = this.cityName;
        data["countyName"] = this.countyName;
        return data;
    }
}

export interface IGetZipCodeForViewDto {
    zipCode: ZipCodeDto;
    countryName: string | undefined;
    stateName: string | undefined;
    cityName: string | undefined;
    countyName: string | undefined;
}

export class GoogleExternalLoginProviderSettings implements IGoogleExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    userInfoEndpoint!: string | undefined;

    constructor(data?: IGoogleExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.userInfoEndpoint = _data["userInfoEndpoint"];
        }
    }

    static fromJS(data: any): GoogleExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["userInfoEndpoint"] = this.userInfoEndpoint;
        return data;
    }
}

export interface IGoogleExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    userInfoEndpoint: string | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto;
    otherSettings!: OtherSettingsEditDto;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = _data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = _data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(_data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? HostBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? OtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
    otherSettings: OtherSettingsEditDto;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean;
    smsVerificationEnabled!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    useCaptchaOnLogin!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;
    userPasswordSettings!: UserPasswordSettingsEditDto;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = _data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
            this.userPasswordSettings = _data["userPasswordSettings"] ? UserPasswordSettingsEditDto.fromJS(_data["userPasswordSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        data["userPasswordSettings"] = this.userPasswordSettings ? this.userPasswordSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    useCaptchaOnLogin: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
    userPasswordSettings: UserPasswordSettingsEditDto;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 301,
    MovedPermanently = 302,
    Moved = 303,
    Found = 304,
    Redirect = 305,
    SeeOther = 306,
    RedirectMethod = 307,
    NotModified = 308,
    UseProxy = 400,
    Unused = 401,
    TemporaryRedirect = 402,
    RedirectKeepVerb = 403,
    PermanentRedirect = 404,
    BadRequest = 405,
    Unauthorized = 406,
    PaymentRequired = 407,
    Forbidden = 408,
    NotFound = 409,
    MethodNotAllowed = 410,
    NotAcceptable = 411,
    ProxyAuthenticationRequired = 412,
    RequestTimeout = 413,
    Conflict = 414,
    Gone = 415,
    LengthRequired = 416,
    PreconditionFailed = 417,
    RequestEntityTooLarge = 421,
    RequestUriTooLong = 422,
    UnsupportedMediaType = 423,
    RequestedRangeNotSatisfiable = 424,
    ExpectationFailed = 426,
    MisdirectedRequest = 428,
    UnprocessableEntity = 429,
    Locked = 431,
    FailedDependency = 451,
    UpgradeRequired = 500,
    PreconditionRequired = 501,
    TooManyRequests = 502,
    RequestHeaderFieldsTooLarge = 503,
    UnavailableForLegalReasons = 504,
    InternalServerError = 505,
    NotImplemented = 506,
    BadGateway = 507,
    ServiceUnavailable = 508,
    GatewayTimeout = 510,
    HttpVersionNotSupported = 511,
}

export class HubCityLookupTableDto implements IHubCityLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IHubCityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): HubCityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new HubCityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IHubCityLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class HubCountryLookupTableDto implements IHubCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IHubCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): HubCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new HubCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IHubCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class HubCountyLookupTableDto implements IHubCountyLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IHubCountyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): HubCountyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new HubCountyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IHubCountyLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class HubCurrencyLookupTableDto implements IHubCurrencyLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IHubCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): HubCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new HubCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IHubCurrencyLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class HubDto implements IHubDto {
    name!: string | undefined;
    description!: string | undefined;
    estimatedPopulation!: number | undefined;
    hasParentHub!: boolean;
    parentHubId!: number | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    live!: boolean;
    url!: string | undefined;
    officeFullAddress!: string | undefined;
    partnerOrOwned!: boolean;
    phone!: string | undefined;
    yearlyRevenue!: string | undefined;
    displaySequence!: number | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    cityId!: number | undefined;
    countyId!: number | undefined;
    hubTypeId!: number;
    currencyId!: number | undefined;
    pictureMediaLibraryId!: number | undefined;
    id!: number;

    constructor(data?: IHubDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.estimatedPopulation = _data["estimatedPopulation"];
            this.hasParentHub = _data["hasParentHub"];
            this.parentHubId = _data["parentHubId"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.live = _data["live"];
            this.url = _data["url"];
            this.officeFullAddress = _data["officeFullAddress"];
            this.partnerOrOwned = _data["partnerOrOwned"];
            this.phone = _data["phone"];
            this.yearlyRevenue = _data["yearlyRevenue"];
            this.displaySequence = _data["displaySequence"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.cityId = _data["cityId"];
            this.countyId = _data["countyId"];
            this.hubTypeId = _data["hubTypeId"];
            this.currencyId = _data["currencyId"];
            this.pictureMediaLibraryId = _data["pictureMediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HubDto {
        data = typeof data === 'object' ? data : {};
        let result = new HubDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["estimatedPopulation"] = this.estimatedPopulation;
        data["hasParentHub"] = this.hasParentHub;
        data["parentHubId"] = this.parentHubId;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["live"] = this.live;
        data["url"] = this.url;
        data["officeFullAddress"] = this.officeFullAddress;
        data["partnerOrOwned"] = this.partnerOrOwned;
        data["phone"] = this.phone;
        data["yearlyRevenue"] = this.yearlyRevenue;
        data["displaySequence"] = this.displaySequence;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["cityId"] = this.cityId;
        data["countyId"] = this.countyId;
        data["hubTypeId"] = this.hubTypeId;
        data["currencyId"] = this.currencyId;
        data["pictureMediaLibraryId"] = this.pictureMediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IHubDto {
    name: string | undefined;
    description: string | undefined;
    estimatedPopulation: number | undefined;
    hasParentHub: boolean;
    parentHubId: number | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    live: boolean;
    url: string | undefined;
    officeFullAddress: string | undefined;
    partnerOrOwned: boolean;
    phone: string | undefined;
    yearlyRevenue: string | undefined;
    displaySequence: number | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    cityId: number | undefined;
    countyId: number | undefined;
    hubTypeId: number;
    currencyId: number | undefined;
    pictureMediaLibraryId: number | undefined;
    id: number;
}

export class HubHubTypeLookupTableDto implements IHubHubTypeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IHubHubTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): HubHubTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new HubHubTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IHubHubTypeLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class HubMediaLibraryLookupTableDto implements IHubMediaLibraryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IHubMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): HubMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new HubMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IHubMediaLibraryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class HubStateLookupTableDto implements IHubStateLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IHubStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): HubStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new HubStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IHubStateLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class HubTypeDto implements IHubTypeDto {
    name!: string | undefined;
    id!: number;

    constructor(data?: IHubTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HubTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new HubTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IHubTypeDto {
    name: string | undefined;
    id: number;
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>(<any>this).attributes)![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>(<any>this).attributes)![key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        return data;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.impersonationToken = _data["impersonationToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class ImpersonateTenantInput implements IImpersonateTenantInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IImpersonateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IImpersonateTenantInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonateUserInput implements IImpersonateUserInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IImpersonateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IImpersonateUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: DateTime;
    amount!: number;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: DateTime;
    amount: number;
}

export class InsertOrUpdateAllValuesInput implements IInsertOrUpdateAllValuesInput {
    items!: InsertOrUpdateAllValuesInputItem[] | undefined;

    constructor(data?: IInsertOrUpdateAllValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InsertOrUpdateAllValuesInputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsertOrUpdateAllValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateAllValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInsertOrUpdateAllValuesInput {
    items: InsertOrUpdateAllValuesInputItem[] | undefined;
}

export class InsertOrUpdateAllValuesInputItem implements IInsertOrUpdateAllValuesInputItem {
    entityId!: string | undefined;
    dynamicEntityPropertyId!: number;
    values!: string[] | undefined;

    constructor(data?: IInsertOrUpdateAllValuesInputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): InsertOrUpdateAllValuesInputItem {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateAllValuesInputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

export interface IInsertOrUpdateAllValuesInputItem {
    entityId: string | undefined;
    dynamicEntityPropertyId: number;
    values: string[] | undefined;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto;
    billInfo!: HostBillingSettingsEditDto;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionString = _data["connectionString"];
            this.adminPassword = _data["adminPassword"];
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverUrl = _data["serverUrl"];
            this.defaultLanguage = _data["defaultLanguage"];
            this.smtpSettings = _data["smtpSettings"] ? EmailSettingsEditDto.fromJS(_data["smtpSettings"]) : <any>undefined;
            this.billInfo = _data["billInfo"] ? HostBillingSettingsEditDto.fromJS(_data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: DateTime;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = _data["tenantLegalName"];
            if (Array.isArray(_data["tenantAddress"])) {
                this.tenantAddress = [] as any;
                for (let item of _data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = _data["tenantTaxNo"];
            this.hostLegalName = _data["hostLegalName"];
            if (Array.isArray(_data["hostAddress"])) {
                this.hostAddress = [] as any;
                for (let item of _data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (Array.isArray(this.tenantAddress)) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (Array.isArray(this.hostAddress)) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data;
    }
}

export interface IInvoiceDto {
    amount: number;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: DateTime;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.serverRootAddress = _data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class JobBusinessLookupTableDto implements IJobBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobCityLookupTableDto implements IJobCityLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobCityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobCityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobCityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobCityLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobCountryLookupTableDto implements IJobCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobCurrencyLookupTableDto implements IJobCurrencyLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobCurrencyLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobDto implements IJobDto {
    title!: string | undefined;
    fullTimeJobOrGigWorkProject!: boolean;
    remoteWorkOrOnSiteWork!: boolean;
    salaryBasedOrFixedPrice!: boolean;
    salaryOrStaffingRate!: string | undefined;
    referralPoints!: string | undefined;
    template!: boolean;
    numberOfJobs!: number | undefined;
    minimumExperience!: string | undefined;
    maximumExperience!: string | undefined;
    jobDescription!: string | undefined;
    jobLocationFullAddress!: string | undefined;
    zipCode!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    startDate!: DateTime | undefined;
    hireByDate!: DateTime | undefined;
    publishDate!: DateTime | undefined;
    expirationDate!: DateTime | undefined;
    internalJobDescription!: string | undefined;
    cityLocation!: string | undefined;
    published!: boolean;
    url!: string | undefined;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    productCategoryId!: number | undefined;
    currencyId!: number | undefined;
    businessId!: number | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    cityId!: number | undefined;
    jobStatusTypeId!: number | undefined;
    storeId!: number | undefined;
    id!: number;

    constructor(data?: IJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.fullTimeJobOrGigWorkProject = _data["fullTimeJobOrGigWorkProject"];
            this.remoteWorkOrOnSiteWork = _data["remoteWorkOrOnSiteWork"];
            this.salaryBasedOrFixedPrice = _data["salaryBasedOrFixedPrice"];
            this.salaryOrStaffingRate = _data["salaryOrStaffingRate"];
            this.referralPoints = _data["referralPoints"];
            this.template = _data["template"];
            this.numberOfJobs = _data["numberOfJobs"];
            this.minimumExperience = _data["minimumExperience"];
            this.maximumExperience = _data["maximumExperience"];
            this.jobDescription = _data["jobDescription"];
            this.jobLocationFullAddress = _data["jobLocationFullAddress"];
            this.zipCode = _data["zipCode"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.hireByDate = _data["hireByDate"] ? DateTime.fromISO(_data["hireByDate"].toString()) : <any>undefined;
            this.publishDate = _data["publishDate"] ? DateTime.fromISO(_data["publishDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? DateTime.fromISO(_data["expirationDate"].toString()) : <any>undefined;
            this.internalJobDescription = _data["internalJobDescription"];
            this.cityLocation = _data["cityLocation"];
            this.published = _data["published"];
            this.url = _data["url"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.productCategoryId = _data["productCategoryId"];
            this.currencyId = _data["currencyId"];
            this.businessId = _data["businessId"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.cityId = _data["cityId"];
            this.jobStatusTypeId = _data["jobStatusTypeId"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): JobDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["fullTimeJobOrGigWorkProject"] = this.fullTimeJobOrGigWorkProject;
        data["remoteWorkOrOnSiteWork"] = this.remoteWorkOrOnSiteWork;
        data["salaryBasedOrFixedPrice"] = this.salaryBasedOrFixedPrice;
        data["salaryOrStaffingRate"] = this.salaryOrStaffingRate;
        data["referralPoints"] = this.referralPoints;
        data["template"] = this.template;
        data["numberOfJobs"] = this.numberOfJobs;
        data["minimumExperience"] = this.minimumExperience;
        data["maximumExperience"] = this.maximumExperience;
        data["jobDescription"] = this.jobDescription;
        data["jobLocationFullAddress"] = this.jobLocationFullAddress;
        data["zipCode"] = this.zipCode;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["hireByDate"] = this.hireByDate ? this.hireByDate.toString() : <any>undefined;
        data["publishDate"] = this.publishDate ? this.publishDate.toString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toString() : <any>undefined;
        data["internalJobDescription"] = this.internalJobDescription;
        data["cityLocation"] = this.cityLocation;
        data["published"] = this.published;
        data["url"] = this.url;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["productCategoryId"] = this.productCategoryId;
        data["currencyId"] = this.currencyId;
        data["businessId"] = this.businessId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["cityId"] = this.cityId;
        data["jobStatusTypeId"] = this.jobStatusTypeId;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface IJobDto {
    title: string | undefined;
    fullTimeJobOrGigWorkProject: boolean;
    remoteWorkOrOnSiteWork: boolean;
    salaryBasedOrFixedPrice: boolean;
    salaryOrStaffingRate: string | undefined;
    referralPoints: string | undefined;
    template: boolean;
    numberOfJobs: number | undefined;
    minimumExperience: string | undefined;
    maximumExperience: string | undefined;
    jobDescription: string | undefined;
    jobLocationFullAddress: string | undefined;
    zipCode: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    startDate: DateTime | undefined;
    hireByDate: DateTime | undefined;
    publishDate: DateTime | undefined;
    expirationDate: DateTime | undefined;
    internalJobDescription: string | undefined;
    cityLocation: string | undefined;
    published: boolean;
    url: string | undefined;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    productCategoryId: number | undefined;
    currencyId: number | undefined;
    businessId: number | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    cityId: number | undefined;
    jobStatusTypeId: number | undefined;
    storeId: number | undefined;
    id: number;
}

export class JobJobStatusTypeLookupTableDto implements IJobJobStatusTypeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobJobStatusTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobJobStatusTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobJobStatusTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobJobStatusTypeLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobMasterTagCategoryLookupTableDto implements IJobMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobMasterTagLookupTableDto implements IJobMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobProductCategoryLookupTableDto implements IJobProductCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobProductCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobProductCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobProductCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobProductCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobStateLookupTableDto implements IJobStateLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobStateLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobStatusTypeDto implements IJobStatusTypeDto {
    name!: string | undefined;
    id!: number;

    constructor(data?: IJobStatusTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): JobStatusTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobStatusTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IJobStatusTypeDto {
    name: string | undefined;
    id: number;
}

export class JobStoreLookupTableDto implements IJobStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobTagDto implements IJobTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    jobId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number;

    constructor(data?: IJobTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.jobId = _data["jobId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): JobTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["jobId"] = this.jobId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface IJobTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    jobId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number;
}

export class JobTagJobLookupTableDto implements IJobTagJobLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobTagJobLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobTagJobLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobTagJobLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobTagJobLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobTagMasterTagCategoryLookupTableDto implements IJobTagMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobTagMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JobTagMasterTagLookupTableDto implements IJobTagMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IJobTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): JobTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IJobTagMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class JsonClaimMapDto implements IJsonClaimMapDto {
    claim!: string | undefined;
    key!: string | undefined;

    constructor(data?: IJsonClaimMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claim = _data["claim"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): JsonClaimMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new JsonClaimMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claim"] = this.claim;
        data["key"] = this.key;
        return data;
    }
}

export interface IJsonClaimMapDto {
    claim: string | undefined;
    key: string | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.baseValue = _data["baseValue"];
            this.targetValue = _data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data;
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean;
    isEnabled!: boolean;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isModuleEnabled = _data["isModuleEnabled"];
            this.isEnabled = _data["isEnabled"];
            this.domain = _data["domain"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.username = _data["username"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ListResultDtoOfDynamicEntityPropertyDto implements IListResultDtoOfDynamicEntityPropertyDto {
    items!: DynamicEntityPropertyDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicEntityPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicEntityPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicEntityPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicEntityPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicEntityPropertyDto {
    items: DynamicEntityPropertyDto[] | undefined;
}

export class ListResultDtoOfDynamicEntityPropertyValueDto implements IListResultDtoOfDynamicEntityPropertyValueDto {
    items!: DynamicEntityPropertyValueDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicEntityPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicEntityPropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicEntityPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicEntityPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicEntityPropertyValueDto {
    items: DynamicEntityPropertyValueDto[] | undefined;
}

export class ListResultDtoOfDynamicPropertyDto implements IListResultDtoOfDynamicPropertyDto {
    items!: DynamicPropertyDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicPropertyDto {
    items: DynamicPropertyDto[] | undefined;
}

export class ListResultDtoOfDynamicPropertyValueDto implements IListResultDtoOfDynamicPropertyValueDto {
    items!: DynamicPropertyValueDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicPropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicPropertyValueDto {
    items: DynamicPropertyValueDto[] | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class ListResultDtoOfGetAllAvailableWebhooksOutput implements IListResultDtoOfGetAllAvailableWebhooksOutput {
    items!: GetAllAvailableWebhooksOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllAvailableWebhooksOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllAvailableWebhooksOutput {
    items: GetAllAvailableWebhooksOutput[] | undefined;
}

export class ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput implements IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
    items!: GetAllEntitiesHasDynamicPropertyOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllEntitiesHasDynamicPropertyOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
    items: GetAllEntitiesHasDynamicPropertyOutput[] | undefined;
}

export class ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput implements IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items!: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOfWebhookEventOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;
}

export class ListResultDtoOfGetAllSubscriptionsOutput implements IListResultDtoOfGetAllSubscriptionsOutput {
    items!: GetAllSubscriptionsOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSubscriptionsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllSubscriptionsOutput {
    items: GetAllSubscriptionsOutput[] | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number;
}

export class MarketplaceCommissionTypeDto implements IMarketplaceCommissionTypeDto {
    name!: string | undefined;
    percentage!: number | undefined;
    fixedAmount!: number | undefined;
    id!: number;

    constructor(data?: IMarketplaceCommissionTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.percentage = _data["percentage"];
            this.fixedAmount = _data["fixedAmount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MarketplaceCommissionTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MarketplaceCommissionTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["percentage"] = this.percentage;
        data["fixedAmount"] = this.fixedAmount;
        data["id"] = this.id;
        return data;
    }
}

export interface IMarketplaceCommissionTypeDto {
    name: string | undefined;
    percentage: number | undefined;
    fixedAmount: number | undefined;
    id: number;
}

export class MassNotificationOrganizationUnitLookupTableDto implements IMassNotificationOrganizationUnitLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IMassNotificationOrganizationUnitLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MassNotificationOrganizationUnitLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MassNotificationOrganizationUnitLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMassNotificationOrganizationUnitLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class MassNotificationUserLookupTableDto implements IMassNotificationUserLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IMassNotificationUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MassNotificationUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MassNotificationUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMassNotificationUserLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class MasterTagCategoryDto implements IMasterTagCategoryDto {
    name!: string | undefined;
    description!: string | undefined;
    pictureMediaLibraryId!: number | undefined;
    id!: number;

    constructor(data?: IMasterTagCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.pictureMediaLibraryId = _data["pictureMediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MasterTagCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterTagCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["pictureMediaLibraryId"] = this.pictureMediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IMasterTagCategoryDto {
    name: string | undefined;
    description: string | undefined;
    pictureMediaLibraryId: number | undefined;
    id: number;
}

export class MasterTagCategoryMediaLibraryLookupTableDto implements IMasterTagCategoryMediaLibraryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IMasterTagCategoryMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MasterTagCategoryMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterTagCategoryMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMasterTagCategoryMediaLibraryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class MasterTagDto implements IMasterTagDto {
    name!: string | undefined;
    description!: string | undefined;
    synonyms!: string | undefined;
    displaySequence!: number | undefined;
    masterTagCategoryId!: number;
    pictureMediaLibraryId!: number | undefined;
    id!: number;

    constructor(data?: IMasterTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.synonyms = _data["synonyms"];
            this.displaySequence = _data["displaySequence"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.pictureMediaLibraryId = _data["pictureMediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MasterTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["synonyms"] = this.synonyms;
        data["displaySequence"] = this.displaySequence;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["pictureMediaLibraryId"] = this.pictureMediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IMasterTagDto {
    name: string | undefined;
    description: string | undefined;
    synonyms: string | undefined;
    displaySequence: number | undefined;
    masterTagCategoryId: number;
    pictureMediaLibraryId: number | undefined;
    id: number;
}

export class MasterTagMasterTagCategoryLookupTableDto implements IMasterTagMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IMasterTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MasterTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMasterTagMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class MasterTagMediaLibraryLookupTableDto implements IMasterTagMediaLibraryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IMasterTagMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MasterTagMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MasterTagMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMasterTagMediaLibraryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class MeasurementUnitDto implements IMeasurementUnitDto {
    name!: string | undefined;
    id!: number;

    constructor(data?: IMeasurementUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MeasurementUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new MeasurementUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface IMeasurementUnitDto {
    name: string | undefined;
    id: number;
}

export class MediaLibraryDto implements IMediaLibraryDto {
    name!: string | undefined;
    size!: string | undefined;
    fileExtension!: string | undefined;
    dimension!: string | undefined;
    videoLink!: string | undefined;
    seoTag!: string | undefined;
    altTag!: string | undefined;
    virtualPath!: string | undefined;
    binaryObjectId!: string;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number;

    constructor(data?: IMediaLibraryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.size = _data["size"];
            this.fileExtension = _data["fileExtension"];
            this.dimension = _data["dimension"];
            this.videoLink = _data["videoLink"];
            this.seoTag = _data["seoTag"];
            this.altTag = _data["altTag"];
            this.virtualPath = _data["virtualPath"];
            this.binaryObjectId = _data["binaryObjectId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MediaLibraryDto {
        data = typeof data === 'object' ? data : {};
        let result = new MediaLibraryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["size"] = this.size;
        data["fileExtension"] = this.fileExtension;
        data["dimension"] = this.dimension;
        data["videoLink"] = this.videoLink;
        data["seoTag"] = this.seoTag;
        data["altTag"] = this.altTag;
        data["virtualPath"] = this.virtualPath;
        data["binaryObjectId"] = this.binaryObjectId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface IMediaLibraryDto {
    name: string | undefined;
    size: string | undefined;
    fileExtension: string | undefined;
    dimension: string | undefined;
    videoLink: string | undefined;
    seoTag: string | undefined;
    altTag: string | undefined;
    virtualPath: string | undefined;
    binaryObjectId: string;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number;
}

export class MediaLibraryMasterTagCategoryLookupTableDto implements IMediaLibraryMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IMediaLibraryMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MediaLibraryMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MediaLibraryMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMediaLibraryMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class MediaLibraryMasterTagLookupTableDto implements IMediaLibraryMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IMediaLibraryMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MediaLibraryMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MediaLibraryMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMediaLibraryMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number;
    closed!: number;
    rate!: string | undefined;
    profilePictureName!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.earnings = _data["earnings"];
            this.cases = _data["cases"];
            this.closed = _data["closed"];
            this.rate = _data["rate"];
            this.profilePictureName = _data["profilePictureName"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        data["profilePictureName"] = this.profilePictureName;
        return data;
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number;
    closed: number;
    rate: string | undefined;
    profilePictureName: string | undefined;
}

export class MembershipTypeDto implements IMembershipTypeDto {
    name!: string | undefined;
    description!: string | undefined;
    id!: number;

    constructor(data?: IMembershipTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MembershipTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MembershipTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }
}

export interface IMembershipTypeDto {
    name: string | undefined;
    description: string | undefined;
    id: number;
}

export class MicrosoftExternalLoginProviderSettings implements IMicrosoftExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: IMicrosoftExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): MicrosoftExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MicrosoftExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data;
    }
}

export interface IMicrosoftExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number;
    targetEditionId!: number;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceEditionId = _data["sourceEditionId"];
            this.targetEditionId = _data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data;
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0,
    Success = 1,
    Warn = 2,
    Error = 3,
    Fatal = 4,
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean;
}

export class OpenIdConnectExternalLoginProviderSettings implements IOpenIdConnectExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    authority!: string | undefined;
    loginUrl!: string | undefined;
    validateIssuer!: boolean;
    responseType!: string | undefined;

    constructor(data?: IOpenIdConnectExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.authority = _data["authority"];
            this.loginUrl = _data["loginUrl"];
            this.validateIssuer = _data["validateIssuer"];
            this.responseType = _data["responseType"];
        }
    }

    static fromJS(data: any): OpenIdConnectExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OpenIdConnectExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["authority"] = this.authority;
        data["loginUrl"] = this.loginUrl;
        data["validateIssuer"] = this.validateIssuer;
        data["responseType"] = this.responseType;
        return data;
    }
}

export interface IOpenIdConnectExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    authority: string | undefined;
    loginUrl: string | undefined;
    validateIssuer: boolean;
    responseType: string | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.name = _data["name"];
            this.addedTime = _data["addedTime"] ? DateTime.fromISO(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: DateTime;
    id: number;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.addedTime = _data["addedTime"] ? DateTime.fromISO(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: DateTime;
    id: number;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class Page implements IPage {
    id!: string | undefined;
    name!: string | undefined;
    widgets!: Widget[] | undefined;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(Widget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPage {
    id: string | undefined;
    name: string | undefined;
    widgets: Widget[] | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class PagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto implements IPagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto {
    totalCount!: number;
    items!: BusinessAccountTeamBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessAccountTeamBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessAccountTeamBusinessLookupTableDto {
    totalCount: number;
    items: BusinessAccountTeamBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto implements IPagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto {
    totalCount!: number;
    items!: BusinessAccountTeamEmployeeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessAccountTeamEmployeeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessAccountTeamEmployeeLookupTableDto {
    totalCount: number;
    items: BusinessAccountTeamEmployeeLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessContactMapBusinessLookupTableDto implements IPagedResultDtoOfBusinessContactMapBusinessLookupTableDto {
    totalCount!: number;
    items!: BusinessContactMapBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessContactMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessContactMapBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessContactMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessContactMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessContactMapBusinessLookupTableDto {
    totalCount: number;
    items: BusinessContactMapBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessContactMapContactLookupTableDto implements IPagedResultDtoOfBusinessContactMapContactLookupTableDto {
    totalCount!: number;
    items!: BusinessContactMapContactLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessContactMapContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessContactMapContactLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessContactMapContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessContactMapContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessContactMapContactLookupTableDto {
    totalCount: number;
    items: BusinessContactMapContactLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessJobMapBusinessLookupTableDto implements IPagedResultDtoOfBusinessJobMapBusinessLookupTableDto {
    totalCount!: number;
    items!: BusinessJobMapBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessJobMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessJobMapBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessJobMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessJobMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessJobMapBusinessLookupTableDto {
    totalCount: number;
    items: BusinessJobMapBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessJobMapJobLookupTableDto implements IPagedResultDtoOfBusinessJobMapJobLookupTableDto {
    totalCount!: number;
    items!: BusinessJobMapJobLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessJobMapJobLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessJobMapJobLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessJobMapJobLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessJobMapJobLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessJobMapJobLookupTableDto {
    totalCount: number;
    items: BusinessJobMapJobLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessMediaLibraryLookupTableDto implements IPagedResultDtoOfBusinessMediaLibraryLookupTableDto {
    totalCount!: number;
    items!: BusinessMediaLibraryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessMediaLibraryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessMediaLibraryLookupTableDto {
    totalCount: number;
    items: BusinessMediaLibraryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessNoteBusinessLookupTableDto implements IPagedResultDtoOfBusinessNoteBusinessLookupTableDto {
    totalCount!: number;
    items!: BusinessNoteBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessNoteBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessNoteBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessNoteBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessNoteBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessNoteBusinessLookupTableDto {
    totalCount: number;
    items: BusinessNoteBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessProductMapBusinessLookupTableDto implements IPagedResultDtoOfBusinessProductMapBusinessLookupTableDto {
    totalCount!: number;
    items!: BusinessProductMapBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessProductMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessProductMapBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessProductMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessProductMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessProductMapBusinessLookupTableDto {
    totalCount: number;
    items: BusinessProductMapBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessProductMapProductLookupTableDto implements IPagedResultDtoOfBusinessProductMapProductLookupTableDto {
    totalCount!: number;
    items!: BusinessProductMapProductLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessProductMapProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessProductMapProductLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessProductMapProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessProductMapProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessProductMapProductLookupTableDto {
    totalCount: number;
    items: BusinessProductMapProductLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessStoreMapBusinessLookupTableDto implements IPagedResultDtoOfBusinessStoreMapBusinessLookupTableDto {
    totalCount!: number;
    items!: BusinessStoreMapBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessStoreMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessStoreMapBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessStoreMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessStoreMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessStoreMapBusinessLookupTableDto {
    totalCount: number;
    items: BusinessStoreMapBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessStoreMapStoreLookupTableDto implements IPagedResultDtoOfBusinessStoreMapStoreLookupTableDto {
    totalCount!: number;
    items!: BusinessStoreMapStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessStoreMapStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessStoreMapStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessStoreMapStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessStoreMapStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessStoreMapStoreLookupTableDto {
    totalCount: number;
    items: BusinessStoreMapStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessTagBusinessLookupTableDto implements IPagedResultDtoOfBusinessTagBusinessLookupTableDto {
    totalCount!: number;
    items!: BusinessTagBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessTagBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessTagBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessTagBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessTagBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessTagBusinessLookupTableDto {
    totalCount: number;
    items: BusinessTagBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto implements IPagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto {
    totalCount!: number;
    items!: BusinessTagMasterTagCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessTagMasterTagCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessTagMasterTagCategoryLookupTableDto {
    totalCount: number;
    items: BusinessTagMasterTagCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessTagMasterTagLookupTableDto implements IPagedResultDtoOfBusinessTagMasterTagLookupTableDto {
    totalCount!: number;
    items!: BusinessTagMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessTagMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessTagMasterTagLookupTableDto {
    totalCount: number;
    items: BusinessTagMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessTaskMapBusinessLookupTableDto implements IPagedResultDtoOfBusinessTaskMapBusinessLookupTableDto {
    totalCount!: number;
    items!: BusinessTaskMapBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessTaskMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessTaskMapBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessTaskMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessTaskMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessTaskMapBusinessLookupTableDto {
    totalCount: number;
    items: BusinessTaskMapBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto implements IPagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto {
    totalCount!: number;
    items!: BusinessTaskMapTaskEventLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessTaskMapTaskEventLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessTaskMapTaskEventLookupTableDto {
    totalCount: number;
    items: BusinessTaskMapTaskEventLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessUserBusinessLookupTableDto implements IPagedResultDtoOfBusinessUserBusinessLookupTableDto {
    totalCount!: number;
    items!: BusinessUserBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessUserBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessUserBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessUserBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessUserBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessUserBusinessLookupTableDto {
    totalCount: number;
    items: BusinessUserBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfBusinessUserUserLookupTableDto implements IPagedResultDtoOfBusinessUserUserLookupTableDto {
    totalCount!: number;
    items!: BusinessUserUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBusinessUserUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BusinessUserUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBusinessUserUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBusinessUserUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBusinessUserUserLookupTableDto {
    totalCount: number;
    items: BusinessUserUserLookupTableDto[] | undefined;
}

export class PagedResultDtoOfContactTagContactLookupTableDto implements IPagedResultDtoOfContactTagContactLookupTableDto {
    totalCount!: number;
    items!: ContactTagContactLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactTagContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContactTagContactLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactTagContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactTagContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfContactTagContactLookupTableDto {
    totalCount: number;
    items: ContactTagContactLookupTableDto[] | undefined;
}

export class PagedResultDtoOfContactTagMasterTagCategoryLookupTableDto implements IPagedResultDtoOfContactTagMasterTagCategoryLookupTableDto {
    totalCount!: number;
    items!: ContactTagMasterTagCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContactTagMasterTagCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfContactTagMasterTagCategoryLookupTableDto {
    totalCount: number;
    items: ContactTagMasterTagCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfContactTagMasterTagLookupTableDto implements IPagedResultDtoOfContactTagMasterTagLookupTableDto {
    totalCount!: number;
    items!: ContactTagMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContactTagMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfContactTagMasterTagLookupTableDto {
    totalCount: number;
    items: ContactTagMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfContactUserLookupTableDto implements IPagedResultDtoOfContactUserLookupTableDto {
    totalCount!: number;
    items!: ContactUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContactUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfContactUserLookupTableDto {
    totalCount: number;
    items: ContactUserLookupTableDto[] | undefined;
}

export class PagedResultDtoOfEmployeeContactLookupTableDto implements IPagedResultDtoOfEmployeeContactLookupTableDto {
    totalCount!: number;
    items!: EmployeeContactLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmployeeContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EmployeeContactLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmployeeContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmployeeContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEmployeeContactLookupTableDto {
    totalCount: number;
    items: EmployeeContactLookupTableDto[] | undefined;
}

export class PagedResultDtoOfEmployeeCountryLookupTableDto implements IPagedResultDtoOfEmployeeCountryLookupTableDto {
    totalCount!: number;
    items!: EmployeeCountryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmployeeCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EmployeeCountryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmployeeCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmployeeCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEmployeeCountryLookupTableDto {
    totalCount: number;
    items: EmployeeCountryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfEmployeeStateLookupTableDto implements IPagedResultDtoOfEmployeeStateLookupTableDto {
    totalCount!: number;
    items!: EmployeeStateLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmployeeStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EmployeeStateLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmployeeStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmployeeStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEmployeeStateLookupTableDto {
    totalCount: number;
    items: EmployeeStateLookupTableDto[] | undefined;
}

export class PagedResultDtoOfEmployeeTagEmployeeLookupTableDto implements IPagedResultDtoOfEmployeeTagEmployeeLookupTableDto {
    totalCount!: number;
    items!: EmployeeTagEmployeeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmployeeTagEmployeeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EmployeeTagEmployeeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmployeeTagEmployeeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmployeeTagEmployeeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEmployeeTagEmployeeLookupTableDto {
    totalCount: number;
    items: EmployeeTagEmployeeLookupTableDto[] | undefined;
}

export class PagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto implements IPagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto {
    totalCount!: number;
    items!: EmployeeTagMasterTagCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EmployeeTagMasterTagCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEmployeeTagMasterTagCategoryLookupTableDto {
    totalCount: number;
    items: EmployeeTagMasterTagCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfEmployeeTagMasterTagLookupTableDto implements IPagedResultDtoOfEmployeeTagMasterTagLookupTableDto {
    totalCount!: number;
    items!: EmployeeTagMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmployeeTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EmployeeTagMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmployeeTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmployeeTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEmployeeTagMasterTagLookupTableDto {
    totalCount: number;
    items: EmployeeTagMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;
}

export class PagedResultDtoOfGetAllSendAttemptsOutput implements IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount!: number;
    items!: GetAllSendAttemptsOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount: number;
    items: GetAllSendAttemptsOutput[] | undefined;
}

export class PagedResultDtoOfGetBusinessAccountTeamForViewDto implements IPagedResultDtoOfGetBusinessAccountTeamForViewDto {
    totalCount!: number;
    items!: GetBusinessAccountTeamForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusinessAccountTeamForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBusinessAccountTeamForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusinessAccountTeamForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusinessAccountTeamForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBusinessAccountTeamForViewDto {
    totalCount: number;
    items: GetBusinessAccountTeamForViewDto[] | undefined;
}

export class PagedResultDtoOfGetBusinessContactMapForViewDto implements IPagedResultDtoOfGetBusinessContactMapForViewDto {
    totalCount!: number;
    items!: GetBusinessContactMapForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusinessContactMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBusinessContactMapForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusinessContactMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusinessContactMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBusinessContactMapForViewDto {
    totalCount: number;
    items: GetBusinessContactMapForViewDto[] | undefined;
}

export class PagedResultDtoOfGetBusinessForViewDto implements IPagedResultDtoOfGetBusinessForViewDto {
    totalCount!: number;
    items!: GetBusinessForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusinessForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBusinessForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusinessForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusinessForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBusinessForViewDto {
    totalCount: number;
    items: GetBusinessForViewDto[] | undefined;
}

export class PagedResultDtoOfGetBusinessJobMapForViewDto implements IPagedResultDtoOfGetBusinessJobMapForViewDto {
    totalCount!: number;
    items!: GetBusinessJobMapForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusinessJobMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBusinessJobMapForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusinessJobMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusinessJobMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBusinessJobMapForViewDto {
    totalCount: number;
    items: GetBusinessJobMapForViewDto[] | undefined;
}

export class PagedResultDtoOfGetBusinessNoteForViewDto implements IPagedResultDtoOfGetBusinessNoteForViewDto {
    totalCount!: number;
    items!: GetBusinessNoteForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusinessNoteForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBusinessNoteForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusinessNoteForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusinessNoteForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBusinessNoteForViewDto {
    totalCount: number;
    items: GetBusinessNoteForViewDto[] | undefined;
}

export class PagedResultDtoOfGetBusinessProductMapForViewDto implements IPagedResultDtoOfGetBusinessProductMapForViewDto {
    totalCount!: number;
    items!: GetBusinessProductMapForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusinessProductMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBusinessProductMapForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusinessProductMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusinessProductMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBusinessProductMapForViewDto {
    totalCount: number;
    items: GetBusinessProductMapForViewDto[] | undefined;
}

export class PagedResultDtoOfGetBusinessStoreMapForViewDto implements IPagedResultDtoOfGetBusinessStoreMapForViewDto {
    totalCount!: number;
    items!: GetBusinessStoreMapForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusinessStoreMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBusinessStoreMapForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusinessStoreMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusinessStoreMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBusinessStoreMapForViewDto {
    totalCount: number;
    items: GetBusinessStoreMapForViewDto[] | undefined;
}

export class PagedResultDtoOfGetBusinessTagForViewDto implements IPagedResultDtoOfGetBusinessTagForViewDto {
    totalCount!: number;
    items!: GetBusinessTagForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusinessTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBusinessTagForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusinessTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusinessTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBusinessTagForViewDto {
    totalCount: number;
    items: GetBusinessTagForViewDto[] | undefined;
}

export class PagedResultDtoOfGetBusinessTaskMapForViewDto implements IPagedResultDtoOfGetBusinessTaskMapForViewDto {
    totalCount!: number;
    items!: GetBusinessTaskMapForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusinessTaskMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBusinessTaskMapForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusinessTaskMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusinessTaskMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBusinessTaskMapForViewDto {
    totalCount: number;
    items: GetBusinessTaskMapForViewDto[] | undefined;
}

export class PagedResultDtoOfGetBusinessUserForViewDto implements IPagedResultDtoOfGetBusinessUserForViewDto {
    totalCount!: number;
    items!: GetBusinessUserForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusinessUserForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetBusinessUserForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusinessUserForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusinessUserForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBusinessUserForViewDto {
    totalCount: number;
    items: GetBusinessUserForViewDto[] | undefined;
}

export class PagedResultDtoOfGetCityForViewDto implements IPagedResultDtoOfGetCityForViewDto {
    totalCount!: number;
    items!: GetCityForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetCityForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetCityForViewDto {
    totalCount: number;
    items: GetCityForViewDto[] | undefined;
}

export class PagedResultDtoOfGetConnectChannelForViewDto implements IPagedResultDtoOfGetConnectChannelForViewDto {
    totalCount!: number;
    items!: GetConnectChannelForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetConnectChannelForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetConnectChannelForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetConnectChannelForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetConnectChannelForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetConnectChannelForViewDto {
    totalCount: number;
    items: GetConnectChannelForViewDto[] | undefined;
}

export class PagedResultDtoOfGetContactForViewDto implements IPagedResultDtoOfGetContactForViewDto {
    totalCount!: number;
    items!: GetContactForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetContactForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetContactForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetContactForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetContactForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetContactForViewDto {
    totalCount: number;
    items: GetContactForViewDto[] | undefined;
}

export class PagedResultDtoOfGetContactTagForViewDto implements IPagedResultDtoOfGetContactTagForViewDto {
    totalCount!: number;
    items!: GetContactTagForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetContactTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetContactTagForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetContactTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetContactTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetContactTagForViewDto {
    totalCount: number;
    items: GetContactTagForViewDto[] | undefined;
}

export class PagedResultDtoOfGetContractTypeForViewDto implements IPagedResultDtoOfGetContractTypeForViewDto {
    totalCount!: number;
    items!: GetContractTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetContractTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetContractTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetContractTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetContractTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetContractTypeForViewDto {
    totalCount: number;
    items: GetContractTypeForViewDto[] | undefined;
}

export class PagedResultDtoOfGetCountryForViewDto implements IPagedResultDtoOfGetCountryForViewDto {
    totalCount!: number;
    items!: GetCountryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCountryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetCountryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCountryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCountryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetCountryForViewDto {
    totalCount: number;
    items: GetCountryForViewDto[] | undefined;
}

export class PagedResultDtoOfGetCountyForViewDto implements IPagedResultDtoOfGetCountyForViewDto {
    totalCount!: number;
    items!: GetCountyForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCountyForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetCountyForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCountyForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCountyForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetCountyForViewDto {
    totalCount: number;
    items: GetCountyForViewDto[] | undefined;
}

export class PagedResultDtoOfGetCurrencyForViewDto implements IPagedResultDtoOfGetCurrencyForViewDto {
    totalCount!: number;
    items!: GetCurrencyForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCurrencyForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetCurrencyForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCurrencyForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCurrencyForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetCurrencyForViewDto {
    totalCount: number;
    items: GetCurrencyForViewDto[] | undefined;
}

export class PagedResultDtoOfGetDocumentTypeForViewDto implements IPagedResultDtoOfGetDocumentTypeForViewDto {
    totalCount!: number;
    items!: GetDocumentTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDocumentTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetDocumentTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDocumentTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDocumentTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetDocumentTypeForViewDto {
    totalCount: number;
    items: GetDocumentTypeForViewDto[] | undefined;
}

export class PagedResultDtoOfGetEmailTemplateForViewDto implements IPagedResultDtoOfGetEmailTemplateForViewDto {
    totalCount!: number;
    items!: GetEmailTemplateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEmailTemplateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetEmailTemplateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEmailTemplateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEmailTemplateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetEmailTemplateForViewDto {
    totalCount: number;
    items: GetEmailTemplateForViewDto[] | undefined;
}

export class PagedResultDtoOfGetEmployeeForViewDto implements IPagedResultDtoOfGetEmployeeForViewDto {
    totalCount!: number;
    items!: GetEmployeeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEmployeeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetEmployeeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEmployeeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEmployeeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetEmployeeForViewDto {
    totalCount: number;
    items: GetEmployeeForViewDto[] | undefined;
}

export class PagedResultDtoOfGetEmployeeTagForViewDto implements IPagedResultDtoOfGetEmployeeTagForViewDto {
    totalCount!: number;
    items!: GetEmployeeTagForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEmployeeTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetEmployeeTagForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEmployeeTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEmployeeTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetEmployeeTagForViewDto {
    totalCount: number;
    items: GetEmployeeTagForViewDto[] | undefined;
}

export class PagedResultDtoOfGetHubForViewDto implements IPagedResultDtoOfGetHubForViewDto {
    totalCount!: number;
    items!: GetHubForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetHubForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetHubForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetHubForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetHubForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetHubForViewDto {
    totalCount: number;
    items: GetHubForViewDto[] | undefined;
}

export class PagedResultDtoOfGetHubTypeForViewDto implements IPagedResultDtoOfGetHubTypeForViewDto {
    totalCount!: number;
    items!: GetHubTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetHubTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetHubTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetHubTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetHubTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetHubTypeForViewDto {
    totalCount: number;
    items: GetHubTypeForViewDto[] | undefined;
}

export class PagedResultDtoOfGetJobForViewDto implements IPagedResultDtoOfGetJobForViewDto {
    totalCount!: number;
    items!: GetJobForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetJobForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetJobForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetJobForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetJobForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetJobForViewDto {
    totalCount: number;
    items: GetJobForViewDto[] | undefined;
}

export class PagedResultDtoOfGetJobStatusTypeForViewDto implements IPagedResultDtoOfGetJobStatusTypeForViewDto {
    totalCount!: number;
    items!: GetJobStatusTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetJobStatusTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetJobStatusTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetJobStatusTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetJobStatusTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetJobStatusTypeForViewDto {
    totalCount: number;
    items: GetJobStatusTypeForViewDto[] | undefined;
}

export class PagedResultDtoOfGetJobTagForViewDto implements IPagedResultDtoOfGetJobTagForViewDto {
    totalCount!: number;
    items!: GetJobTagForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetJobTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetJobTagForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetJobTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetJobTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetJobTagForViewDto {
    totalCount: number;
    items: GetJobTagForViewDto[] | undefined;
}

export class PagedResultDtoOfGetMarketplaceCommissionTypeForViewDto implements IPagedResultDtoOfGetMarketplaceCommissionTypeForViewDto {
    totalCount!: number;
    items!: GetMarketplaceCommissionTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMarketplaceCommissionTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMarketplaceCommissionTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMarketplaceCommissionTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMarketplaceCommissionTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMarketplaceCommissionTypeForViewDto {
    totalCount: number;
    items: GetMarketplaceCommissionTypeForViewDto[] | undefined;
}

export class PagedResultDtoOfGetMasterTagCategoryForViewDto implements IPagedResultDtoOfGetMasterTagCategoryForViewDto {
    totalCount!: number;
    items!: GetMasterTagCategoryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMasterTagCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMasterTagCategoryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMasterTagCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMasterTagCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMasterTagCategoryForViewDto {
    totalCount: number;
    items: GetMasterTagCategoryForViewDto[] | undefined;
}

export class PagedResultDtoOfGetMasterTagForViewDto implements IPagedResultDtoOfGetMasterTagForViewDto {
    totalCount!: number;
    items!: GetMasterTagForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMasterTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMasterTagForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMasterTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMasterTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMasterTagForViewDto {
    totalCount: number;
    items: GetMasterTagForViewDto[] | undefined;
}

export class PagedResultDtoOfGetMeasurementUnitForViewDto implements IPagedResultDtoOfGetMeasurementUnitForViewDto {
    totalCount!: number;
    items!: GetMeasurementUnitForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMeasurementUnitForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMeasurementUnitForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMeasurementUnitForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMeasurementUnitForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMeasurementUnitForViewDto {
    totalCount: number;
    items: GetMeasurementUnitForViewDto[] | undefined;
}

export class PagedResultDtoOfGetMediaLibraryForViewDto implements IPagedResultDtoOfGetMediaLibraryForViewDto {
    totalCount!: number;
    items!: GetMediaLibraryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMediaLibraryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMediaLibraryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMediaLibraryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMediaLibraryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMediaLibraryForViewDto {
    totalCount: number;
    items: GetMediaLibraryForViewDto[] | undefined;
}

export class PagedResultDtoOfGetMembershipTypeForViewDto implements IPagedResultDtoOfGetMembershipTypeForViewDto {
    totalCount!: number;
    items!: GetMembershipTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMembershipTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMembershipTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMembershipTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMembershipTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMembershipTypeForViewDto {
    totalCount: number;
    items: GetMembershipTypeForViewDto[] | undefined;
}

export class PagedResultDtoOfGetProductCategoryForViewDto implements IPagedResultDtoOfGetProductCategoryForViewDto {
    totalCount!: number;
    items!: GetProductCategoryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetProductCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetProductCategoryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProductCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetProductCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetProductCategoryForViewDto {
    totalCount: number;
    items: GetProductCategoryForViewDto[] | undefined;
}

export class PagedResultDtoOfGetProductForViewDto implements IPagedResultDtoOfGetProductForViewDto {
    totalCount!: number;
    items!: GetProductForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetProductForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetProductForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProductForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetProductForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetProductForViewDto {
    totalCount: number;
    items: GetProductForViewDto[] | undefined;
}

export class PagedResultDtoOfGetProductTagForViewDto implements IPagedResultDtoOfGetProductTagForViewDto {
    totalCount!: number;
    items!: GetProductTagForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetProductTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetProductTagForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProductTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetProductTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetProductTagForViewDto {
    totalCount: number;
    items: GetProductTagForViewDto[] | undefined;
}

export class PagedResultDtoOfGetRatingLikeForViewDto implements IPagedResultDtoOfGetRatingLikeForViewDto {
    totalCount!: number;
    items!: GetRatingLikeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRatingLikeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetRatingLikeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRatingLikeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRatingLikeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetRatingLikeForViewDto {
    totalCount: number;
    items: GetRatingLikeForViewDto[] | undefined;
}

export class PagedResultDtoOfGetSmsTemplateForViewDto implements IPagedResultDtoOfGetSmsTemplateForViewDto {
    totalCount!: number;
    items!: GetSmsTemplateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSmsTemplateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSmsTemplateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSmsTemplateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSmsTemplateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSmsTemplateForViewDto {
    totalCount: number;
    items: GetSmsTemplateForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStateForViewDto implements IPagedResultDtoOfGetStateForViewDto {
    totalCount!: number;
    items!: GetStateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStateForViewDto {
    totalCount: number;
    items: GetStateForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreAccountTeamForViewDto implements IPagedResultDtoOfGetStoreAccountTeamForViewDto {
    totalCount!: number;
    items!: GetStoreAccountTeamForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreAccountTeamForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreAccountTeamForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreAccountTeamForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreAccountTeamForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreAccountTeamForViewDto {
    totalCount: number;
    items: GetStoreAccountTeamForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreBankAccountForViewDto implements IPagedResultDtoOfGetStoreBankAccountForViewDto {
    totalCount!: number;
    items!: GetStoreBankAccountForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreBankAccountForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreBankAccountForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreBankAccountForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreBankAccountForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreBankAccountForViewDto {
    totalCount: number;
    items: GetStoreBankAccountForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreBusinessCustomerMapForViewDto implements IPagedResultDtoOfGetStoreBusinessCustomerMapForViewDto {
    totalCount!: number;
    items!: GetStoreBusinessCustomerMapForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreBusinessCustomerMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreBusinessCustomerMapForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreBusinessCustomerMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreBusinessCustomerMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreBusinessCustomerMapForViewDto {
    totalCount: number;
    items: GetStoreBusinessCustomerMapForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreBusinessHourForViewDto implements IPagedResultDtoOfGetStoreBusinessHourForViewDto {
    totalCount!: number;
    items!: GetStoreBusinessHourForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreBusinessHourForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreBusinessHourForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreBusinessHourForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreBusinessHourForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreBusinessHourForViewDto {
    totalCount: number;
    items: GetStoreBusinessHourForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreContactMapForViewDto implements IPagedResultDtoOfGetStoreContactMapForViewDto {
    totalCount!: number;
    items!: GetStoreContactMapForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreContactMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreContactMapForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreContactMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreContactMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreContactMapForViewDto {
    totalCount: number;
    items: GetStoreContactMapForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreForViewDto implements IPagedResultDtoOfGetStoreForViewDto {
    totalCount!: number;
    items!: GetStoreForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreForViewDto {
    totalCount: number;
    items: GetStoreForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreLocationForViewDto implements IPagedResultDtoOfGetStoreLocationForViewDto {
    totalCount!: number;
    items!: GetStoreLocationForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreLocationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreLocationForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreLocationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreLocationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreLocationForViewDto {
    totalCount: number;
    items: GetStoreLocationForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto implements IPagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto {
    totalCount!: number;
    items!: GetStoreMarketplaceCommissionSettingForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreMarketplaceCommissionSettingForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreMarketplaceCommissionSettingForViewDto {
    totalCount: number;
    items: GetStoreMarketplaceCommissionSettingForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreMediaForViewDto implements IPagedResultDtoOfGetStoreMediaForViewDto {
    totalCount!: number;
    items!: GetStoreMediaForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreMediaForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreMediaForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreMediaForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreMediaForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreMediaForViewDto {
    totalCount: number;
    items: GetStoreMediaForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreNoteForViewDto implements IPagedResultDtoOfGetStoreNoteForViewDto {
    totalCount!: number;
    items!: GetStoreNoteForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreNoteForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreNoteForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreNoteForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreNoteForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreNoteForViewDto {
    totalCount: number;
    items: GetStoreNoteForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreOwnerTeamForViewDto implements IPagedResultDtoOfGetStoreOwnerTeamForViewDto {
    totalCount!: number;
    items!: GetStoreOwnerTeamForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreOwnerTeamForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreOwnerTeamForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreOwnerTeamForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreOwnerTeamForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreOwnerTeamForViewDto {
    totalCount: number;
    items: GetStoreOwnerTeamForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreProductCategoryMapForViewDto implements IPagedResultDtoOfGetStoreProductCategoryMapForViewDto {
    totalCount!: number;
    items!: GetStoreProductCategoryMapForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreProductCategoryMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreProductCategoryMapForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreProductCategoryMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreProductCategoryMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreProductCategoryMapForViewDto {
    totalCount: number;
    items: GetStoreProductCategoryMapForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreProductMapForViewDto implements IPagedResultDtoOfGetStoreProductMapForViewDto {
    totalCount!: number;
    items!: GetStoreProductMapForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreProductMapForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreProductMapForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreProductMapForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreProductMapForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreProductMapForViewDto {
    totalCount: number;
    items: GetStoreProductMapForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreSalesAlertForViewDto implements IPagedResultDtoOfGetStoreSalesAlertForViewDto {
    totalCount!: number;
    items!: GetStoreSalesAlertForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreSalesAlertForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreSalesAlertForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreSalesAlertForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreSalesAlertForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreSalesAlertForViewDto {
    totalCount: number;
    items: GetStoreSalesAlertForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreTagForViewDto implements IPagedResultDtoOfGetStoreTagForViewDto {
    totalCount!: number;
    items!: GetStoreTagForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreTagForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreTagForViewDto {
    totalCount: number;
    items: GetStoreTagForViewDto[] | undefined;
}

export class PagedResultDtoOfGetStoreTaxForViewDto implements IPagedResultDtoOfGetStoreTaxForViewDto {
    totalCount!: number;
    items!: GetStoreTaxForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStoreTaxForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetStoreTaxForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStoreTaxForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStoreTaxForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetStoreTaxForViewDto {
    totalCount: number;
    items: GetStoreTaxForViewDto[] | undefined;
}

export class PagedResultDtoOfGetTaskEventForViewDto implements IPagedResultDtoOfGetTaskEventForViewDto {
    totalCount!: number;
    items!: GetTaskEventForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTaskEventForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTaskEventForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTaskEventForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTaskEventForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTaskEventForViewDto {
    totalCount: number;
    items: GetTaskEventForViewDto[] | undefined;
}

export class PagedResultDtoOfGetTaskStatusForViewDto implements IPagedResultDtoOfGetTaskStatusForViewDto {
    totalCount!: number;
    items!: GetTaskStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTaskStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTaskStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTaskStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTaskStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTaskStatusForViewDto {
    totalCount: number;
    items: GetTaskStatusForViewDto[] | undefined;
}

export class PagedResultDtoOfGetTaskTagForViewDto implements IPagedResultDtoOfGetTaskTagForViewDto {
    totalCount!: number;
    items!: GetTaskTagForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTaskTagForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTaskTagForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTaskTagForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTaskTagForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTaskTagForViewDto {
    totalCount: number;
    items: GetTaskTagForViewDto[] | undefined;
}

export class PagedResultDtoOfGetZipCodeForViewDto implements IPagedResultDtoOfGetZipCodeForViewDto {
    totalCount!: number;
    items!: GetZipCodeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetZipCodeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetZipCodeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetZipCodeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetZipCodeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetZipCodeForViewDto {
    totalCount: number;
    items: GetZipCodeForViewDto[] | undefined;
}

export class PagedResultDtoOfHubMediaLibraryLookupTableDto implements IPagedResultDtoOfHubMediaLibraryLookupTableDto {
    totalCount!: number;
    items!: HubMediaLibraryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfHubMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HubMediaLibraryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfHubMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfHubMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfHubMediaLibraryLookupTableDto {
    totalCount: number;
    items: HubMediaLibraryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobBusinessLookupTableDto implements IPagedResultDtoOfJobBusinessLookupTableDto {
    totalCount!: number;
    items!: JobBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobBusinessLookupTableDto {
    totalCount: number;
    items: JobBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobCityLookupTableDto implements IPagedResultDtoOfJobCityLookupTableDto {
    totalCount!: number;
    items!: JobCityLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobCityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobCityLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobCityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobCityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobCityLookupTableDto {
    totalCount: number;
    items: JobCityLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobCountryLookupTableDto implements IPagedResultDtoOfJobCountryLookupTableDto {
    totalCount!: number;
    items!: JobCountryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobCountryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobCountryLookupTableDto {
    totalCount: number;
    items: JobCountryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobCurrencyLookupTableDto implements IPagedResultDtoOfJobCurrencyLookupTableDto {
    totalCount!: number;
    items!: JobCurrencyLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobCurrencyLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobCurrencyLookupTableDto {
    totalCount: number;
    items: JobCurrencyLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobJobStatusTypeLookupTableDto implements IPagedResultDtoOfJobJobStatusTypeLookupTableDto {
    totalCount!: number;
    items!: JobJobStatusTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobJobStatusTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobJobStatusTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobJobStatusTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobJobStatusTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobJobStatusTypeLookupTableDto {
    totalCount: number;
    items: JobJobStatusTypeLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobMasterTagCategoryLookupTableDto implements IPagedResultDtoOfJobMasterTagCategoryLookupTableDto {
    totalCount!: number;
    items!: JobMasterTagCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobMasterTagCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobMasterTagCategoryLookupTableDto {
    totalCount: number;
    items: JobMasterTagCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobMasterTagLookupTableDto implements IPagedResultDtoOfJobMasterTagLookupTableDto {
    totalCount!: number;
    items!: JobMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobMasterTagLookupTableDto {
    totalCount: number;
    items: JobMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobProductCategoryLookupTableDto implements IPagedResultDtoOfJobProductCategoryLookupTableDto {
    totalCount!: number;
    items!: JobProductCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobProductCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobProductCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobProductCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobProductCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobProductCategoryLookupTableDto {
    totalCount: number;
    items: JobProductCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobStateLookupTableDto implements IPagedResultDtoOfJobStateLookupTableDto {
    totalCount!: number;
    items!: JobStateLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobStateLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobStateLookupTableDto {
    totalCount: number;
    items: JobStateLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobStoreLookupTableDto implements IPagedResultDtoOfJobStoreLookupTableDto {
    totalCount!: number;
    items!: JobStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobStoreLookupTableDto {
    totalCount: number;
    items: JobStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobTagJobLookupTableDto implements IPagedResultDtoOfJobTagJobLookupTableDto {
    totalCount!: number;
    items!: JobTagJobLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobTagJobLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobTagJobLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobTagJobLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobTagJobLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobTagJobLookupTableDto {
    totalCount: number;
    items: JobTagJobLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobTagMasterTagCategoryLookupTableDto implements IPagedResultDtoOfJobTagMasterTagCategoryLookupTableDto {
    totalCount!: number;
    items!: JobTagMasterTagCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobTagMasterTagCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobTagMasterTagCategoryLookupTableDto {
    totalCount: number;
    items: JobTagMasterTagCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfJobTagMasterTagLookupTableDto implements IPagedResultDtoOfJobTagMasterTagLookupTableDto {
    totalCount!: number;
    items!: JobTagMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(JobTagMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfJobTagMasterTagLookupTableDto {
    totalCount: number;
    items: JobTagMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;
}

export class PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto implements IPagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto {
    totalCount!: number;
    items!: MassNotificationOrganizationUnitLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MassNotificationOrganizationUnitLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto {
    totalCount: number;
    items: MassNotificationOrganizationUnitLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMassNotificationUserLookupTableDto implements IPagedResultDtoOfMassNotificationUserLookupTableDto {
    totalCount!: number;
    items!: MassNotificationUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMassNotificationUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MassNotificationUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMassNotificationUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMassNotificationUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMassNotificationUserLookupTableDto {
    totalCount: number;
    items: MassNotificationUserLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto implements IPagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto {
    totalCount!: number;
    items!: MasterTagCategoryMediaLibraryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MasterTagCategoryMediaLibraryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMasterTagCategoryMediaLibraryLookupTableDto {
    totalCount: number;
    items: MasterTagCategoryMediaLibraryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMasterTagMediaLibraryLookupTableDto implements IPagedResultDtoOfMasterTagMediaLibraryLookupTableDto {
    totalCount!: number;
    items!: MasterTagMediaLibraryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMasterTagMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MasterTagMediaLibraryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMasterTagMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMasterTagMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMasterTagMediaLibraryLookupTableDto {
    totalCount: number;
    items: MasterTagMediaLibraryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto implements IPagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto {
    totalCount!: number;
    items!: MediaLibraryMasterTagCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MediaLibraryMasterTagCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMediaLibraryMasterTagCategoryLookupTableDto {
    totalCount: number;
    items: MediaLibraryMasterTagCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMediaLibraryMasterTagLookupTableDto implements IPagedResultDtoOfMediaLibraryMasterTagLookupTableDto {
    totalCount!: number;
    items!: MediaLibraryMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMediaLibraryMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MediaLibraryMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMediaLibraryMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMediaLibraryMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMediaLibraryMasterTagLookupTableDto {
    totalCount: number;
    items: MediaLibraryMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class PagedResultDtoOfProductCategoryMediaLibraryLookupTableDto implements IPagedResultDtoOfProductCategoryMediaLibraryLookupTableDto {
    totalCount!: number;
    items!: ProductCategoryMediaLibraryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductCategoryMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductCategoryMediaLibraryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductCategoryMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductCategoryMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProductCategoryMediaLibraryLookupTableDto {
    totalCount: number;
    items: ProductCategoryMediaLibraryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfProductCurrencyLookupTableDto implements IPagedResultDtoOfProductCurrencyLookupTableDto {
    totalCount!: number;
    items!: ProductCurrencyLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductCurrencyLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProductCurrencyLookupTableDto {
    totalCount: number;
    items: ProductCurrencyLookupTableDto[] | undefined;
}

export class PagedResultDtoOfProductMeasurementUnitLookupTableDto implements IPagedResultDtoOfProductMeasurementUnitLookupTableDto {
    totalCount!: number;
    items!: ProductMeasurementUnitLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductMeasurementUnitLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductMeasurementUnitLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductMeasurementUnitLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductMeasurementUnitLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProductMeasurementUnitLookupTableDto {
    totalCount: number;
    items: ProductMeasurementUnitLookupTableDto[] | undefined;
}

export class PagedResultDtoOfProductMediaLibraryLookupTableDto implements IPagedResultDtoOfProductMediaLibraryLookupTableDto {
    totalCount!: number;
    items!: ProductMediaLibraryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductMediaLibraryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProductMediaLibraryLookupTableDto {
    totalCount: number;
    items: ProductMediaLibraryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfProductProductCategoryLookupTableDto implements IPagedResultDtoOfProductProductCategoryLookupTableDto {
    totalCount!: number;
    items!: ProductProductCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductProductCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductProductCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductProductCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductProductCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProductProductCategoryLookupTableDto {
    totalCount: number;
    items: ProductProductCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfProductRatingLikeLookupTableDto implements IPagedResultDtoOfProductRatingLikeLookupTableDto {
    totalCount!: number;
    items!: ProductRatingLikeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductRatingLikeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductRatingLikeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductRatingLikeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductRatingLikeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProductRatingLikeLookupTableDto {
    totalCount: number;
    items: ProductRatingLikeLookupTableDto[] | undefined;
}

export class PagedResultDtoOfProductTagMasterTagCategoryLookupTableDto implements IPagedResultDtoOfProductTagMasterTagCategoryLookupTableDto {
    totalCount!: number;
    items!: ProductTagMasterTagCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductTagMasterTagCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProductTagMasterTagCategoryLookupTableDto {
    totalCount: number;
    items: ProductTagMasterTagCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfProductTagMasterTagLookupTableDto implements IPagedResultDtoOfProductTagMasterTagLookupTableDto {
    totalCount!: number;
    items!: ProductTagMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductTagMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProductTagMasterTagLookupTableDto {
    totalCount: number;
    items: ProductTagMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfProductTagProductLookupTableDto implements IPagedResultDtoOfProductTagProductLookupTableDto {
    totalCount!: number;
    items!: ProductTagProductLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductTagProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductTagProductLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductTagProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductTagProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfProductTagProductLookupTableDto {
    totalCount: number;
    items: ProductTagProductLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto implements IPagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto {
    totalCount!: number;
    items!: StoreAccountTeamEmployeeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreAccountTeamEmployeeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreAccountTeamEmployeeLookupTableDto {
    totalCount: number;
    items: StoreAccountTeamEmployeeLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreAccountTeamStoreLookupTableDto implements IPagedResultDtoOfStoreAccountTeamStoreLookupTableDto {
    totalCount!: number;
    items!: StoreAccountTeamStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreAccountTeamStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreAccountTeamStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreAccountTeamStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreAccountTeamStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreAccountTeamStoreLookupTableDto {
    totalCount: number;
    items: StoreAccountTeamStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreBankAccountStoreLookupTableDto implements IPagedResultDtoOfStoreBankAccountStoreLookupTableDto {
    totalCount!: number;
    items!: StoreBankAccountStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreBankAccountStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreBankAccountStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreBankAccountStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreBankAccountStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreBankAccountStoreLookupTableDto {
    totalCount: number;
    items: StoreBankAccountStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto implements IPagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto {
    totalCount!: number;
    items!: StoreBusinessCustomerMapBusinessLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreBusinessCustomerMapBusinessLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreBusinessCustomerMapBusinessLookupTableDto {
    totalCount: number;
    items: StoreBusinessCustomerMapBusinessLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto implements IPagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto {
    totalCount!: number;
    items!: StoreBusinessCustomerMapStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreBusinessCustomerMapStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreBusinessCustomerMapStoreLookupTableDto {
    totalCount: number;
    items: StoreBusinessCustomerMapStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto implements IPagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto {
    totalCount!: number;
    items!: StoreBusinessHourMasterTagCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreBusinessHourMasterTagCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreBusinessHourMasterTagCategoryLookupTableDto {
    totalCount: number;
    items: StoreBusinessHourMasterTagCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto implements IPagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto {
    totalCount!: number;
    items!: StoreBusinessHourMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreBusinessHourMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreBusinessHourMasterTagLookupTableDto {
    totalCount: number;
    items: StoreBusinessHourMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreBusinessHourStoreLookupTableDto implements IPagedResultDtoOfStoreBusinessHourStoreLookupTableDto {
    totalCount!: number;
    items!: StoreBusinessHourStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreBusinessHourStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreBusinessHourStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreBusinessHourStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreBusinessHourStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreBusinessHourStoreLookupTableDto {
    totalCount: number;
    items: StoreBusinessHourStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreContactMapContactLookupTableDto implements IPagedResultDtoOfStoreContactMapContactLookupTableDto {
    totalCount!: number;
    items!: StoreContactMapContactLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreContactMapContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreContactMapContactLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreContactMapContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreContactMapContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreContactMapContactLookupTableDto {
    totalCount: number;
    items: StoreContactMapContactLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreContactMapStoreLookupTableDto implements IPagedResultDtoOfStoreContactMapStoreLookupTableDto {
    totalCount!: number;
    items!: StoreContactMapStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreContactMapStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreContactMapStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreContactMapStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreContactMapStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreContactMapStoreLookupTableDto {
    totalCount: number;
    items: StoreContactMapStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreLocationCityLookupTableDto implements IPagedResultDtoOfStoreLocationCityLookupTableDto {
    totalCount!: number;
    items!: StoreLocationCityLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreLocationCityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreLocationCityLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreLocationCityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreLocationCityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreLocationCityLookupTableDto {
    totalCount: number;
    items: StoreLocationCityLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreLocationCountryLookupTableDto implements IPagedResultDtoOfStoreLocationCountryLookupTableDto {
    totalCount!: number;
    items!: StoreLocationCountryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreLocationCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreLocationCountryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreLocationCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreLocationCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreLocationCountryLookupTableDto {
    totalCount: number;
    items: StoreLocationCountryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreLocationStateLookupTableDto implements IPagedResultDtoOfStoreLocationStateLookupTableDto {
    totalCount!: number;
    items!: StoreLocationStateLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreLocationStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreLocationStateLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreLocationStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreLocationStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreLocationStateLookupTableDto {
    totalCount: number;
    items: StoreLocationStateLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreLocationStoreLookupTableDto implements IPagedResultDtoOfStoreLocationStoreLookupTableDto {
    totalCount!: number;
    items!: StoreLocationStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreLocationStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreLocationStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreLocationStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreLocationStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreLocationStoreLookupTableDto {
    totalCount: number;
    items: StoreLocationStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto implements IPagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto {
    totalCount!: number;
    items!: StoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto {
    totalCount: number;
    items: StoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto implements IPagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto {
    totalCount!: number;
    items!: StoreMarketplaceCommissionSettingProductCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreMarketplaceCommissionSettingProductCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreMarketplaceCommissionSettingProductCategoryLookupTableDto {
    totalCount: number;
    items: StoreMarketplaceCommissionSettingProductCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto implements IPagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto {
    totalCount!: number;
    items!: StoreMarketplaceCommissionSettingProductLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreMarketplaceCommissionSettingProductLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreMarketplaceCommissionSettingProductLookupTableDto {
    totalCount: number;
    items: StoreMarketplaceCommissionSettingProductLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto implements IPagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto {
    totalCount!: number;
    items!: StoreMarketplaceCommissionSettingStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreMarketplaceCommissionSettingStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreMarketplaceCommissionSettingStoreLookupTableDto {
    totalCount: number;
    items: StoreMarketplaceCommissionSettingStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreMasterTagLookupTableDto implements IPagedResultDtoOfStoreMasterTagLookupTableDto {
    totalCount!: number;
    items!: StoreMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreMasterTagLookupTableDto {
    totalCount: number;
    items: StoreMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreMediaLibraryLookupTableDto implements IPagedResultDtoOfStoreMediaLibraryLookupTableDto {
    totalCount!: number;
    items!: StoreMediaLibraryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreMediaLibraryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreMediaLibraryLookupTableDto {
    totalCount: number;
    items: StoreMediaLibraryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreMediaMediaLibraryLookupTableDto implements IPagedResultDtoOfStoreMediaMediaLibraryLookupTableDto {
    totalCount!: number;
    items!: StoreMediaMediaLibraryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreMediaMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreMediaMediaLibraryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreMediaMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreMediaMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreMediaMediaLibraryLookupTableDto {
    totalCount: number;
    items: StoreMediaMediaLibraryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreMediaStoreLookupTableDto implements IPagedResultDtoOfStoreMediaStoreLookupTableDto {
    totalCount!: number;
    items!: StoreMediaStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreMediaStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreMediaStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreMediaStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreMediaStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreMediaStoreLookupTableDto {
    totalCount: number;
    items: StoreMediaStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreNoteStoreLookupTableDto implements IPagedResultDtoOfStoreNoteStoreLookupTableDto {
    totalCount!: number;
    items!: StoreNoteStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreNoteStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreNoteStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreNoteStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreNoteStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreNoteStoreLookupTableDto {
    totalCount: number;
    items: StoreNoteStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreOwnerTeamStoreLookupTableDto implements IPagedResultDtoOfStoreOwnerTeamStoreLookupTableDto {
    totalCount!: number;
    items!: StoreOwnerTeamStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreOwnerTeamStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreOwnerTeamStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreOwnerTeamStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreOwnerTeamStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreOwnerTeamStoreLookupTableDto {
    totalCount: number;
    items: StoreOwnerTeamStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreOwnerTeamUserLookupTableDto implements IPagedResultDtoOfStoreOwnerTeamUserLookupTableDto {
    totalCount!: number;
    items!: StoreOwnerTeamUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreOwnerTeamUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreOwnerTeamUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreOwnerTeamUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreOwnerTeamUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreOwnerTeamUserLookupTableDto {
    totalCount: number;
    items: StoreOwnerTeamUserLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto implements IPagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto {
    totalCount!: number;
    items!: StoreProductCategoryMapProductCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreProductCategoryMapProductCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreProductCategoryMapProductCategoryLookupTableDto {
    totalCount: number;
    items: StoreProductCategoryMapProductCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto implements IPagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto {
    totalCount!: number;
    items!: StoreProductCategoryMapStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreProductCategoryMapStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreProductCategoryMapStoreLookupTableDto {
    totalCount: number;
    items: StoreProductCategoryMapStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreProductMapProductLookupTableDto implements IPagedResultDtoOfStoreProductMapProductLookupTableDto {
    totalCount!: number;
    items!: StoreProductMapProductLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreProductMapProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreProductMapProductLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreProductMapProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreProductMapProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreProductMapProductLookupTableDto {
    totalCount: number;
    items: StoreProductMapProductLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreProductMapStoreLookupTableDto implements IPagedResultDtoOfStoreProductMapStoreLookupTableDto {
    totalCount!: number;
    items!: StoreProductMapStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreProductMapStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreProductMapStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreProductMapStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreProductMapStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreProductMapStoreLookupTableDto {
    totalCount: number;
    items: StoreProductMapStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreSalesAlertStoreLookupTableDto implements IPagedResultDtoOfStoreSalesAlertStoreLookupTableDto {
    totalCount!: number;
    items!: StoreSalesAlertStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreSalesAlertStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreSalesAlertStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreSalesAlertStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreSalesAlertStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreSalesAlertStoreLookupTableDto {
    totalCount: number;
    items: StoreSalesAlertStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto implements IPagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto {
    totalCount!: number;
    items!: StoreTagMasterTagCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreTagMasterTagCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreTagMasterTagCategoryLookupTableDto {
    totalCount: number;
    items: StoreTagMasterTagCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreTagMasterTagLookupTableDto implements IPagedResultDtoOfStoreTagMasterTagLookupTableDto {
    totalCount!: number;
    items!: StoreTagMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreTagMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreTagMasterTagLookupTableDto {
    totalCount: number;
    items: StoreTagMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreTagStoreLookupTableDto implements IPagedResultDtoOfStoreTagStoreLookupTableDto {
    totalCount!: number;
    items!: StoreTagStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreTagStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreTagStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreTagStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreTagStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreTagStoreLookupTableDto {
    totalCount: number;
    items: StoreTagStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfStoreTaxStoreLookupTableDto implements IPagedResultDtoOfStoreTaxStoreLookupTableDto {
    totalCount!: number;
    items!: StoreTaxStoreLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreTaxStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreTaxStoreLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreTaxStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreTaxStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfStoreTaxStoreLookupTableDto {
    totalCount: number;
    items: StoreTaxStoreLookupTableDto[] | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class PagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto implements IPagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto {
    totalCount!: number;
    items!: TaskTagMasterTagCategoryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TaskTagMasterTagCategoryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTaskTagMasterTagCategoryLookupTableDto {
    totalCount: number;
    items: TaskTagMasterTagCategoryLookupTableDto[] | undefined;
}

export class PagedResultDtoOfTaskTagMasterTagLookupTableDto implements IPagedResultDtoOfTaskTagMasterTagLookupTableDto {
    totalCount!: number;
    items!: TaskTagMasterTagLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTaskTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TaskTagMasterTagLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTaskTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTaskTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTaskTagMasterTagLookupTableDto {
    totalCount: number;
    items: TaskTagMasterTagLookupTableDto[] | undefined;
}

export class PagedResultDtoOfTaskTagTaskEventLookupTableDto implements IPagedResultDtoOfTaskTagTaskEventLookupTableDto {
    totalCount!: number;
    items!: TaskTagTaskEventLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTaskTagTaskEventLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TaskTagTaskEventLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTaskTagTaskEventLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTaskTagTaskEventLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTaskTagTaskEventLookupTableDto {
    totalCount: number;
    items: TaskTagTaskEventLookupTableDto[] | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;
}

export class PagedResultDtoOfUserDelegationDto implements IPagedResultDtoOfUserDelegationDto {
    totalCount!: number;
    items!: UserDelegationDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDelegationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserDelegationDto {
    totalCount: number;
    items: UserDelegationDto[] | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;
}

export class PagedResultDtoOfUserLoginAttemptDto implements IPagedResultDtoOfUserLoginAttemptDto {
    totalCount!: number;
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserLoginAttemptDto {
    totalCount: number;
    items: UserLoginAttemptDto[] | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    readonly allowedMinimumLength!: number;
    requireDigit!: boolean;
    requireLowercase!: boolean;
    requireNonAlphanumeric!: boolean;
    requireUppercase!: boolean;
    requiredLength!: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).allowedMinimumLength = _data["allowedMinimumLength"];
            this.requireDigit = _data["requireDigit"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireUppercase = _data["requireUppercase"];
            this.requiredLength = _data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowedMinimumLength"] = this.allowedMinimumLength;
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data;
    }
}

export interface IPasswordComplexitySetting {
    allowedMinimumLength: number;
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;
    disabledFundings!: string[] | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.demoUsername = _data["demoUsername"];
            this.demoPassword = _data["demoPassword"];
            if (Array.isArray(_data["disabledFundings"])) {
                this.disabledFundings = [] as any;
                for (let item of _data["disabledFundings"])
                    this.disabledFundings!.push(item);
            }
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        if (Array.isArray(this.disabledFundings)) {
            data["disabledFundings"] = [];
            for (let item of this.disabledFundings)
                data["disabledFundings"].push(item);
        }
        return data;
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
    disabledFundings: string[] | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType;
    supportsRecurringPayments!: boolean;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayType = _data["gatewayType"];
            this.supportsRecurringPayments = _data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data;
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType;
    supportsRecurringPayments: boolean;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto;
    additionalPrice!: number;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            this.additionalPrice = _data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data;
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;
}

export enum PaymentPeriodType {
    Daily = 1,
    Weekly = 7,
    Monthly = 30,
    Annual = 365,
}

export class ProductCategoryDto implements IProductCategoryDto {
    name!: string | undefined;
    description!: string | undefined;
    hasParentCategory!: boolean;
    parentCategoryId!: number | undefined;
    url!: string | undefined;
    metaTitle!: string | undefined;
    metaKeywords!: string | undefined;
    displaySequence!: number | undefined;
    productOrService!: boolean;
    mediaLibraryId!: number | undefined;
    id!: number;

    constructor(data?: IProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.hasParentCategory = _data["hasParentCategory"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.url = _data["url"];
            this.metaTitle = _data["metaTitle"];
            this.metaKeywords = _data["metaKeywords"];
            this.displaySequence = _data["displaySequence"];
            this.productOrService = _data["productOrService"];
            this.mediaLibraryId = _data["mediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["hasParentCategory"] = this.hasParentCategory;
        data["parentCategoryId"] = this.parentCategoryId;
        data["url"] = this.url;
        data["metaTitle"] = this.metaTitle;
        data["metaKeywords"] = this.metaKeywords;
        data["displaySequence"] = this.displaySequence;
        data["productOrService"] = this.productOrService;
        data["mediaLibraryId"] = this.mediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IProductCategoryDto {
    name: string | undefined;
    description: string | undefined;
    hasParentCategory: boolean;
    parentCategoryId: number | undefined;
    url: string | undefined;
    metaTitle: string | undefined;
    metaKeywords: string | undefined;
    displaySequence: number | undefined;
    productOrService: boolean;
    mediaLibraryId: number | undefined;
    id: number;
}

export class ProductCategoryMediaLibraryLookupTableDto implements IProductCategoryMediaLibraryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductCategoryMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ProductCategoryMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IProductCategoryMediaLibraryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ProductCurrencyLookupTableDto implements IProductCurrencyLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ProductCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IProductCurrencyLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ProductDto implements IProductDto {
    name!: string | undefined;
    shortDescription!: string | undefined;
    description!: string | undefined;
    sku!: string | undefined;
    url!: string | undefined;
    seoTitle!: string | undefined;
    metaKeywords!: string | undefined;
    metaDescription!: string | undefined;
    regularPrice!: number | undefined;
    salePrice!: number | undefined;
    priceDiscountPercentage!: number | undefined;
    callForPrice!: boolean;
    unitPrice!: number | undefined;
    measurementAmount!: number | undefined;
    isTaxExempt!: boolean;
    stockQuantity!: number | undefined;
    isDisplayStockQuantity!: boolean;
    isPublished!: boolean;
    isPackageProduct!: boolean;
    internalNotes!: string | undefined;
    isTemplate!: boolean;
    priceDiscountAmount!: number | undefined;
    isService!: boolean;
    isWholeSaleProduct!: boolean;
    productManufacturerSku!: string | undefined;
    byOrderOnly!: boolean;
    score!: number | undefined;
    productCategoryId!: number;
    mediaLibraryId!: number | undefined;
    measurementUnitId!: number | undefined;
    currencyId!: number | undefined;
    ratingLikeId!: number | undefined;
    id!: number;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.shortDescription = _data["shortDescription"];
            this.description = _data["description"];
            this.sku = _data["sku"];
            this.url = _data["url"];
            this.seoTitle = _data["seoTitle"];
            this.metaKeywords = _data["metaKeywords"];
            this.metaDescription = _data["metaDescription"];
            this.regularPrice = _data["regularPrice"];
            this.salePrice = _data["salePrice"];
            this.priceDiscountPercentage = _data["priceDiscountPercentage"];
            this.callForPrice = _data["callForPrice"];
            this.unitPrice = _data["unitPrice"];
            this.measurementAmount = _data["measurementAmount"];
            this.isTaxExempt = _data["isTaxExempt"];
            this.stockQuantity = _data["stockQuantity"];
            this.isDisplayStockQuantity = _data["isDisplayStockQuantity"];
            this.isPublished = _data["isPublished"];
            this.isPackageProduct = _data["isPackageProduct"];
            this.internalNotes = _data["internalNotes"];
            this.isTemplate = _data["isTemplate"];
            this.priceDiscountAmount = _data["priceDiscountAmount"];
            this.isService = _data["isService"];
            this.isWholeSaleProduct = _data["isWholeSaleProduct"];
            this.productManufacturerSku = _data["productManufacturerSku"];
            this.byOrderOnly = _data["byOrderOnly"];
            this.score = _data["score"];
            this.productCategoryId = _data["productCategoryId"];
            this.mediaLibraryId = _data["mediaLibraryId"];
            this.measurementUnitId = _data["measurementUnitId"];
            this.currencyId = _data["currencyId"];
            this.ratingLikeId = _data["ratingLikeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        data["sku"] = this.sku;
        data["url"] = this.url;
        data["seoTitle"] = this.seoTitle;
        data["metaKeywords"] = this.metaKeywords;
        data["metaDescription"] = this.metaDescription;
        data["regularPrice"] = this.regularPrice;
        data["salePrice"] = this.salePrice;
        data["priceDiscountPercentage"] = this.priceDiscountPercentage;
        data["callForPrice"] = this.callForPrice;
        data["unitPrice"] = this.unitPrice;
        data["measurementAmount"] = this.measurementAmount;
        data["isTaxExempt"] = this.isTaxExempt;
        data["stockQuantity"] = this.stockQuantity;
        data["isDisplayStockQuantity"] = this.isDisplayStockQuantity;
        data["isPublished"] = this.isPublished;
        data["isPackageProduct"] = this.isPackageProduct;
        data["internalNotes"] = this.internalNotes;
        data["isTemplate"] = this.isTemplate;
        data["priceDiscountAmount"] = this.priceDiscountAmount;
        data["isService"] = this.isService;
        data["isWholeSaleProduct"] = this.isWholeSaleProduct;
        data["productManufacturerSku"] = this.productManufacturerSku;
        data["byOrderOnly"] = this.byOrderOnly;
        data["score"] = this.score;
        data["productCategoryId"] = this.productCategoryId;
        data["mediaLibraryId"] = this.mediaLibraryId;
        data["measurementUnitId"] = this.measurementUnitId;
        data["currencyId"] = this.currencyId;
        data["ratingLikeId"] = this.ratingLikeId;
        data["id"] = this.id;
        return data;
    }
}

export interface IProductDto {
    name: string | undefined;
    shortDescription: string | undefined;
    description: string | undefined;
    sku: string | undefined;
    url: string | undefined;
    seoTitle: string | undefined;
    metaKeywords: string | undefined;
    metaDescription: string | undefined;
    regularPrice: number | undefined;
    salePrice: number | undefined;
    priceDiscountPercentage: number | undefined;
    callForPrice: boolean;
    unitPrice: number | undefined;
    measurementAmount: number | undefined;
    isTaxExempt: boolean;
    stockQuantity: number | undefined;
    isDisplayStockQuantity: boolean;
    isPublished: boolean;
    isPackageProduct: boolean;
    internalNotes: string | undefined;
    isTemplate: boolean;
    priceDiscountAmount: number | undefined;
    isService: boolean;
    isWholeSaleProduct: boolean;
    productManufacturerSku: string | undefined;
    byOrderOnly: boolean;
    score: number | undefined;
    productCategoryId: number;
    mediaLibraryId: number | undefined;
    measurementUnitId: number | undefined;
    currencyId: number | undefined;
    ratingLikeId: number | undefined;
    id: number;
}

export class ProductMeasurementUnitLookupTableDto implements IProductMeasurementUnitLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductMeasurementUnitLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ProductMeasurementUnitLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductMeasurementUnitLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IProductMeasurementUnitLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ProductMediaLibraryLookupTableDto implements IProductMediaLibraryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ProductMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IProductMediaLibraryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ProductProductCategoryLookupTableDto implements IProductProductCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductProductCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ProductProductCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductProductCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IProductProductCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ProductRatingLikeLookupTableDto implements IProductRatingLikeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductRatingLikeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ProductRatingLikeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductRatingLikeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IProductRatingLikeLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ProductTagDto implements IProductTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    productId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number;

    constructor(data?: IProductTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.productId = _data["productId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["productId"] = this.productId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface IProductTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    productId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number;
}

export class ProductTagMasterTagCategoryLookupTableDto implements IProductTagMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ProductTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IProductTagMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ProductTagMasterTagLookupTableDto implements IProductTagMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ProductTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IProductTagMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ProductTagProductLookupTableDto implements IProductTagProductLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IProductTagProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ProductTagProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTagProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IProductTagProductLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class RatingLikeDto implements IRatingLikeDto {
    name!: string | undefined;
    score!: number | undefined;
    iconLink!: string | undefined;
    id!: number;

    constructor(data?: IRatingLikeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.score = _data["score"];
            this.iconLink = _data["iconLink"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RatingLikeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RatingLikeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["score"] = this.score;
        data["iconLink"] = this.iconLink;
        data["id"] = this.id;
        return data;
    }
}

export interface IRatingLikeDto {
    name: string | undefined;
    score: number | undefined;
    iconLink: string | undefined;
    id: number;
}

export class RecentTenant implements IRecentTenant {
    id!: number;
    name!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IRecentTenant {
    id: number;
    name: string | undefined;
    creationTime: DateTime;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number;
    change!: number[] | undefined;
    averagePrice!: number;
    totalPrice!: number;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryName = _data["countryName"];
            this.sales = _data["sales"];
            if (Array.isArray(_data["change"])) {
                this.change = [] as any;
                for (let item of _data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = _data["averagePrice"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (Array.isArray(this.change)) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data;
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number;
    change: number[] | undefined;
    averagePrice: number;
    totalPrice: number;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminName!: string | undefined;
    adminSurname!: string | undefined;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminName = _data["adminName"];
            this.adminSurname = _data["adminSurname"];
            this.adminPassword = _data["adminPassword"];
            this.captchaResponse = _data["captchaResponse"];
            this.subscriptionStartType = _data["subscriptionStartType"];
            this.editionId = _data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminName"] = this.adminName;
        data["adminSurname"] = this.adminSurname;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data;
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminName: string | undefined;
    adminSurname: string | undefined;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean;
    isActive!: boolean;
    isEmailConfirmationRequired!: boolean;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.isTenantActive = _data["isTenantActive"];
            this.isActive = _data["isActive"];
            this.isEmailConfirmationRequired = _data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data;
    }
}

export interface IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;
}

export class RenamePageInput implements IRenamePageInput {
    dashboardName!: string | undefined;
    id!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IRenamePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): RenamePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["id"] = this.id;
        data["name"] = this.name;
        data["application"] = this.application;
        return data;
    }
}

export interface IRenamePageInput {
    dashboardName: string | undefined;
    id: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number;
    resetCode!: string | undefined;
    expireDate!: DateTime;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetCode = _data["resetCode"];
            this.expireDate = _data["expireDate"] ? DateTime.fromISO(_data["expireDate"].toString()) : <any>undefined;
            this.password = _data["password"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["expireDate"] = this.expireDate ? this.expireDate.toString() : <any>undefined;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data;
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    expireDate: DateTime;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: DateTime;
    id: number;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number;
    profit!: number;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.period = _data["period"];
            this.sales = _data["sales"];
            this.profit = _data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data;
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number;
    profit: number;
}

export enum SalesSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class SavePageInput implements ISavePageInput {
    dashboardName!: string | undefined;
    application!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: ISavePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.application = _data["application"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SavePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SavePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["application"] = this.application;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: Page[] | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean;
    useDefaultPasswordComplexitySettings!: boolean;
    passwordComplexity!: PasswordComplexitySetting;
    defaultPasswordComplexity!: PasswordComplexitySetting;
    userLockOut!: UserLockOutSettingsEditDto;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowOneConcurrentLoginPerUser = _data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = _data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = _data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(_data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = _data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(_data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = _data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(_data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class SendAndGetDateWithTextInput implements ISendAndGetDateWithTextInput {
    text!: string | undefined;
    date!: DateTime;

    constructor(data?: ISendAndGetDateWithTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SendAndGetDateWithTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendAndGetDateWithTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        return data;
    }
}

export interface ISendAndGetDateWithTextInput {
    text: string | undefined;
    date: DateTime;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.provider = _data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data;
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber!: string | undefined;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
    isEnabled!: boolean;
    timeOutSecond!: number;
    showTimeOutNotificationSecond!: number;
    showLockScreenWhenTimedOut!: boolean;

    constructor(data?: ISessionTimeOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.timeOutSecond = _data["timeOutSecond"];
            this.showTimeOutNotificationSecond = _data["showTimeOutNotificationSecond"];
            this.showLockScreenWhenTimedOut = _data["showLockScreenWhenTimedOut"];
        }
    }

    static fromJS(data: any): SessionTimeOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionTimeOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["timeOutSecond"] = this.timeOutSecond;
        data["showTimeOutNotificationSecond"] = this.showTimeOutNotificationSecond;
        data["showLockScreenWhenTimedOut"] = this.showLockScreenWhenTimedOut;
        return data;
    }
}

export interface ISessionTimeOutSettingsEditDto {
    isEnabled: boolean;
    timeOutSecond: number;
    showTimeOutNotificationSecond: number;
    showLockScreenWhenTimedOut: boolean;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class SetNotificationAsReadOutput implements ISetNotificationAsReadOutput {
    success!: boolean;

    constructor(data?: ISetNotificationAsReadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): SetNotificationAsReadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SetNotificationAsReadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        return data;
    }
}

export interface ISetNotificationAsReadOutput {
    success: boolean;
}

export enum SettingScopes {
    Application = 1,
    Tenant = 2,
    User = 4,
    All = 7,
}

export class SmsTemplateDto implements ISmsTemplateDto {
    title!: string | undefined;
    content!: string | undefined;
    published!: boolean;
    id!: number;

    constructor(data?: ISmsTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.content = _data["content"];
            this.published = _data["published"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SmsTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new SmsTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["content"] = this.content;
        data["published"] = this.published;
        data["id"] = this.id;
        return data;
    }
}

export interface ISmsTemplateDto {
    title: string | undefined;
    content: string | undefined;
    published: boolean;
    id: number;
}

export class StateCountryLookupTableDto implements IStateCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStateCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StateCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StateCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStateCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StateDto implements IStateDto {
    name!: string | undefined;
    ticker!: string | undefined;
    countryId!: number;
    id!: number;

    constructor(data?: IStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.ticker = _data["ticker"];
            this.countryId = _data["countryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StateDto {
        data = typeof data === 'object' ? data : {};
        let result = new StateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["ticker"] = this.ticker;
        data["countryId"] = this.countryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStateDto {
    name: string | undefined;
    ticker: string | undefined;
    countryId: number;
    id: number;
}

export class StoreAccountTeamDto implements IStoreAccountTeamDto {
    primary!: boolean;
    active!: boolean;
    orderEmailNotification!: boolean;
    orderSmsNotification!: boolean;
    storeId!: number;
    employeeId!: number;
    id!: number;

    constructor(data?: IStoreAccountTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.primary = _data["primary"];
            this.active = _data["active"];
            this.orderEmailNotification = _data["orderEmailNotification"];
            this.orderSmsNotification = _data["orderSmsNotification"];
            this.storeId = _data["storeId"];
            this.employeeId = _data["employeeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreAccountTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreAccountTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["primary"] = this.primary;
        data["active"] = this.active;
        data["orderEmailNotification"] = this.orderEmailNotification;
        data["orderSmsNotification"] = this.orderSmsNotification;
        data["storeId"] = this.storeId;
        data["employeeId"] = this.employeeId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreAccountTeamDto {
    primary: boolean;
    active: boolean;
    orderEmailNotification: boolean;
    orderSmsNotification: boolean;
    storeId: number;
    employeeId: number;
    id: number;
}

export class StoreAccountTeamEmployeeLookupTableDto implements IStoreAccountTeamEmployeeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreAccountTeamEmployeeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreAccountTeamEmployeeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreAccountTeamEmployeeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreAccountTeamEmployeeLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreAccountTeamStoreLookupTableDto implements IStoreAccountTeamStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreAccountTeamStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreAccountTeamStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreAccountTeamStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreAccountTeamStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreBankAccountDto implements IStoreBankAccountDto {
    accountName!: string | undefined;
    accountNo!: string | undefined;
    bankName!: string | undefined;
    routingNo!: string | undefined;
    bankAddress!: string | undefined;
    storeId!: number;
    id!: number;

    constructor(data?: IStoreBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountName = _data["accountName"];
            this.accountNo = _data["accountNo"];
            this.bankName = _data["bankName"];
            this.routingNo = _data["routingNo"];
            this.bankAddress = _data["bankAddress"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreBankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreBankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["accountNo"] = this.accountNo;
        data["bankName"] = this.bankName;
        data["routingNo"] = this.routingNo;
        data["bankAddress"] = this.bankAddress;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreBankAccountDto {
    accountName: string | undefined;
    accountNo: string | undefined;
    bankName: string | undefined;
    routingNo: string | undefined;
    bankAddress: string | undefined;
    storeId: number;
    id: number;
}

export class StoreBankAccountStoreLookupTableDto implements IStoreBankAccountStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreBankAccountStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreBankAccountStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreBankAccountStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreBankAccountStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreBusinessCustomerMapBusinessLookupTableDto implements IStoreBusinessCustomerMapBusinessLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreBusinessCustomerMapBusinessLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreBusinessCustomerMapBusinessLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreBusinessCustomerMapBusinessLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreBusinessCustomerMapBusinessLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreBusinessCustomerMapDto implements IStoreBusinessCustomerMapDto {
    paidCustomer!: boolean;
    lifeTimeSalesAmount!: number | undefined;
    storeId!: number;
    businessId!: number;
    id!: number;

    constructor(data?: IStoreBusinessCustomerMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paidCustomer = _data["paidCustomer"];
            this.lifeTimeSalesAmount = _data["lifeTimeSalesAmount"];
            this.storeId = _data["storeId"];
            this.businessId = _data["businessId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreBusinessCustomerMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreBusinessCustomerMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paidCustomer"] = this.paidCustomer;
        data["lifeTimeSalesAmount"] = this.lifeTimeSalesAmount;
        data["storeId"] = this.storeId;
        data["businessId"] = this.businessId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreBusinessCustomerMapDto {
    paidCustomer: boolean;
    lifeTimeSalesAmount: number | undefined;
    storeId: number;
    businessId: number;
    id: number;
}

export class StoreBusinessCustomerMapStoreLookupTableDto implements IStoreBusinessCustomerMapStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreBusinessCustomerMapStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreBusinessCustomerMapStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreBusinessCustomerMapStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreBusinessCustomerMapStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreBusinessHourDto implements IStoreBusinessHourDto {
    nowOpenOrClosed!: boolean;
    isOpen24Hours!: boolean;
    mondayStartTime!: string | undefined;
    mondayEndTime!: string | undefined;
    tuesdayStartTime!: string | undefined;
    tuesdayEndTime!: string | undefined;
    wednesdayStartTime!: string | undefined;
    wednesdayEndTime!: string | undefined;
    thursdayStartTime!: string | undefined;
    thursdayEndTime!: string | undefined;
    fridayStartTime!: string | undefined;
    fridayEndTime!: string | undefined;
    saturdayStartTime!: string | undefined;
    saturdayEndTime!: string | undefined;
    sundayStartTime!: string | undefined;
    sundayEndTime!: string | undefined;
    isAcceptOnlyBusinessHour!: boolean;
    storeId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number;

    constructor(data?: IStoreBusinessHourDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nowOpenOrClosed = _data["nowOpenOrClosed"];
            this.isOpen24Hours = _data["isOpen24Hours"];
            this.mondayStartTime = _data["mondayStartTime"];
            this.mondayEndTime = _data["mondayEndTime"];
            this.tuesdayStartTime = _data["tuesdayStartTime"];
            this.tuesdayEndTime = _data["tuesdayEndTime"];
            this.wednesdayStartTime = _data["wednesdayStartTime"];
            this.wednesdayEndTime = _data["wednesdayEndTime"];
            this.thursdayStartTime = _data["thursdayStartTime"];
            this.thursdayEndTime = _data["thursdayEndTime"];
            this.fridayStartTime = _data["fridayStartTime"];
            this.fridayEndTime = _data["fridayEndTime"];
            this.saturdayStartTime = _data["saturdayStartTime"];
            this.saturdayEndTime = _data["saturdayEndTime"];
            this.sundayStartTime = _data["sundayStartTime"];
            this.sundayEndTime = _data["sundayEndTime"];
            this.isAcceptOnlyBusinessHour = _data["isAcceptOnlyBusinessHour"];
            this.storeId = _data["storeId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreBusinessHourDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreBusinessHourDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nowOpenOrClosed"] = this.nowOpenOrClosed;
        data["isOpen24Hours"] = this.isOpen24Hours;
        data["mondayStartTime"] = this.mondayStartTime;
        data["mondayEndTime"] = this.mondayEndTime;
        data["tuesdayStartTime"] = this.tuesdayStartTime;
        data["tuesdayEndTime"] = this.tuesdayEndTime;
        data["wednesdayStartTime"] = this.wednesdayStartTime;
        data["wednesdayEndTime"] = this.wednesdayEndTime;
        data["thursdayStartTime"] = this.thursdayStartTime;
        data["thursdayEndTime"] = this.thursdayEndTime;
        data["fridayStartTime"] = this.fridayStartTime;
        data["fridayEndTime"] = this.fridayEndTime;
        data["saturdayStartTime"] = this.saturdayStartTime;
        data["saturdayEndTime"] = this.saturdayEndTime;
        data["sundayStartTime"] = this.sundayStartTime;
        data["sundayEndTime"] = this.sundayEndTime;
        data["isAcceptOnlyBusinessHour"] = this.isAcceptOnlyBusinessHour;
        data["storeId"] = this.storeId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreBusinessHourDto {
    nowOpenOrClosed: boolean;
    isOpen24Hours: boolean;
    mondayStartTime: string | undefined;
    mondayEndTime: string | undefined;
    tuesdayStartTime: string | undefined;
    tuesdayEndTime: string | undefined;
    wednesdayStartTime: string | undefined;
    wednesdayEndTime: string | undefined;
    thursdayStartTime: string | undefined;
    thursdayEndTime: string | undefined;
    fridayStartTime: string | undefined;
    fridayEndTime: string | undefined;
    saturdayStartTime: string | undefined;
    saturdayEndTime: string | undefined;
    sundayStartTime: string | undefined;
    sundayEndTime: string | undefined;
    isAcceptOnlyBusinessHour: boolean;
    storeId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number;
}

export class StoreBusinessHourMasterTagCategoryLookupTableDto implements IStoreBusinessHourMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreBusinessHourMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreBusinessHourMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreBusinessHourMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreBusinessHourMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreBusinessHourMasterTagLookupTableDto implements IStoreBusinessHourMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreBusinessHourMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreBusinessHourMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreBusinessHourMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreBusinessHourMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreBusinessHourStoreLookupTableDto implements IStoreBusinessHourStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreBusinessHourStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreBusinessHourStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreBusinessHourStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreBusinessHourStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreContactMapContactLookupTableDto implements IStoreContactMapContactLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreContactMapContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreContactMapContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreContactMapContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreContactMapContactLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreContactMapDto implements IStoreContactMapDto {
    paidCustomer!: boolean;
    lifeTimeSalesAmount!: number | undefined;
    storeId!: number;
    contactId!: number;
    id!: number;

    constructor(data?: IStoreContactMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paidCustomer = _data["paidCustomer"];
            this.lifeTimeSalesAmount = _data["lifeTimeSalesAmount"];
            this.storeId = _data["storeId"];
            this.contactId = _data["contactId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreContactMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreContactMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paidCustomer"] = this.paidCustomer;
        data["lifeTimeSalesAmount"] = this.lifeTimeSalesAmount;
        data["storeId"] = this.storeId;
        data["contactId"] = this.contactId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreContactMapDto {
    paidCustomer: boolean;
    lifeTimeSalesAmount: number | undefined;
    storeId: number;
    contactId: number;
    id: number;
}

export class StoreContactMapStoreLookupTableDto implements IStoreContactMapStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreContactMapStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreContactMapStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreContactMapStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreContactMapStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreCountryLookupTableDto implements IStoreCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreDto implements IStoreDto {
    name!: string | undefined;
    storeUrl!: string | undefined;
    description!: string | undefined;
    metaTag!: string | undefined;
    metaDescription!: string | undefined;
    fullAddress!: string | undefined;
    address!: string | undefined;
    city!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    phone!: string | undefined;
    mobile!: string | undefined;
    email!: string | undefined;
    isPublished!: boolean;
    facebook!: string | undefined;
    instagram!: string | undefined;
    linkedIn!: string | undefined;
    youtube!: string | undefined;
    fax!: string | undefined;
    zipCode!: string | undefined;
    website!: string | undefined;
    yearOfEstablishment!: string | undefined;
    displaySequence!: number | undefined;
    score!: number | undefined;
    legalName!: string | undefined;
    isLocalOrOnlineStore!: boolean;
    isVerified!: boolean;
    logoMediaLibraryId!: number | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    ratingLikeId!: number | undefined;
    storeCategoryId!: number | undefined;
    id!: number;

    constructor(data?: IStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.storeUrl = _data["storeUrl"];
            this.description = _data["description"];
            this.metaTag = _data["metaTag"];
            this.metaDescription = _data["metaDescription"];
            this.fullAddress = _data["fullAddress"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.phone = _data["phone"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
            this.isPublished = _data["isPublished"];
            this.facebook = _data["facebook"];
            this.instagram = _data["instagram"];
            this.linkedIn = _data["linkedIn"];
            this.youtube = _data["youtube"];
            this.fax = _data["fax"];
            this.zipCode = _data["zipCode"];
            this.website = _data["website"];
            this.yearOfEstablishment = _data["yearOfEstablishment"];
            this.displaySequence = _data["displaySequence"];
            this.score = _data["score"];
            this.legalName = _data["legalName"];
            this.isLocalOrOnlineStore = _data["isLocalOrOnlineStore"];
            this.isVerified = _data["isVerified"];
            this.logoMediaLibraryId = _data["logoMediaLibraryId"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.ratingLikeId = _data["ratingLikeId"];
            this.storeCategoryId = _data["storeCategoryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["storeUrl"] = this.storeUrl;
        data["description"] = this.description;
        data["metaTag"] = this.metaTag;
        data["metaDescription"] = this.metaDescription;
        data["fullAddress"] = this.fullAddress;
        data["address"] = this.address;
        data["city"] = this.city;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["phone"] = this.phone;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["isPublished"] = this.isPublished;
        data["facebook"] = this.facebook;
        data["instagram"] = this.instagram;
        data["linkedIn"] = this.linkedIn;
        data["youtube"] = this.youtube;
        data["fax"] = this.fax;
        data["zipCode"] = this.zipCode;
        data["website"] = this.website;
        data["yearOfEstablishment"] = this.yearOfEstablishment;
        data["displaySequence"] = this.displaySequence;
        data["score"] = this.score;
        data["legalName"] = this.legalName;
        data["isLocalOrOnlineStore"] = this.isLocalOrOnlineStore;
        data["isVerified"] = this.isVerified;
        data["logoMediaLibraryId"] = this.logoMediaLibraryId;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["ratingLikeId"] = this.ratingLikeId;
        data["storeCategoryId"] = this.storeCategoryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreDto {
    name: string | undefined;
    storeUrl: string | undefined;
    description: string | undefined;
    metaTag: string | undefined;
    metaDescription: string | undefined;
    fullAddress: string | undefined;
    address: string | undefined;
    city: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    phone: string | undefined;
    mobile: string | undefined;
    email: string | undefined;
    isPublished: boolean;
    facebook: string | undefined;
    instagram: string | undefined;
    linkedIn: string | undefined;
    youtube: string | undefined;
    fax: string | undefined;
    zipCode: string | undefined;
    website: string | undefined;
    yearOfEstablishment: string | undefined;
    displaySequence: number | undefined;
    score: number | undefined;
    legalName: string | undefined;
    isLocalOrOnlineStore: boolean;
    isVerified: boolean;
    logoMediaLibraryId: number | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    ratingLikeId: number | undefined;
    storeCategoryId: number | undefined;
    id: number;
}

export class StoreLocationCityLookupTableDto implements IStoreLocationCityLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreLocationCityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreLocationCityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreLocationCityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreLocationCityLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreLocationCountryLookupTableDto implements IStoreLocationCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreLocationCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreLocationCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreLocationCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreLocationCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreLocationDto implements IStoreLocationDto {
    locationName!: string | undefined;
    fullAddress!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    address!: string | undefined;
    mobile!: string | undefined;
    email!: string | undefined;
    zipCode!: string | undefined;
    cityId!: number | undefined;
    stateId!: number | undefined;
    countryId!: number | undefined;
    storeId!: number;
    id!: number;

    constructor(data?: IStoreLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationName = _data["locationName"];
            this.fullAddress = _data["fullAddress"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.address = _data["address"];
            this.mobile = _data["mobile"];
            this.email = _data["email"];
            this.zipCode = _data["zipCode"];
            this.cityId = _data["cityId"];
            this.stateId = _data["stateId"];
            this.countryId = _data["countryId"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationName"] = this.locationName;
        data["fullAddress"] = this.fullAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["address"] = this.address;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        data["zipCode"] = this.zipCode;
        data["cityId"] = this.cityId;
        data["stateId"] = this.stateId;
        data["countryId"] = this.countryId;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreLocationDto {
    locationName: string | undefined;
    fullAddress: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    address: string | undefined;
    mobile: string | undefined;
    email: string | undefined;
    zipCode: string | undefined;
    cityId: number | undefined;
    stateId: number | undefined;
    countryId: number | undefined;
    storeId: number;
    id: number;
}

export class StoreLocationStateLookupTableDto implements IStoreLocationStateLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreLocationStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreLocationStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreLocationStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreLocationStateLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreLocationStoreLookupTableDto implements IStoreLocationStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreLocationStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreLocationStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreLocationStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreLocationStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreMarketplaceCommissionSettingDto implements IStoreMarketplaceCommissionSettingDto {
    percentage!: number | undefined;
    fixedAmount!: number | undefined;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;
    storeId!: number;
    marketplaceCommissionTypeId!: number | undefined;
    productCategoryId!: number | undefined;
    productId!: number | undefined;
    id!: number;

    constructor(data?: IStoreMarketplaceCommissionSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.percentage = _data["percentage"];
            this.fixedAmount = _data["fixedAmount"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.storeId = _data["storeId"];
            this.marketplaceCommissionTypeId = _data["marketplaceCommissionTypeId"];
            this.productCategoryId = _data["productCategoryId"];
            this.productId = _data["productId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreMarketplaceCommissionSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreMarketplaceCommissionSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["percentage"] = this.percentage;
        data["fixedAmount"] = this.fixedAmount;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["storeId"] = this.storeId;
        data["marketplaceCommissionTypeId"] = this.marketplaceCommissionTypeId;
        data["productCategoryId"] = this.productCategoryId;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreMarketplaceCommissionSettingDto {
    percentage: number | undefined;
    fixedAmount: number | undefined;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
    storeId: number;
    marketplaceCommissionTypeId: number | undefined;
    productCategoryId: number | undefined;
    productId: number | undefined;
    id: number;
}

export class StoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto implements IStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreMarketplaceCommissionSettingMarketplaceCommissionTypeLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreMarketplaceCommissionSettingProductCategoryLookupTableDto implements IStoreMarketplaceCommissionSettingProductCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreMarketplaceCommissionSettingProductCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreMarketplaceCommissionSettingProductCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreMarketplaceCommissionSettingProductCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreMarketplaceCommissionSettingProductCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreMarketplaceCommissionSettingProductLookupTableDto implements IStoreMarketplaceCommissionSettingProductLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreMarketplaceCommissionSettingProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreMarketplaceCommissionSettingProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreMarketplaceCommissionSettingProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreMarketplaceCommissionSettingProductLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreMarketplaceCommissionSettingStoreLookupTableDto implements IStoreMarketplaceCommissionSettingStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreMarketplaceCommissionSettingStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreMarketplaceCommissionSettingStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreMarketplaceCommissionSettingStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreMarketplaceCommissionSettingStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreMasterTagLookupTableDto implements IStoreMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreMediaDto implements IStoreMediaDto {
    displaySequence!: number | undefined;
    storeId!: number;
    mediaLibraryId!: number;
    id!: number;

    constructor(data?: IStoreMediaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displaySequence = _data["displaySequence"];
            this.storeId = _data["storeId"];
            this.mediaLibraryId = _data["mediaLibraryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreMediaDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreMediaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displaySequence"] = this.displaySequence;
        data["storeId"] = this.storeId;
        data["mediaLibraryId"] = this.mediaLibraryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreMediaDto {
    displaySequence: number | undefined;
    storeId: number;
    mediaLibraryId: number;
    id: number;
}

export class StoreMediaLibraryLookupTableDto implements IStoreMediaLibraryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreMediaLibraryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreMediaMediaLibraryLookupTableDto implements IStoreMediaMediaLibraryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreMediaMediaLibraryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreMediaMediaLibraryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreMediaMediaLibraryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreMediaMediaLibraryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreMediaStoreLookupTableDto implements IStoreMediaStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreMediaStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreMediaStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreMediaStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreMediaStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreNoteDto implements IStoreNoteDto {
    notes!: string | undefined;
    storeId!: number;
    id!: number;

    constructor(data?: IStoreNoteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notes = _data["notes"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreNoteDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreNoteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notes"] = this.notes;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreNoteDto {
    notes: string | undefined;
    storeId: number;
    id: number;
}

export class StoreNoteStoreLookupTableDto implements IStoreNoteStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreNoteStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreNoteStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreNoteStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreNoteStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreOwnerTeamDto implements IStoreOwnerTeamDto {
    active!: boolean;
    primary!: boolean;
    orderEmailNotification!: boolean;
    orderSmsNotification!: boolean;
    storeId!: number;
    userId!: number;
    id!: number;

    constructor(data?: IStoreOwnerTeamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.primary = _data["primary"];
            this.orderEmailNotification = _data["orderEmailNotification"];
            this.orderSmsNotification = _data["orderSmsNotification"];
            this.storeId = _data["storeId"];
            this.userId = _data["userId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreOwnerTeamDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreOwnerTeamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["primary"] = this.primary;
        data["orderEmailNotification"] = this.orderEmailNotification;
        data["orderSmsNotification"] = this.orderSmsNotification;
        data["storeId"] = this.storeId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreOwnerTeamDto {
    active: boolean;
    primary: boolean;
    orderEmailNotification: boolean;
    orderSmsNotification: boolean;
    storeId: number;
    userId: number;
    id: number;
}

export class StoreOwnerTeamStoreLookupTableDto implements IStoreOwnerTeamStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreOwnerTeamStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreOwnerTeamStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreOwnerTeamStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreOwnerTeamStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreOwnerTeamUserLookupTableDto implements IStoreOwnerTeamUserLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreOwnerTeamUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreOwnerTeamUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreOwnerTeamUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreOwnerTeamUserLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreProductCategoryMapDto implements IStoreProductCategoryMapDto {
    published!: boolean;
    displaySequence!: number | undefined;
    storeId!: number;
    productCategoryId!: number;
    id!: number;

    constructor(data?: IStoreProductCategoryMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.published = _data["published"];
            this.displaySequence = _data["displaySequence"];
            this.storeId = _data["storeId"];
            this.productCategoryId = _data["productCategoryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreProductCategoryMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreProductCategoryMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        data["displaySequence"] = this.displaySequence;
        data["storeId"] = this.storeId;
        data["productCategoryId"] = this.productCategoryId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreProductCategoryMapDto {
    published: boolean;
    displaySequence: number | undefined;
    storeId: number;
    productCategoryId: number;
    id: number;
}

export class StoreProductCategoryMapProductCategoryLookupTableDto implements IStoreProductCategoryMapProductCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreProductCategoryMapProductCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreProductCategoryMapProductCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreProductCategoryMapProductCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreProductCategoryMapProductCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreProductCategoryMapStoreLookupTableDto implements IStoreProductCategoryMapStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreProductCategoryMapStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreProductCategoryMapStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreProductCategoryMapStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreProductCategoryMapStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreProductMapDto implements IStoreProductMapDto {
    published!: boolean;
    displaySequence!: number | undefined;
    storeId!: number;
    productId!: number;
    id!: number;

    constructor(data?: IStoreProductMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.published = _data["published"];
            this.displaySequence = _data["displaySequence"];
            this.storeId = _data["storeId"];
            this.productId = _data["productId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreProductMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreProductMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["published"] = this.published;
        data["displaySequence"] = this.displaySequence;
        data["storeId"] = this.storeId;
        data["productId"] = this.productId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreProductMapDto {
    published: boolean;
    displaySequence: number | undefined;
    storeId: number;
    productId: number;
    id: number;
}

export class StoreProductMapProductLookupTableDto implements IStoreProductMapProductLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreProductMapProductLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreProductMapProductLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreProductMapProductLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreProductMapProductLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreProductMapStoreLookupTableDto implements IStoreProductMapStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreProductMapStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreProductMapStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreProductMapStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreProductMapStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreRatingLikeLookupTableDto implements IStoreRatingLikeLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreRatingLikeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreRatingLikeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreRatingLikeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreRatingLikeLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreSalesAlertDto implements IStoreSalesAlertDto {
    message!: string | undefined;
    current!: boolean;
    startDate!: DateTime | undefined;
    endDate!: DateTime | undefined;
    storeId!: number;
    id!: number;

    constructor(data?: IStoreSalesAlertDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.current = _data["current"];
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreSalesAlertDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreSalesAlertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["current"] = this.current;
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreSalesAlertDto {
    message: string | undefined;
    current: boolean;
    startDate: DateTime | undefined;
    endDate: DateTime | undefined;
    storeId: number;
    id: number;
}

export class StoreSalesAlertStoreLookupTableDto implements IStoreSalesAlertStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreSalesAlertStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreSalesAlertStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreSalesAlertStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreSalesAlertStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreStateLookupTableDto implements IStoreStateLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreStateLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreTagDto implements IStoreTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verified!: boolean;
    sequence!: number | undefined;
    storeId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number;

    constructor(data?: IStoreTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verified = _data["verified"];
            this.sequence = _data["sequence"];
            this.storeId = _data["storeId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verified"] = this.verified;
        data["sequence"] = this.sequence;
        data["storeId"] = this.storeId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verified: boolean;
    sequence: number | undefined;
    storeId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number;
}

export class StoreTagMasterTagCategoryLookupTableDto implements IStoreTagMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreTagMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreTagMasterTagLookupTableDto implements IStoreTagMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreTagMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreTagStoreLookupTableDto implements IStoreTagStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreTagStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreTagStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreTagStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreTagStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StoreTaxDto implements IStoreTaxDto {
    taxName!: string | undefined;
    percentageOrAmount!: boolean;
    taxRatePercentage!: number | undefined;
    taxAmount!: number | undefined;
    storeId!: number;
    id!: number;

    constructor(data?: IStoreTaxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taxName = _data["taxName"];
            this.percentageOrAmount = _data["percentageOrAmount"];
            this.taxRatePercentage = _data["taxRatePercentage"];
            this.taxAmount = _data["taxAmount"];
            this.storeId = _data["storeId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreTaxDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreTaxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxName"] = this.taxName;
        data["percentageOrAmount"] = this.percentageOrAmount;
        data["taxRatePercentage"] = this.taxRatePercentage;
        data["taxAmount"] = this.taxAmount;
        data["storeId"] = this.storeId;
        data["id"] = this.id;
        return data;
    }
}

export interface IStoreTaxDto {
    taxName: string | undefined;
    percentageOrAmount: boolean;
    taxRatePercentage: number | undefined;
    taxAmount: number | undefined;
    storeId: number;
    id: number;
}

export class StoreTaxStoreLookupTableDto implements IStoreTaxStoreLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IStoreTaxStoreLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): StoreTaxStoreLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreTaxStoreLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IStoreTaxStoreLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data;
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publishableKey = _data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data;
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class StripeCreatePaymentSessionInput implements IStripeCreatePaymentSessionInput {
    paymentId!: number;
    successUrl!: string | undefined;
    cancelUrl!: string | undefined;

    constructor(data?: IStripeCreatePaymentSessionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.successUrl = _data["successUrl"];
            this.cancelUrl = _data["cancelUrl"];
        }
    }

    static fromJS(data: any): StripeCreatePaymentSessionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreatePaymentSessionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["successUrl"] = this.successUrl;
        data["cancelUrl"] = this.cancelUrl;
        return data;
    }
}

export interface IStripeCreatePaymentSessionInput {
    paymentId: number;
    successUrl: string | undefined;
    cancelUrl: string | undefined;
}

export class StripePaymentResultOutput implements IStripePaymentResultOutput {
    paymentDone!: boolean;

    constructor(data?: IStripePaymentResultOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentDone = _data["paymentDone"];
        }
    }

    static fromJS(data: any): StripePaymentResultOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StripePaymentResultOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentDone"] = this.paymentDone;
        return data;
    }
}

export interface IStripePaymentResultOutput {
    paymentDone: boolean;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isFree = _data["isFree"];
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;
    amount!: number;
    editionId!: number;
    tenantId!: number;
    dayCount!: number;
    paymentPeriodType!: PaymentPeriodType;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number;
    status!: SubscriptionPaymentStatus;
    isRecurring!: boolean;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    editionPaymentType!: EditionPaymentType;
    id!: number;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.tenantId = _data["tenantId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.paymentId = _data["paymentId"];
            this.payerId = _data["payerId"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.status = _data["status"];
            this.isRecurring = _data["isRecurring"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["editionPaymentType"] = this.editionPaymentType;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
    amount: number;
    editionId: number;
    tenantId: number;
    dayCount: number;
    paymentPeriodType: PaymentPeriodType;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number;
    status: SubscriptionPaymentStatus;
    isRecurring: boolean;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    editionPaymentType: EditionPaymentType;
    id: number;
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1,
    Stripe = 2,
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number;
    editionId!: number;
    dayCount!: number;
    paymentPeriodType!: string | undefined;
    externalPaymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number;
    invoiceNo!: string | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.payerId = _data["payerId"];
            this.status = _data["status"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.tenantId = _data["tenantId"];
            this.invoiceNo = _data["invoiceNo"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["externalPaymentId"] = this.externalPaymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string | undefined;
    externalPaymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1,
    Paid = 2,
    Failed = 3,
    Cancelled = 4,
    Completed = 5,
}

export enum SubscriptionPaymentType {
    Manual = 0,
    RecurringAutomatic = 1,
    RecurringManual = 2,
}

export enum SubscriptionStartType {
    Free = 1,
    Trial = 2,
    Paid = 3,
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetTenantId = _data["targetTenantId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchAccountToken = _data["switchAccountToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class TaskEventDto implements ITaskEventDto {
    name!: string | undefined;
    description!: string | undefined;
    status!: boolean;
    priority!: boolean;
    eventDate!: DateTime | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    template!: boolean;
    actualTime!: string | undefined;
    endDate!: DateTime | undefined;
    estimatedTime!: string | undefined;
    hourAndMinutes!: string | undefined;
    taskStatusId!: number | undefined;
    id!: number;

    constructor(data?: ITaskEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.priority = _data["priority"];
            this.eventDate = _data["eventDate"] ? DateTime.fromISO(_data["eventDate"].toString()) : <any>undefined;
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.template = _data["template"];
            this.actualTime = _data["actualTime"];
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
            this.estimatedTime = _data["estimatedTime"];
            this.hourAndMinutes = _data["hourAndMinutes"];
            this.taskStatusId = _data["taskStatusId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaskEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["status"] = this.status;
        data["priority"] = this.priority;
        data["eventDate"] = this.eventDate ? this.eventDate.toString() : <any>undefined;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["template"] = this.template;
        data["actualTime"] = this.actualTime;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        data["estimatedTime"] = this.estimatedTime;
        data["hourAndMinutes"] = this.hourAndMinutes;
        data["taskStatusId"] = this.taskStatusId;
        data["id"] = this.id;
        return data;
    }
}

export interface ITaskEventDto {
    name: string | undefined;
    description: string | undefined;
    status: boolean;
    priority: boolean;
    eventDate: DateTime | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    template: boolean;
    actualTime: string | undefined;
    endDate: DateTime | undefined;
    estimatedTime: string | undefined;
    hourAndMinutes: string | undefined;
    taskStatusId: number | undefined;
    id: number;
}

export class TaskEventTaskStatusLookupTableDto implements ITaskEventTaskStatusLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITaskEventTaskStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): TaskEventTaskStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskEventTaskStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITaskEventTaskStatusLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class TaskStatusDto implements ITaskStatusDto {
    name!: string | undefined;
    id!: number;

    constructor(data?: ITaskStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaskStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }
}

export interface ITaskStatusDto {
    name: string | undefined;
    id: number;
}

export class TaskTagDto implements ITaskTagDto {
    customTag!: string | undefined;
    tagValue!: string | undefined;
    verfied!: boolean;
    sequence!: number | undefined;
    taskEventId!: number;
    masterTagCategoryId!: number | undefined;
    masterTagId!: number | undefined;
    id!: number;

    constructor(data?: ITaskTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customTag = _data["customTag"];
            this.tagValue = _data["tagValue"];
            this.verfied = _data["verfied"];
            this.sequence = _data["sequence"];
            this.taskEventId = _data["taskEventId"];
            this.masterTagCategoryId = _data["masterTagCategoryId"];
            this.masterTagId = _data["masterTagId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaskTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customTag"] = this.customTag;
        data["tagValue"] = this.tagValue;
        data["verfied"] = this.verfied;
        data["sequence"] = this.sequence;
        data["taskEventId"] = this.taskEventId;
        data["masterTagCategoryId"] = this.masterTagCategoryId;
        data["masterTagId"] = this.masterTagId;
        data["id"] = this.id;
        return data;
    }
}

export interface ITaskTagDto {
    customTag: string | undefined;
    tagValue: string | undefined;
    verfied: boolean;
    sequence: number | undefined;
    taskEventId: number;
    masterTagCategoryId: number | undefined;
    masterTagId: number | undefined;
    id: number;
}

export class TaskTagMasterTagCategoryLookupTableDto implements ITaskTagMasterTagCategoryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITaskTagMasterTagCategoryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): TaskTagMasterTagCategoryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskTagMasterTagCategoryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITaskTagMasterTagCategoryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class TaskTagMasterTagLookupTableDto implements ITaskTagMasterTagLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITaskTagMasterTagLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): TaskTagMasterTagLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskTagMasterTagLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITaskTagMasterTagLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class TaskTagTaskEventLookupTableDto implements ITaskTagTaskEventLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITaskTagTaskEventLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): TaskTagTaskEventLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaskTagTaskEventLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITaskTagTaskEventLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
            this.taxVatNo = _data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.connectionString = _data["connectionString"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useHostDefaultEmailSettings = _data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    subscriptionEndDateUtc!: DateTime | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = _data["editionId"];
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: DateTime;
    subscriptionEndDateUtc: DateTime | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    darkLogoId!: string | undefined;
    darkLogoFileType!: string | undefined;
    lightLogoId!: string | undefined;
    lightLogoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;
    subscriptionPaymentType!: SubscriptionPaymentType;
    edition!: EditionInfoDto;
    featureValues!: NameValueDto[] | undefined;
    creationTime!: DateTime;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.darkLogoId = _data["darkLogoId"];
            this.darkLogoFileType = _data["darkLogoFileType"];
            this.lightLogoId = _data["lightLogoId"];
            this.lightLogoFileType = _data["lightLogoFileType"];
            this.customCssId = _data["customCssId"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.subscriptionPaymentType = _data["subscriptionPaymentType"];
            this.edition = _data["edition"] ? EditionInfoDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionDateString = _data["subscriptionDateString"];
            this.creationTimeString = _data["creationTimeString"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["darkLogoId"] = this.darkLogoId;
        data["darkLogoFileType"] = this.darkLogoFileType;
        data["lightLogoId"] = this.lightLogoId;
        data["lightLogoFileType"] = this.lightLogoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    darkLogoId: string | undefined;
    darkLogoFileType: string | undefined;
    lightLogoId: string | undefined;
    lightLogoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
    subscriptionPaymentType: SubscriptionPaymentType;
    edition: EditionInfoDto;
    featureValues: NameValueDto[] | undefined;
    creationTime: DateTime;
    paymentPeriodType: PaymentPeriodType;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredTenantActiveByDefault!: boolean;
    useCaptchaOnRegistration!: boolean;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = _data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.defaultEditionId = _data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity;
    creationTime!: DateTime;
    id!: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.notificationName = _data["notificationName"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            this.entityType = _data["entityType"];
            this.entityTypeName = _data["entityTypeName"];
            this.entityId = _data["entityId"];
            this.severity = _data["severity"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity;
    creationTime: DateTime;
    id: string;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto;
    ldap!: LdapSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto;
    otherSettings!: TenantOtherSettingsEditDto;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : <any>undefined;
            this.userManagement = _data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = _data["email"] ? TenantEmailSettingsEditDto.fromJS(_data["email"]) : <any>undefined;
            this.ldap = _data["ldap"] ? LdapSettingsEditDto.fromJS(_data["ldap"]) : <any>undefined;
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? TenantBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
    otherSettings: TenantOtherSettingsEditDto;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredUserActiveByDefault!: boolean;
    isEmailConfirmationRequiredForLogin!: boolean;
    useCaptchaOnRegistration!: boolean;
    useCaptchaOnLogin!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = _data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
    useCaptchaOnLogin: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedFooter = _data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data;
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    readonly desktopFixedHeader!: boolean;
    readonly mobileFixedHeader!: boolean;
    minimizeDesktopHeaderType!: string | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).desktopFixedHeader = _data["desktopFixedHeader"];
            (<any>this).mobileFixedHeader = _data["mobileFixedHeader"];
            this.minimizeDesktopHeaderType = _data["minimizeDesktopHeaderType"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        return data;
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean;
    mobileFixedHeader: boolean;
    minimizeDesktopHeaderType: string | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;
    darkMode!: boolean;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layoutType = _data["layoutType"];
            this.darkMode = _data["darkMode"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["darkMode"] = this.darkMode;
        return data;
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
    darkMode: boolean;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean;
    allowAsideMinimizing!: boolean;
    defaultMinimizedAside!: boolean;
    submenuToggle!: string | undefined;
    searchActive!: boolean;
    enableSecondary!: boolean;
    hoverableAside!: boolean;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.asideSkin = _data["asideSkin"];
            this.fixedAside = _data["fixedAside"];
            this.allowAsideMinimizing = _data["allowAsideMinimizing"];
            this.defaultMinimizedAside = _data["defaultMinimizedAside"];
            this.submenuToggle = _data["submenuToggle"];
            this.searchActive = _data["searchActive"];
            this.enableSecondary = _data["enableSecondary"];
            this.hoverableAside = _data["hoverableAside"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        data["searchActive"] = this.searchActive;
        data["enableSecondary"] = this.enableSecondary;
        data["hoverableAside"] = this.hoverableAside;
        return data;
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    submenuToggle: string | undefined;
    searchActive: boolean;
    enableSecondary: boolean;
    hoverableAside: boolean;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto;
    header!: ThemeHeaderSettingsDto;
    subHeader!: ThemeSubHeaderSettingsDto;
    menu!: ThemeMenuSettingsDto;
    footer!: ThemeFooterSettingsDto;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
            this.layout = _data["layout"] ? ThemeLayoutSettingsDto.fromJS(_data["layout"]) : <any>undefined;
            this.header = _data["header"] ? ThemeHeaderSettingsDto.fromJS(_data["header"]) : <any>undefined;
            this.subHeader = _data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(_data["subHeader"]) : <any>undefined;
            this.menu = _data["menu"] ? ThemeMenuSettingsDto.fromJS(_data["menu"]) : <any>undefined;
            this.footer = _data["footer"] ? ThemeFooterSettingsDto.fromJS(_data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto;
    header: ThemeHeaderSettingsDto;
    subHeader: ThemeSubHeaderSettingsDto;
    menu: ThemeMenuSettingsDto;
    footer: ThemeFooterSettingsDto;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean;
    subheaderStyle!: string | undefined;
    subheaderSize!: number;
    titleStyle!: string | undefined;
    containerStyle!: string | undefined;
    subContainerStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedSubHeader = _data["fixedSubHeader"];
            this.subheaderStyle = _data["subheaderStyle"];
            this.subheaderSize = _data["subheaderSize"];
            this.titleStyle = _data["titleStyle"];
            this.containerStyle = _data["containerStyle"];
            this.subContainerStyle = _data["subContainerStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        data["subheaderSize"] = this.subheaderSize;
        data["titleStyle"] = this.titleStyle;
        data["containerStyle"] = this.containerStyle;
        data["subContainerStyle"] = this.subContainerStyle;
        return data;
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean;
    subheaderStyle: string | undefined;
    subheaderSize: number;
    titleStyle: string | undefined;
    containerStyle: string | undefined;
    subContainerStyle: string | undefined;
}

export class TopStatsData implements ITopStatsData {
    newTenantsCount!: number;
    newSubscriptionAmount!: number;
    dashboardPlaceholder1!: number;
    dashboardPlaceholder2!: number;

    constructor(data?: ITopStatsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newTenantsCount = _data["newTenantsCount"];
            this.newSubscriptionAmount = _data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = _data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = _data["dashboardPlaceholder2"];
        }
    }

    static fromJS(data: any): TopStatsData {
        data = typeof data === 'object' ? data : {};
        let result = new TopStatsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        return data;
    }
}

export interface ITopStatsData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;
}

export class TwitterExternalLoginProviderSettings implements ITwitterExternalLoginProviderSettings {
    consumerKey!: string | undefined;
    consumerSecret!: string | undefined;

    constructor(data?: ITwitterExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerKey = _data["consumerKey"];
            this.consumerSecret = _data["consumerSecret"];
        }
    }

    static fromJS(data: any): TwitterExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerKey"] = this.consumerKey;
        data["consumerSecret"] = this.consumerSecret;
        return data;
    }
}

export interface ITwitterExternalLoginProviderSettings {
    consumerKey: string | undefined;
    consumerSecret: string | undefined;
}

export class TwitterGetAccessTokenResponse implements ITwitterGetAccessTokenResponse {
    accessToken!: string | undefined;
    accessTokenSecret!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: ITwitterGetAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.accessTokenSecret = _data["accessTokenSecret"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): TwitterGetAccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetAccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["accessTokenSecret"] = this.accessTokenSecret;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ITwitterGetAccessTokenResponse {
    accessToken: string | undefined;
    accessTokenSecret: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
}

export class TwitterGetRequestTokenResponse implements ITwitterGetRequestTokenResponse {
    token!: string | undefined;
    secret!: string | undefined;
    confirmed!: boolean;
    redirectUrl!: string | undefined;

    constructor(data?: ITwitterGetRequestTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.secret = _data["secret"];
            this.confirmed = _data["confirmed"];
            this.redirectUrl = _data["redirectUrl"];
        }
    }

    static fromJS(data: any): TwitterGetRequestTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetRequestTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["secret"] = this.secret;
        data["confirmed"] = this.confirmed;
        data["redirectUrl"] = this.redirectUrl;
        return data;
    }
}

export interface ITwitterGetRequestTokenResponse {
    token: string | undefined;
    secret: string | undefined;
    confirmed: boolean;
    redirectUrl: string | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean;
    isEnabled!: boolean;
    isEmailProviderEnabled!: boolean;
    isSmsProviderEnabled!: boolean;
    isRememberBrowserEnabled!: boolean;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabledForApplication = _data["isEnabledForApplication"];
            this.isEnabled = _data["isEnabled"];
            this.isEmailProviderEnabled = _data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = _data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = _data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto;
    isLeftMenuUsed!: boolean;
    isTopMenuUsed!: boolean;
    isTabMenuUsed!: boolean;
    allowMenuScroll!: boolean;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseSettings = _data["baseSettings"] ? ThemeSettingsDto.fromJS(_data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = _data["isLeftMenuUsed"];
            this.isTopMenuUsed = _data["isTopMenuUsed"];
            this.isTabMenuUsed = _data["isTabMenuUsed"];
            this.allowMenuScroll = _data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data;
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto;
    isLeftMenuUsed: boolean;
    isTopMenuUsed: boolean;
    isTabMenuUsed: boolean;
    allowMenuScroll: boolean;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IUnblockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : new EditionEditDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class UpdateGoogleAuthenticatorKeyInput implements IUpdateGoogleAuthenticatorKeyInput {
    googleAuthenticatorKey!: string | undefined;
    authenticatorCode!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.googleAuthenticatorKey = _data["googleAuthenticatorKey"];
            this.authenticatorCode = _data["authenticatorCode"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        data["authenticatorCode"] = this.authenticatorCode;
        return data;
    }
}

export interface IUpdateGoogleAuthenticatorKeyInput {
    googleAuthenticatorKey: string | undefined;
    authenticatorCode: string | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    recoveryCodes!: string[] | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        return data;
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    recoveryCodes: string[] | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
            this.sourceName = _data["sourceName"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string | undefined;
    useGravatarProfilePicture!: boolean;
    userId!: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileToken = _data["fileToken"];
            this.useGravatarProfilePicture = _data["useGravatarProfilePicture"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["useGravatarProfilePicture"] = this.useGravatarProfilePicture;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string | undefined;
    useGravatarProfilePicture: boolean;
    userId: number | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signInToken = _data["signInToken"];
            this.encodedUserId = _data["encodedUserId"];
            this.encodedTenantId = _data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class UserDelegationDto implements IUserDelegationDto {
    username!: string | undefined;
    startTime!: DateTime;
    endTime!: DateTime;
    id!: number;

    constructor(data?: IUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserDelegationDto {
    username: string | undefined;
    startTime: DateTime;
    endTime: DateTime;
    id: number;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean;
    shouldChangePasswordOnNextLogin!: boolean;
    isTwoFactorEnabled!: boolean;
    isLockoutEnabled!: boolean;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data;
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    lockoutEndDateUtc!: DateTime | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? DateTime.fromISO(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.profilePictureId = _data["profilePictureId"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toString() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    lockoutEndDateUtc: DateTime | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean;
    creationTime: DateTime;
    id: number;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean;
    maxFailedAccessAttemptsBeforeLockout!: number;
    defaultAccountLockoutSeconds!: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = _data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = _data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userNameOrEmail = _data["userNameOrEmail"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.result = _data["result"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: DateTime;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    id!: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number;
    state!: UserNotificationState;
    notification!: TenantNotification;
    targetNotifiers!: string | undefined;
    readonly targetNotifiersList!: string[] | undefined;
    id!: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.state = _data["state"];
            this.notification = _data["notification"] ? TenantNotification.fromJS(_data["notification"]) : <any>undefined;
            this.targetNotifiers = _data["targetNotifiers"];
            if (Array.isArray(_data["targetNotifiersList"])) {
                (<any>this).targetNotifiersList = [] as any;
                for (let item of _data["targetNotifiersList"])
                    (<any>this).targetNotifiersList!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["targetNotifiers"] = this.targetNotifiers;
        if (Array.isArray(this.targetNotifiersList)) {
            data["targetNotifiersList"] = [];
            for (let item of this.targetNotifiersList)
                data["targetNotifiersList"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    targetNotifiers: string | undefined;
    targetNotifiersList: string[] | undefined;
    id: string;
}

export enum UserNotificationState {
    Unread = 0,
    Read = 1,
}

export class UserPasswordSettingsEditDto implements IUserPasswordSettingsEditDto {
    enableCheckingLastXPasswordWhenPasswordChange!: boolean;
    checkingLastXPasswordCount!: number;
    enablePasswordExpiration!: boolean;
    passwordExpirationDayCount!: number;
    passwordResetCodeExpirationHours!: number;

    constructor(data?: IUserPasswordSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableCheckingLastXPasswordWhenPasswordChange = _data["enableCheckingLastXPasswordWhenPasswordChange"];
            this.checkingLastXPasswordCount = _data["checkingLastXPasswordCount"];
            this.enablePasswordExpiration = _data["enablePasswordExpiration"];
            this.passwordExpirationDayCount = _data["passwordExpirationDayCount"];
            this.passwordResetCodeExpirationHours = _data["passwordResetCodeExpirationHours"];
        }
    }

    static fromJS(data: any): UserPasswordSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPasswordSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableCheckingLastXPasswordWhenPasswordChange"] = this.enableCheckingLastXPasswordWhenPasswordChange;
        data["checkingLastXPasswordCount"] = this.checkingLastXPasswordCount;
        data["enablePasswordExpiration"] = this.enablePasswordExpiration;
        data["passwordExpirationDayCount"] = this.passwordExpirationDayCount;
        data["passwordResetCodeExpirationHours"] = this.passwordResetCodeExpirationHours;
        return data;
    }
}

export interface IUserPasswordSettingsEditDto {
    enableCheckingLastXPasswordWhenPasswordChange: boolean;
    checkingLastXPasswordCount: number;
    enablePasswordExpiration: boolean;
    passwordExpirationDayCount: number;
    passwordResetCodeExpirationHours: number;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean;
    inheritedFromOrganizationUnit!: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDisplayName = _data["roleDisplayName"];
            this.isAssigned = _data["isAssigned"];
            this.inheritedFromOrganizationUnit = _data["inheritedFromOrganizationUnit"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        data["inheritedFromOrganizationUnit"] = this.inheritedFromOrganizationUnit;
        return data;
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
    inheritedFromOrganizationUnit: boolean;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class VerifyAuthenticatorCodeInput implements IVerifyAuthenticatorCodeInput {
    code!: string | undefined;
    googleAuthenticatorKey!: string | undefined;

    constructor(data?: IVerifyAuthenticatorCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.googleAuthenticatorKey = _data["googleAuthenticatorKey"];
        }
    }

    static fromJS(data: any): VerifyAuthenticatorCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyAuthenticatorCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        return data;
    }
}

export interface IVerifyAuthenticatorCodeInput {
    code: string | undefined;
    googleAuthenticatorKey: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class WebhookEvent implements IWebhookEvent {
    webhookName!: string;
    data!: string | undefined;
    creationTime!: DateTime;
    tenantId!: number | undefined;
    isDeleted!: boolean;
    deletionTime!: DateTime | undefined;
    id!: string;

    constructor(data?: IWebhookEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhookEvent {
    webhookName: string;
    data: string | undefined;
    creationTime: DateTime;
    tenantId: number | undefined;
    isDeleted: boolean;
    deletionTime: DateTime | undefined;
    id: string;
}

export class WebhookSubscription implements IWebhookSubscription {
    tenantId!: number | undefined;
    webhookUri!: string | undefined;
    secret!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    headers!: { [key: string]: string; } | undefined;
    id!: string;

    constructor(data?: IWebhookSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.webhookUri = _data["webhookUri"];
            this.secret = _data["secret"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["webhookUri"] = this.webhookUri;
        data["secret"] = this.secret;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhookSubscription {
    tenantId: number | undefined;
    webhookUri: string | undefined;
    secret: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    headers: { [key: string]: string; } | undefined;
    id: string;
}

export class Widget implements IWidget {
    widgetId!: string | undefined;
    height!: number;
    width!: number;
    positionX!: number;
    positionY!: number;

    constructor(data?: IWidget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
        }
    }

    static fromJS(data: any): Widget {
        data = typeof data === 'object' ? data : {};
        let result = new Widget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["height"] = this.height;
        data["width"] = this.width;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data;
    }
}

export interface IWidget {
    widgetId: string | undefined;
    height: number;
    width: number;
    positionX: number;
    positionY: number;
}

export class WidgetFilterOutput implements IWidgetFilterOutput {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IWidgetFilterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WidgetFilterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetFilterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;
}

export class WidgetOutput implements IWidgetOutput {
    id!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    filters!: WidgetFilterOutput[] | undefined;

    constructor(data?: IWidgetOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(WidgetFilterOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WidgetOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWidgetOutput {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    filters: WidgetFilterOutput[] | undefined;
}

export class WsFederationExternalLoginProviderSettings implements IWsFederationExternalLoginProviderSettings {
    clientId!: string | undefined;
    tenant!: string | undefined;
    metaDataAddress!: string | undefined;
    wtrealm!: string | undefined;
    authority!: string | undefined;

    constructor(data?: IWsFederationExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.tenant = _data["tenant"];
            this.metaDataAddress = _data["metaDataAddress"];
            this.wtrealm = _data["wtrealm"];
            this.authority = _data["authority"];
        }
    }

    static fromJS(data: any): WsFederationExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new WsFederationExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["tenant"] = this.tenant;
        data["metaDataAddress"] = this.metaDataAddress;
        data["wtrealm"] = this.wtrealm;
        data["authority"] = this.authority;
        return data;
    }
}

export interface IWsFederationExternalLoginProviderSettings {
    clientId: string | undefined;
    tenant: string | undefined;
    metaDataAddress: string | undefined;
    wtrealm: string | undefined;
    authority: string | undefined;
}

export class ZipCodeCityLookupTableDto implements IZipCodeCityLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IZipCodeCityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ZipCodeCityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZipCodeCityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IZipCodeCityLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ZipCodeCountryLookupTableDto implements IZipCodeCountryLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IZipCodeCountryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ZipCodeCountryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZipCodeCountryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IZipCodeCountryLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ZipCodeCountyLookupTableDto implements IZipCodeCountyLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IZipCodeCountyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ZipCodeCountyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZipCodeCountyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IZipCodeCountyLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ZipCodeDto implements IZipCodeDto {
    name!: string | undefined;
    areaCode!: string | undefined;
    asianPopulation!: string | undefined;
    averageHouseValue!: string | undefined;
    blackPopulation!: string | undefined;
    cbsa!: string | undefined;
    cbsA_Div!: string | undefined;
    cbsA_Div_Name!: string | undefined;
    cbsA_Name!: string | undefined;
    cbsA_Type!: string | undefined;
    csa!: string | undefined;
    csaName!: string | undefined;
    carrierRouteRateSortation!: string | undefined;
    city!: string | undefined;
    cityAliasCode!: string | undefined;
    cityAliasMixedCase!: string | undefined;
    cityAliasName!: string | undefined;
    cityDeliveryIndicator!: string | undefined;
    cityMixedCase!: string | undefined;
    cityStateKey!: string | undefined;
    cityType!: string | undefined;
    classificationCode!: string | undefined;
    county!: string | undefined;
    countyANSI!: string | undefined;
    countyFIPS!: string | undefined;
    countyMixedCase!: string | undefined;
    dayLightSaving!: string | undefined;
    division!: string | undefined;
    elevation!: string | undefined;
    facilityCode!: string | undefined;
    femalePopulation!: string | undefined;
    financeNumber!: string | undefined;
    hawaiianPopulation!: string | undefined;
    hispanicPopulation!: string | undefined;
    householdsPerZipCode!: string | undefined;
    incomePerHousehold!: string | undefined;
    indianPopulation!: string | undefined;
    latitude!: string | undefined;
    longitude!: string | undefined;
    msa!: string | undefined;
    msA_Name!: string | undefined;
    mailingName!: string | undefined;
    malePopulation!: string | undefined;
    multiCounty!: string | undefined;
    otherPopulation!: string | undefined;
    pmsa!: string | undefined;
    pmsA_Name!: string | undefined;
    personsPerHousehold!: string | undefined;
    population!: string | undefined;
    preferredLastLineKey!: string | undefined;
    primaryRecord!: string | undefined;
    region!: string | undefined;
    state!: string | undefined;
    stateANSI!: string | undefined;
    stateFIPS!: string | undefined;
    stateFullName!: string | undefined;
    timeZone!: string | undefined;
    uniqueZIPName!: string | undefined;
    whitePopulation!: string | undefined;
    countryId!: number | undefined;
    stateId!: number | undefined;
    cityId!: number | undefined;
    countyId!: number | undefined;
    id!: number;

    constructor(data?: IZipCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.areaCode = _data["areaCode"];
            this.asianPopulation = _data["asianPopulation"];
            this.averageHouseValue = _data["averageHouseValue"];
            this.blackPopulation = _data["blackPopulation"];
            this.cbsa = _data["cbsa"];
            this.cbsA_Div = _data["cbsA_Div"];
            this.cbsA_Div_Name = _data["cbsA_Div_Name"];
            this.cbsA_Name = _data["cbsA_Name"];
            this.cbsA_Type = _data["cbsA_Type"];
            this.csa = _data["csa"];
            this.csaName = _data["csaName"];
            this.carrierRouteRateSortation = _data["carrierRouteRateSortation"];
            this.city = _data["city"];
            this.cityAliasCode = _data["cityAliasCode"];
            this.cityAliasMixedCase = _data["cityAliasMixedCase"];
            this.cityAliasName = _data["cityAliasName"];
            this.cityDeliveryIndicator = _data["cityDeliveryIndicator"];
            this.cityMixedCase = _data["cityMixedCase"];
            this.cityStateKey = _data["cityStateKey"];
            this.cityType = _data["cityType"];
            this.classificationCode = _data["classificationCode"];
            this.county = _data["county"];
            this.countyANSI = _data["countyANSI"];
            this.countyFIPS = _data["countyFIPS"];
            this.countyMixedCase = _data["countyMixedCase"];
            this.dayLightSaving = _data["dayLightSaving"];
            this.division = _data["division"];
            this.elevation = _data["elevation"];
            this.facilityCode = _data["facilityCode"];
            this.femalePopulation = _data["femalePopulation"];
            this.financeNumber = _data["financeNumber"];
            this.hawaiianPopulation = _data["hawaiianPopulation"];
            this.hispanicPopulation = _data["hispanicPopulation"];
            this.householdsPerZipCode = _data["householdsPerZipCode"];
            this.incomePerHousehold = _data["incomePerHousehold"];
            this.indianPopulation = _data["indianPopulation"];
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.msa = _data["msa"];
            this.msA_Name = _data["msA_Name"];
            this.mailingName = _data["mailingName"];
            this.malePopulation = _data["malePopulation"];
            this.multiCounty = _data["multiCounty"];
            this.otherPopulation = _data["otherPopulation"];
            this.pmsa = _data["pmsa"];
            this.pmsA_Name = _data["pmsA_Name"];
            this.personsPerHousehold = _data["personsPerHousehold"];
            this.population = _data["population"];
            this.preferredLastLineKey = _data["preferredLastLineKey"];
            this.primaryRecord = _data["primaryRecord"];
            this.region = _data["region"];
            this.state = _data["state"];
            this.stateANSI = _data["stateANSI"];
            this.stateFIPS = _data["stateFIPS"];
            this.stateFullName = _data["stateFullName"];
            this.timeZone = _data["timeZone"];
            this.uniqueZIPName = _data["uniqueZIPName"];
            this.whitePopulation = _data["whitePopulation"];
            this.countryId = _data["countryId"];
            this.stateId = _data["stateId"];
            this.cityId = _data["cityId"];
            this.countyId = _data["countyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ZipCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZipCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["areaCode"] = this.areaCode;
        data["asianPopulation"] = this.asianPopulation;
        data["averageHouseValue"] = this.averageHouseValue;
        data["blackPopulation"] = this.blackPopulation;
        data["cbsa"] = this.cbsa;
        data["cbsA_Div"] = this.cbsA_Div;
        data["cbsA_Div_Name"] = this.cbsA_Div_Name;
        data["cbsA_Name"] = this.cbsA_Name;
        data["cbsA_Type"] = this.cbsA_Type;
        data["csa"] = this.csa;
        data["csaName"] = this.csaName;
        data["carrierRouteRateSortation"] = this.carrierRouteRateSortation;
        data["city"] = this.city;
        data["cityAliasCode"] = this.cityAliasCode;
        data["cityAliasMixedCase"] = this.cityAliasMixedCase;
        data["cityAliasName"] = this.cityAliasName;
        data["cityDeliveryIndicator"] = this.cityDeliveryIndicator;
        data["cityMixedCase"] = this.cityMixedCase;
        data["cityStateKey"] = this.cityStateKey;
        data["cityType"] = this.cityType;
        data["classificationCode"] = this.classificationCode;
        data["county"] = this.county;
        data["countyANSI"] = this.countyANSI;
        data["countyFIPS"] = this.countyFIPS;
        data["countyMixedCase"] = this.countyMixedCase;
        data["dayLightSaving"] = this.dayLightSaving;
        data["division"] = this.division;
        data["elevation"] = this.elevation;
        data["facilityCode"] = this.facilityCode;
        data["femalePopulation"] = this.femalePopulation;
        data["financeNumber"] = this.financeNumber;
        data["hawaiianPopulation"] = this.hawaiianPopulation;
        data["hispanicPopulation"] = this.hispanicPopulation;
        data["householdsPerZipCode"] = this.householdsPerZipCode;
        data["incomePerHousehold"] = this.incomePerHousehold;
        data["indianPopulation"] = this.indianPopulation;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["msa"] = this.msa;
        data["msA_Name"] = this.msA_Name;
        data["mailingName"] = this.mailingName;
        data["malePopulation"] = this.malePopulation;
        data["multiCounty"] = this.multiCounty;
        data["otherPopulation"] = this.otherPopulation;
        data["pmsa"] = this.pmsa;
        data["pmsA_Name"] = this.pmsA_Name;
        data["personsPerHousehold"] = this.personsPerHousehold;
        data["population"] = this.population;
        data["preferredLastLineKey"] = this.preferredLastLineKey;
        data["primaryRecord"] = this.primaryRecord;
        data["region"] = this.region;
        data["state"] = this.state;
        data["stateANSI"] = this.stateANSI;
        data["stateFIPS"] = this.stateFIPS;
        data["stateFullName"] = this.stateFullName;
        data["timeZone"] = this.timeZone;
        data["uniqueZIPName"] = this.uniqueZIPName;
        data["whitePopulation"] = this.whitePopulation;
        data["countryId"] = this.countryId;
        data["stateId"] = this.stateId;
        data["cityId"] = this.cityId;
        data["countyId"] = this.countyId;
        data["id"] = this.id;
        return data;
    }
}

export interface IZipCodeDto {
    name: string | undefined;
    areaCode: string | undefined;
    asianPopulation: string | undefined;
    averageHouseValue: string | undefined;
    blackPopulation: string | undefined;
    cbsa: string | undefined;
    cbsA_Div: string | undefined;
    cbsA_Div_Name: string | undefined;
    cbsA_Name: string | undefined;
    cbsA_Type: string | undefined;
    csa: string | undefined;
    csaName: string | undefined;
    carrierRouteRateSortation: string | undefined;
    city: string | undefined;
    cityAliasCode: string | undefined;
    cityAliasMixedCase: string | undefined;
    cityAliasName: string | undefined;
    cityDeliveryIndicator: string | undefined;
    cityMixedCase: string | undefined;
    cityStateKey: string | undefined;
    cityType: string | undefined;
    classificationCode: string | undefined;
    county: string | undefined;
    countyANSI: string | undefined;
    countyFIPS: string | undefined;
    countyMixedCase: string | undefined;
    dayLightSaving: string | undefined;
    division: string | undefined;
    elevation: string | undefined;
    facilityCode: string | undefined;
    femalePopulation: string | undefined;
    financeNumber: string | undefined;
    hawaiianPopulation: string | undefined;
    hispanicPopulation: string | undefined;
    householdsPerZipCode: string | undefined;
    incomePerHousehold: string | undefined;
    indianPopulation: string | undefined;
    latitude: string | undefined;
    longitude: string | undefined;
    msa: string | undefined;
    msA_Name: string | undefined;
    mailingName: string | undefined;
    malePopulation: string | undefined;
    multiCounty: string | undefined;
    otherPopulation: string | undefined;
    pmsa: string | undefined;
    pmsA_Name: string | undefined;
    personsPerHousehold: string | undefined;
    population: string | undefined;
    preferredLastLineKey: string | undefined;
    primaryRecord: string | undefined;
    region: string | undefined;
    state: string | undefined;
    stateANSI: string | undefined;
    stateFIPS: string | undefined;
    stateFullName: string | undefined;
    timeZone: string | undefined;
    uniqueZIPName: string | undefined;
    whitePopulation: string | undefined;
    countryId: number | undefined;
    stateId: number | undefined;
    cityId: number | undefined;
    countyId: number | undefined;
    id: number;
}

export class ZipCodeStateLookupTableDto implements IZipCodeStateLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IZipCodeStateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ZipCodeStateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZipCodeStateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IZipCodeStateLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}